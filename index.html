<!DOCTYPE html>
<html lang="vi">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Quản Lý Truyện AI</title>
    <link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.5.2/css/bootstrap.min.css">
    <style>
        body {
            font-family: 'Helvetica Neue', Arial, sans-serif;
            padding-bottom: 60px; /* Space for bottom nav */
            background-color: #f8f9fa;
        }
        #content {
            padding: 20px;
        }
        .bottom-nav {
            position: fixed;
            bottom: 0;
            left: 0;
            width: 100%;
            background-color: #ffffff;
            border-top: 1px solid #dee2e6;
            display: flex;
            justify-content: space-around;
            align-items: center;
            height: 60px;
            box-shadow: 0 -2px 5px rgba(0,0,0,0.1);
        }
        .bottom-nav a {
            text-decoration: none;
            color: #333;
            font-size: 14px;
            display: flex;
            flex-direction: column;
            align-items: center;
        }
        .bottom-nav a:hover {
            color: #007bff;
        }
        button {
            margin: 10px 0;
        }
        /* iPhone-specific adjustments */
        @media only screen and (max-device-width: 812px) and (-webkit-device-pixel-ratio: 3) {
            body {
                font-size: 16px;
            }
            .bottom-nav {
                height: 70px; /* Taller for better touch */
            }
        }
    </style>
</head>
<body>
    <div id="content">
        <h1>Chào mừng đến với Quản Lý Truyện AI</h1>
        <p>Vui lòng đăng nhập để sử dụng.</p>
        <button id="authorize_button" class="btn btn-primary" onclick="handleAuthClick()">Đăng Nhập Google</button>
    </div>
    <div class="bottom-nav">
        <a href="#" onclick="showHome()"><span>Home</span></a>
        <a href="#" onclick="analyze()"><span>Phân Tích</span></a>
        <a href="#" onclick="generate()"><span>Tạo Truyện</span></a>
        <a href="#" onclick="addStory()"><span>Thêm Truyện</span></a>
    </div>

    <script src="https://apis.google.com/js/api.js" onload="gapiLoaded()"></script>
    <script async defer src="https://accounts.google.com/gsi/client" onload="gisLoaded()"></script>
    <script src="https://unpkg.com/ml5@latest/dist/ml5.min.js"></script> <!-- ml5 for potential extensions, though core uses custom Markov -->
    <script>
        const CLIENT_ID = '398509518475-7bjid324tkuuh9gv8b0g92lhsgv8nrl5.apps.googleusercontent.com';
        const API_KEY = 'AIzaSyAbcWr0UPvC4YpsunE6uAa7E5pan9iys2o';
        const DISCOVERY_DOC = 'https://www.googleapis.com/discovery/v1/apis/drive/v3/rest';
        const SCOPES = 'https://www.googleapis.com/auth/drive';

        let tokenClient;
        let gapiInited = false;
        let gisInited = false;

        function gapiLoaded() {
            gapi.load('client', initializeGapiClient);
        }

        async function initializeGapiClient() {
            await gapi.client.init({
                apiKey: API_KEY,
                discoveryDocs: [DISCOVERY_DOC],
            });
            gapiInited = true;
            maybeEnableButtons();
        }

        function gisLoaded() {
            tokenClient = google.accounts.oauth2.initTokenClient({
                client_id: CLIENT_ID,
                scope: SCOPES,
                callback: '', // defined later
            });
            gisInited = true;
            maybeEnableButtons();
        }

        function maybeEnableButtons() {
            if (gapiInited && gisInited) {
                document.getElementById('authorize_button').style.display = 'block';
            }
        }

        function handleAuthClick() {
            tokenClient.callback = async (resp) => {
                if (resp.error !== undefined) {
                    throw (resp);
                }
                document.getElementById('authorize_button').style.display = 'none';
                alert('Đăng nhập thành công!');
            };
            if (gapi.client.getToken() === null) {
                tokenClient.requestAccessToken({prompt: 'consent'});
            } else {
                tokenClient.requestAccessToken({prompt: ''});
            }
        }

        async function getFolderId(name) {
            const response = await gapi.client.drive.files.list({
                q: `name='${name}' and mimeType='application/vnd.google-apps.folder' and trashed=false`,
                fields: 'files(id, name)',
            });
            if (response.result.files && response.result.files.length > 0) {
                return response.result.files[0].id;
            }
            return null;
        }

        async function listTxtFiles(folderId) {
            const response = await gapi.client.drive.files.list({
                q: `'${folderId}' in parents and mimeType='text/plain' and trashed=false`,
                fields: 'files(id, name)',
            });
            return response.result.files || [];
        }

        async function downloadFile(fileId) {
            const response = await gapi.client.drive.files.get({
                fileId: fileId,
                alt: 'media'
            }, {responseType: 'text'});
            return response.body;
        }

        function cleanVietnamese(text) {
            // Lọc để giữ chữ cái Việt Nam, số, dấu câu, khoảng trắng; loại bỏ các ký tự lạ
            return text.replace(/[^\p{L}\p{N}\p{P}\p{Zs}\u00C0-\u1EF9]/gu, ' ').replace(/\s+/g, ' ').trim();
        }

        async function collectTexts() {
            const folderId = await getFolderId('QuanLyTruyen');
            if (!folderId) {
                alert('Không tìm thấy thư mục QuanLyTruyen');
                return '';
            }
            const files = await listTxtFiles(folderId);
            let allText = '';
            for (let file of files) {
                let text = await downloadFile(file.id);
                text = cleanVietnamese(text);
                allText += text + ' ';
            }
            return allText;
        }

        class Markov {
            constructor(order) {
                this.order = order;
                this.transitions = {};
                this.starts = [];
            }

            train(text) {
                const words = text.split(/\s+/).filter(w => w.length > 0);
                for (let i = 0; i < words.length - this.order; i++) {
                    const key = words.slice(i, i + this.order).join(' ');
                    const next = words[i + this.order];
                    if (!this.transitions[key]) {
                        this.transitions[key] = [];
                    }
                    this.transitions[key].push(next);
                    if (i === 0 || /[.!?]$/.test(words[i - 1])) { // Bắt đầu câu mới
                        if (key.startsWith('Tôi')) { // Ưu tiên khởi đầu ngôi thứ nhất
                            this.starts.push(key);
                        }
                    }
                }
                if (this.starts.length === 0) {
                    this.starts = Object.keys(this.transitions); // Fallback
                }
            }

            generate(length) {
                if (this.starts.length === 0) return '';
                let current = this.starts[Math.floor(Math.random() * this.starts.length)];
                let result = current;
                for (let i = 0; i < length - this.order; i++) {
                    const possibilities = this.transitions[current];
                    if (!possibilities || possibilities.length === 0) break;
                    const next = possibilities[Math.floor(Math.random() * possibilities.length)];
                    result += ' ' + next;
                    current = result.split(' ').slice(-this.order).join(' ');
                }
                return result;
            }
        }

        async function getModelFileId(folderId) {
            const response = await gapi.client.drive.files.list({
                q: `'${folderId}' in parents and name='model.json' and trashed=false`,
                fields: 'files(id)',
            });
            if (response.result.files && response.result.files.length > 0) {
                return response.result.files[0].id;
            }
            return null;
        }

        async function loadModel() {
            const folderId = await getFolderId('QuanLyTruyen');
            const modelId = await getModelFileId(folderId);
            if (!modelId) return null;
            const json = await downloadFile(modelId);
            const {order, transitions, starts} = JSON.parse(json);
            const markov = new Markov(order);
            markov.transitions = transitions;
            markov.starts = starts;
            return markov;
        }

        async function saveModel(markov, folderId) {
            const data = {
                order: markov.order,
                transitions: markov.transitions,
                starts: markov.starts
            };
            const json = JSON.stringify(data);
            await uploadFile('model.json', json, folderId, 'application/json');
        }

        async function uploadFile(name, content, folderId, mimeType = 'text/plain') {
            const fileMetadata = {
                name: name,
                parents: [folderId]
            };
            const media = {
                mimeType: mimeType,
                body: content
            };
            const response = await gapi.client.drive.files.create({
                resource: fileMetadata,
                media: media,
                fields: 'id'
            });
            return response.result.id;
        }

        async function createFolder(name, parentId) {
            const metadata = {
                name: name,
                mimeType: 'application/vnd.google-apps.folder',
                parents: [parentId]
            };
            const response = await gapi.client.drive.files.create({
                resource: metadata,
                fields: 'id'
            });
            return response.result.id;
        }

        async function analyze() {
            if (!gapi.client.getToken()) {
                alert('Vui lòng đăng nhập trước');
                return;
            }
            document.getElementById('content').innerHTML = '<p>Đang phân tích và học...</p>';
            const text = await collectTexts();
            if (!text) return;
            const markov = new Markov(4); // Order 4 để tăng tính logic và mạch lạc
            markov.train(text);
            const folderId = await getFolderId('QuanLyTruyen');
            await saveModel(markov, folderId);
            document.getElementById('content').innerHTML = '<p>Phân tích và lưu mô hình thành công! Bây giờ bạn có thể tạo truyện.</p>';
        }

        async function generate() {
            if (!gapi.client.getToken()) {
                alert('Vui lòng đăng nhập trước');
                return;
            }
            document.getElementById('content').innerHTML = '<p>Đang tải mô hình và tạo truyện...</p>';
            let markov = await loadModel();
            if (!markov) {
                alert('Vui lòng phân tích trước để tạo mô hình');
                return;
            }
            const numChapters = 50;
            const minWordsPerChapter = 2000;
            const maxWordsPerChapter = 3000;
            let chapters = [];
            for (let i = 1; i <= numChapters; i++) {
                const wordsPerChapter = Math.floor(Math.random() * (maxWordsPerChapter - minWordsPerChapter + 1)) + minWordsPerChapter;
                let chapterText = markov.generate(wordsPerChapter);
                // Đảm bảo ngôi thứ nhất: Bắt đầu bằng 'Tôi' nếu chưa
                if (!chapterText.startsWith('Tôi')) {
                    chapterText = 'Tôi ' + chapterText.slice(0, -3) + '...'; // Cắt bớt để giữ độ dài
                }
                // Lọc lại để thuần Việt
                chapterText = cleanVietnamese(chapterText);
                chapters.push(chapterText);
            }
            // Tạo tên truyện ngẫu nhiên nhưng logic từ mô hình
            const storyTitle = 'Câu Chuyện ' + markov.generate(3).split(' ').map(w => w.charAt(0).toUpperCase() + w.slice(1)).join(' ');
            const folderId = await getFolderId('QuanLyTruyen');
            const storyFolderId = await createFolder(storyTitle, folderId);
            // Upload từng chương
            for (let i = 0; i < chapters.length; i++) {
                const chapterName = `Chương ${i + 1}: ${markov.generate(4)}`; // Tên chương từ generate ngắn
                await uploadFile(`${chapterName}.txt`, chapters[i], storyFolderId);
            }
            document.getElementById('content').innerHTML = `<p>Truyện đã được tạo và upload vào thư mục "${storyTitle}"!</p>`;
        }

        function showHome() {
            document.getElementById('content').innerHTML = '<h1>Chào mừng đến với Quản Lý Truyện AI</h1><p>Sử dụng menu dưới để bắt đầu.</p>';
        }

        function addStory() {
            document.getElementById('content').innerHTML = `
                <h2>Thêm Truyện</h2>
                <button class="btn btn-success" onclick="generateNew()">Tạo Truyện Mới (AI Sinh)</button>
                <hr>
                <h3>Upload Truyện Đã Có</h3>
                <input type="file" id="uploadFile" accept=".txt" class="form-control">
                <button class="btn btn-primary" onclick="uploadExisting()">Upload</button>
            `;
        }

        function generateNew() {
            generate();
        }

        async function uploadExisting() {
            if (!gapi.client.getToken()) {
                alert('Vui lòng đăng nhập trước');
                return;
            }
            const fileInput = document.getElementById('uploadFile');
            if (!fileInput.files.length) {
                alert('Vui lòng chọn file .txt');
                return;
            }
            const file = fileInput.files[0];
            const content = await file.text();
            const cleanedContent = cleanVietnamese(content);
            const folderId = await getFolderId('QuanLyTruyen');
            await uploadFile(file.name, cleanedContent, folderId);
            alert('Upload thành công!');
        }
    </script>
</body>
</html>
