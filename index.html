<!DOCTYPE html>
<html lang="vi">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Tr√¨nh Ph√¢n T√≠ch Truy·ªán AI</title>
    <script src="https://apis.google.com/js/api.js"></script>
    <script src="https://accounts.google.com/gsi/client"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            color: #333;
        }

        .container {
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
        }

        .header {
            text-align: center;
            margin-bottom: 30px;
            color: white;
        }

        .header h1 {
            font-size: 2.5em;
            margin-bottom: 10px;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.3);
        }

        .header p {
            font-size: 1.2em;
            opacity: 0.9;
        }

        .auth-section {
            background: white;
            border-radius: 15px;
            padding: 30px;
            margin-bottom: 30px;
            box-shadow: 0 15px 35px rgba(0,0,0,0.1);
            text-align: center;
        }

        .login-btn {
            background: linear-gradient(45deg, #4285f4, #34a853);
            color: white;
            border: none;
            padding: 15px 30px;
            border-radius: 50px;
            font-size: 1.1em;
            cursor: pointer;
            transition: all 0.3s ease;
            box-shadow: 0 5px 15px rgba(0,0,0,0.2);
        }

        .login-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 8px 25px rgba(0,0,0,0.3);
        }

        .status-section {
            background: white;
            border-radius: 15px;
            padding: 20px;
            margin-bottom: 30px;
            box-shadow: 0 15px 35px rgba(0,0,0,0.1);
        }

        .control-panel {
            background: white;
            border-radius: 15px;
            padding: 30px;
            margin-bottom: 30px;
            box-shadow: 0 15px 35px rgba(0,0,0,0.1);
        }

        .control-btn {
            background: linear-gradient(45deg, #ff6b6b, #ee5a24);
            color: white;
            border: none;
            padding: 12px 25px;
            border-radius: 25px;
            font-size: 1em;
            cursor: pointer;
            margin: 5px;
            transition: all 0.3s ease;
        }

        .control-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(0,0,0,0.2);
        }

        .control-btn:disabled {
            background: #ccc;
            cursor: not-allowed;
            transform: none;
        }

        .analysis-section {
            background: white;
            border-radius: 15px;
            padding: 30px;
            margin-bottom: 30px;
            box-shadow: 0 15px 35px rgba(0,0,0,0.1);
        }

        .file-card {
            background: #f8f9fa;
            border: 1px solid #dee2e6;
            border-radius: 10px;
            padding: 20px;
            margin-bottom: 20px;
            transition: all 0.3s ease;
        }

        .file-card:hover {
            box-shadow: 0 5px 15px rgba(0,0,0,0.1);
            transform: translateY(-2px);
        }

        .file-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 15px;
        }

        .file-name {
            font-weight: bold;
            color: #495057;
            font-size: 1.1em;
        }

        .analysis-content {
            line-height: 1.6;
            color: #666;
        }

        .analysis-section h3 {
            color: #495057;
            margin-bottom: 10px;
            padding-bottom: 5px;
            border-bottom: 2px solid #007bff;
        }

        .progress-bar {
            width: 100%;
            height: 20px;
            background: #e9ecef;
            border-radius: 10px;
            overflow: hidden;
            margin: 10px 0;
        }

        .progress-fill {
            height: 100%;
            background: linear-gradient(45deg, #28a745, #20c997);
            width: 0%;
            transition: width 0.3s ease;
        }

        .loading {
            display: inline-block;
            width: 20px;
            height: 20px;
            border: 3px solid #f3f3f3;
            border-top: 3px solid #3498db;
            border-radius: 50%;
            animation: spin 1s linear infinite;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        .story-output {
            background: #f8f9fa;
            border-left: 4px solid #007bff;
            padding: 20px;
            margin: 15px 0;
            border-radius: 0 10px 10px 0;
            white-space: pre-wrap;
            font-family: 'Times New Roman', serif;
            line-height: 1.8;
        }

        .hidden {
            display: none;
        }

        .error {
            background: #f8d7da;
            color: #721c24;
            border: 1px solid #f5c6cb;
            padding: 10px;
            border-radius: 5px;
            margin: 10px 0;
        }

        .success {
            background: #d4edda;
            color: #155724;
            border: 1px solid #c3e6cb;
            padding: 10px;
            border-radius: 5px;
            margin: 10px 0;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>ü§ñ Tr√¨nh Ph√¢n T√≠ch Truy·ªán AI</h1>
            <p>Ph√¢n t√≠ch v√† t·∫°o truy·ªán th√¥ng minh t·ª´ Google Drive</p>
        </div>

        <div class="auth-section">
            <div id="loginSection">
                <h2>ƒêƒÉng nh·∫≠p Google Drive</h2>
                <p>K·∫øt n·ªëi v·ªõi Google Drive ƒë·ªÉ truy c·∫≠p th∆∞ m·ª•c "QuanLyTruyen"</p>
                <br>
                <button class="login-btn" onclick="handleAuthClick()">
                    üìÅ ƒêƒÉng nh·∫≠p Google Drive
                </button>
            </div>
            <div id="loggedInSection" class="hidden">
                <h2>‚úÖ ƒê√£ k·∫øt n·ªëi th√†nh c√¥ng!</h2>
                <p id="userInfo"></p>
                <button class="control-btn" onclick="handleSignoutClick()">ƒêƒÉng xu·∫•t</button>
            </div>
        </div>

        <div class="status-section">
            <h3>üìä Tr·∫°ng th√°i h·ªá th·ªëng</h3>
            <div id="statusInfo">
                <p>üî¥ Ch∆∞a k·∫øt n·ªëi Google Drive</p>
            </div>
            <div class="progress-bar">
                <div class="progress-fill" id="progressBar"></div>
            </div>
        </div>

        <div class="control-panel">
            <h3>üéÆ B·∫£ng ƒëi·ªÅu khi·ªÉn</h3>
            <button class="control-btn" id="scanBtn" onclick="scanFolder()" disabled>
                üîç Qu√©t th∆∞ m·ª•c QuanLyTruyen (200 file, ƒë·ªá quy)
            </button>
            <button class="control-btn" id="clearCacheBtn" onclick="clearCache()" disabled>
                üóëÔ∏è X√≥a cache v√† qu√©t l·∫°i
            </button>
            <button class="control-btn" id="analyzeBtn" onclick="analyzeFiles()" disabled>
                üß† Ph√¢n t√≠ch t·∫•t c·∫£ file
            </button>
            <button class="control-btn" id="generateBtn" onclick="generateStories()" disabled>
                ‚úçÔ∏è T·∫°o truy·ªán t·ª´ ph√¢n t√≠ch
            </button>
            <button class="control-btn" id="saveBtn" onclick="saveToGoogleDrive()" disabled>
                üíæ L∆∞u k·∫øt qu·∫£ l√™n Drive
            </button>
        </div>

        <div class="analysis-section">
            <h3>üìù K·∫øt qu·∫£ ph√¢n t√≠ch v√† truy·ªán ƒë∆∞·ª£c t·∫°o</h3>
            <div id="analysisResults">
                <p>Ch∆∞a c√≥ d·ªØ li·ªáu ph√¢n t√≠ch. Vui l√≤ng qu√©t v√† ph√¢n t√≠ch th∆∞ m·ª•c tr∆∞·ªõc.</p>
            </div>
        </div>
    </div>

    <script>
        // Google API Configuration
        const CLIENT_ID = '398509518475-7bjid324tkuuh9gv8b0g92lhsgv8nrl5.apps.googleusercontent.com'; // Thay th·∫ø b·∫±ng Client ID th·ª±c t·∫ø
        const API_KEY = 'AIzaSyAbcWr0UPvC4YpsunE6uAa7E5pan9iys2o'; // Thay th·∫ø b·∫±ng API Key th·ª±c t·∫ø
        const DISCOVERY_DOC = 'https://www.googleapis.com/discovery/v1/apis/drive/v3/rest';
        const SCOPES = 'https://www.googleapis.com/auth/drive';

        let tokenClient;
        let gapi_inited = false;
        let gsi_inited = false;

        // Global variables
        let analysisData = [];
        let generatedStories = [];

        // Initialize Google APIs
        function gapiLoaded() {
            gapi.load('client', initializeGapiClient);
        }

        async function initializeGapiClient() {
            await gapi.client.init({
                apiKey: API_KEY,
                discoveryDocs: [DISCOVERY_DOC],
            });
            gapi_inited = true;
            maybeEnableButtons();
        }

        function gisLoaded() {
            tokenClient = google.accounts.oauth2.initTokenClient({
                client_id: CLIENT_ID,
                scope: SCOPES,
                callback: '',
            });
            gsi_inited = true;
            maybeEnableButtons();
        }

        function maybeEnableButtons() {
            if (gapi_inited && gsi_inited) {
                document.getElementById('scanBtn').disabled = false;
            }
        }

        // Authentication functions
        function handleAuthClick() {
            tokenClient.callback = async (resp) => {
                if (resp.error !== undefined) {
                    throw (resp);
                }
                await showLoggedInState();
            };

            if (gapi.client.getToken() === null) {
                tokenClient.requestAccessToken({prompt: 'consent'});
            } else {
                tokenClient.requestAccessToken({prompt: ''});
            }
        }

        function handleSignoutClick() {
            const token = gapi.client.getToken();
            if (token !== null) {
                google.accounts.oauth2.revoke(token.access_token);
                gapi.client.setToken('');
                showLoggedOutState();
            }
        }

        async function showLoggedInState() {
            document.getElementById('loginSection').classList.add('hidden');
            document.getElementById('loggedInSection').classList.remove('hidden');
            document.getElementById('statusInfo').innerHTML = '<p>üü¢ ƒê√£ k·∫øt n·ªëi Google Drive</p>';
            
            document.getElementById('scanBtn').disabled = false;
            document.getElementById('clearCacheBtn').disabled = false;
            
            // Get user info
            try {
                const response = await gapi.client.request({
                    path: 'https://www.googleapis.com/oauth2/v1/userinfo',
                });
                document.getElementById('userInfo').textContent = `Xin ch√†o, ${response.result.name}!`;
            } catch (error) {
                console.error('Error getting user info:', error);
            }
        }

        function showLoggedOutState() {
            document.getElementById('loginSection').classList.remove('hidden');
            document.getElementById('loggedInSection').classList.add('hidden');
            document.getElementById('statusInfo').innerHTML = '<p>üî¥ Ch∆∞a k·∫øt n·ªëi Google Drive</p>';
            
            // Disable all buttons
            document.getElementById('scanBtn').disabled = true;
            document.getElementById('clearCacheBtn').disabled = true;
            document.getElementById('analyzeBtn').disabled = true;
            document.getElementById('generateBtn').disabled = true;
            document.getElementById('saveBtn').disabled = true;
        }

        // Clear cache function
        async function clearCache() {
            const confirmClear = confirm('B·∫°n c√≥ ch·∫Øc ch·∫Øn mu·ªën x√≥a cache v√† qu√©t l·∫°i kh√¥ng?');
            if (!confirmClear) return;
            
            updateStatus('üóëÔ∏è ƒêang x√≥a cache...');
            updateProgress(20);
            
            try {
                const response = await gapi.client.drive.files.list({
                    q: `name='${CACHE_FILE_NAME}' and trashed=false`,
                    fields: 'files(id)'
                });
                
                if (response.result.files.length > 0) {
                    await gapi.client.drive.files.delete({
                        fileId: response.result.files[0].id
                    });
                }
                
                updateProgress(50);
                updateStatus('‚úÖ ƒê√£ x√≥a cache, b·∫Øt ƒë·∫ßu qu√©t m·ªõi...');
                
                // Clear local cache
                scanCache = {};
                window.txtFiles = [];
                
                updateProgress(70);
                
                // Start fresh scan
                setTimeout(() => scanFolder(), 1000);
                
            } catch (error) {
                console.error('Error clearing cache:', error);
                updateStatus(`‚ùå L·ªói x√≥a cache: ${error.message}`);
                updateProgress(0);
            }
        }

        // Cache management
        let scanCache = {};
        const CACHE_FILE_NAME = 'ScanCache_QuanLyTruyen.json';

        // File scanning functions
        async function scanFolder() {
            updateProgress(5);
            updateStatus('üîç Ki·ªÉm tra cache qu√©t tr∆∞·ªõc ƒë√≥...');
            
            try {
                // First check if cache exists
                const cacheExists = await checkCacheExists();
                if (cacheExists) {
                    const useCache = confirm('ƒê√£ t√¨m th·∫•y k·∫øt qu·∫£ qu√©t tr∆∞·ªõc ƒë√≥. B·∫°n c√≥ mu·ªën s·ª≠ d·ª•ng cache kh√¥ng?\n(Ch·ªçn "Cancel" ƒë·ªÉ qu√©t l·∫°i to√†n b·ªô)');
                    if (useCache) {
                        await loadFromCache();
                        return;
                    }
                }
                
                updateProgress(10);
                updateStatus('üîç ƒêang qu√©t th∆∞ m·ª•c QuanLyTruyen v√† t·∫•t c·∫£ th∆∞ m·ª•c con...');
                
                // Find the QuanLyTruyen folder
                const folderResponse = await gapi.client.drive.files.list({
                    q: "name='QuanLyTruyen' and mimeType='application/vnd.google-apps.folder'",
                    fields: 'files(id, name)'
                });
                
                if (folderResponse.result.files.length === 0) {
                    throw new Error('Kh√¥ng t√¨m th·∫•y th∆∞ m·ª•c QuanLyTruyen');
                }
                
                const folderId = folderResponse.result.files[0].id;
                updateProgress(20);
                
                // Scan recursively for all txt files
                updateStatus('üîç Qu√©t ƒë·ªá quy t·∫•t c·∫£ th∆∞ m·ª•c con...');
                const allTxtFiles = await scanFolderRecursive(folderId);
                
                updateProgress(80);
                updateStatus(`‚úÖ T√¨m th·∫•y ${allTxtFiles.length} file txt trong t·∫•t c·∫£ th∆∞ m·ª•c con`);
                
                // Store files and cache info
                window.txtFiles = allTxtFiles;
                scanCache = {
                    timestamp: new Date().toISOString(),
                    totalFiles: allTxtFiles.length,
                    files: allTxtFiles,
                    folderStructure: await buildFolderStructure(folderId)
                };
                
                // Save cache to Google Drive
                await saveCacheToGoogleDrive();
                
                document.getElementById('analyzeBtn').disabled = false;
                updateProgress(100);
                
                displayScanResults(allTxtFiles);
                setTimeout(() => updateProgress(0), 2000);
                
            } catch (error) {
                console.error('Error scanning folder:', error);
                updateStatus(`‚ùå L·ªói: ${error.message}`);
                updateProgress(0);
            }
        }

        async function scanFolderRecursive(folderId, depth = 0, maxDepth = 10) {
            if (depth > maxDepth) {
                console.warn(`ƒê·∫°t ƒë·ªô s√¢u t·ªëi ƒëa ${maxDepth}, d·ª´ng qu√©t`);
                return [];
            }
            
            let allFiles = [];
            let nextPageToken = null;
            
            do {
                // Get files and folders in current directory
                const response = await gapi.client.drive.files.list({
                    q: `'${folderId}' in parents and trashed=false`,
                    fields: 'nextPageToken, files(id, name, parents, mimeType, size, modifiedTime)',
                    pageSize: 200, // Increased to 200
                    pageToken: nextPageToken
                });
                
                const items = response.result.files;
                nextPageToken = response.result.nextPageToken;
                
                for (const item of items) {
                    if (item.mimeType === 'text/plain' && item.name.endsWith('.txt')) {
                        // Add txt file with folder path
                        const folderPath = await getFolderPath(item.parents[0]);
                        allFiles.push({
                            ...item,
                            folderPath: folderPath
                        });
                    } else if (item.mimeType === 'application/vnd.google-apps.folder') {
                        // Recursively scan subfolder
                        updateStatus(`üîç ƒêang qu√©t th∆∞ m·ª•c: ${item.name} (ƒë·ªô s√¢u ${depth + 1})`);
                        const subFiles = await scanFolderRecursive(item.id, depth + 1, maxDepth);
                        allFiles = allFiles.concat(subFiles);
                    }
                }
                
            } while (nextPageToken && allFiles.length < 200); // Stop at 200 files
            
            return allFiles;
        }

        async function getFolderPath(folderId) {
            try {
                const response = await gapi.client.drive.files.get({
                    fileId: folderId,
                    fields: 'name, parents'
                });
                
                const folder = response.result;
                if (!folder.parents || folder.name === 'QuanLyTruyen') {
                    return folder.name;
                }
                
                const parentPath = await getFolderPath(folder.parents[0]);
                return `${parentPath}/${folder.name}`;
            } catch (error) {
                console.error('Error getting folder path:', error);
                return 'Unknown';
            }
        }

        async function buildFolderStructure(folderId, depth = 0) {
            if (depth > 5) return {}; // Prevent infinite recursion
            
            const structure = {};
            
            try {
                const response = await gapi.client.drive.files.list({
                    q: `'${folderId}' in parents and mimeType='application/vnd.google-apps.folder' and trashed=false`,
                    fields: 'files(id, name)',
                    pageSize: 100
                });
                
                for (const folder of response.result.files) {
                    structure[folder.name] = {
                        id: folder.id,
                        subfolders: await buildFolderStructure(folder.id, depth + 1)
                    };
                }
            } catch (error) {
                console.error('Error building folder structure:', error);
            }
            
            return structure;
        }

        function displayScanResults(files) {
            const container = document.getElementById('analysisResults');
            
            // Group files by folder
            const filesByFolder = {};
            files.forEach(file => {
                const folder = file.folderPath || 'Unknown';
                if (!filesByFolder[folder]) {
                    filesByFolder[folder] = [];
                }
                filesByFolder[folder].push(file);
            });
            
            let html = `
                <div class="file-card">
                    <div class="file-header">
                        <span class="file-name">üìä K·∫øt qu·∫£ qu√©t th∆∞ m·ª•c</span>
                        <small>T·ªïng c·ªông: ${files.length} file txt</small>
                    </div>
                    <div class="analysis-content">
                        <h4>üìÅ Ph√¢n b·ªë file theo th∆∞ m·ª•c:</h4>
            `;
            
            Object.entries(filesByFolder).forEach(([folder, folderFiles]) => {
                html += `
                    <div style="margin: 10px 0; padding: 10px; background: #f8f9fa; border-radius: 5px;">
                        <strong>üìÇ ${folder}</strong> (${folderFiles.length} file)
                        <ul style="margin: 5px 0 0 20px;">
                `;
                
                folderFiles.slice(0, 10).forEach(file => {
                    const size = file.size ? Math.round(file.size / 1024) + 'KB' : 'N/A';
                    const date = file.modifiedTime ? new Date(file.modifiedTime).toLocaleDateString('vi-VN') : 'N/A';
                    html += `<li>${file.name} (${size}, ${date})</li>`;
                });
                
                if (folderFiles.length > 10) {
                    html += `<li><em>... v√† ${folderFiles.length - 10} file kh√°c</em></li>`;
                }
                
                html += `</ul></div>`;
            });
            
            html += `
                    </div>
                </div>
            `;
            
            container.innerHTML = html;
        }

        // Cache management functions
        async function checkCacheExists() {
            try {
                const response = await gapi.client.drive.files.list({
                    q: `name='${CACHE_FILE_NAME}' and trashed=false`,
                    fields: 'files(id, name, modifiedTime)'
                });
                
                return response.result.files.length > 0;
            } catch (error) {
                console.error('Error checking cache:', error);
                return false;
            }
        }

        async function loadFromCache() {
            updateProgress(20);
            updateStatus('üìÇ ƒêang t·∫£i cache t·ª´ Google Drive...');
            
            try {
                const response = await gapi.client.drive.files.list({
                    q: `name='${CACHE_FILE_NAME}' and trashed=false`,
                    fields: 'files(id, name, modifiedTime)'
                });
                
                if (response.result.files.length === 0) {
                    throw new Error('Kh√¥ng t√¨m th·∫•y file cache');
                }
                
                const cacheFile = response.result.files[0];
                updateProgress(50);
                
                // Download cache content
                const cacheResponse = await gapi.client.drive.files.get({
                    fileId: cacheFile.id,
                    alt: 'media'
                });
                
                updateProgress(70);
                
                const cacheData = JSON.parse(cacheResponse.body);
                scanCache = cacheData;
                window.txtFiles = cacheData.files;
                
                updateProgress(90);
                updateStatus(`‚úÖ ƒê√£ t·∫£i cache th√†nh c√¥ng: ${cacheData.totalFiles} file (c·∫≠p nh·∫≠t: ${new Date(cacheFile.modifiedTime).toLocaleString('vi-VN')})`);
                
                document.getElementById('analyzeBtn').disabled = false;
                displayScanResults(cacheData.files);
                updateProgress(100);
                
                setTimeout(() => updateProgress(0), 2000);
                
            } catch (error) {
                console.error('Error loading cache:', error);
                updateStatus(`‚ùå L·ªói t·∫£i cache: ${error.message}`);
                // Fallback to normal scan
                await scanFolder();
            }
        }

        async function saveCacheToGoogleDrive() {
            updateProgress(85);
            updateStatus('üíæ ƒêang l∆∞u cache qu√©t...');
            
            try {
                // Check if cache file already exists
                const existingResponse = await gapi.client.drive.files.list({
                    q: `name='${CACHE_FILE_NAME}' and trashed=false`,
                    fields: 'files(id)'
                });
                
                const cacheContent = JSON.stringify(scanCache, null, 2);
                
                if (existingResponse.result.files.length > 0) {
                    // Update existing cache file
                    const fileId = existingResponse.result.files[0].id;
                    await gapi.client.request({
                        path: `https://www.googleapis.com/upload/drive/v3/files/${fileId}`,
                        method: 'PATCH',
                        params: {
                            uploadType: 'media'
                        },
                        headers: {
                            'Content-Type': 'application/json'
                        },
                        body: cacheContent
                    });
                } else {
                    // Create new cache file
                    await gapi.client.request({
                        path: 'https://www.googleapis.com/upload/drive/v3/files',
                        method: 'POST',
                        params: {
                            uploadType: 'multipart'
                        },
                        headers: {
                            'Content-Type': 'multipart/related; boundary="boundary"'
                        },
                        body: createMultipartBody({
                            name: CACHE_FILE_NAME,
                            description: 'Cache file for QuanLyTruyen scanner'
                        }, cacheContent)
                    });
                }
                
                updateProgress(95);
                updateStatus('‚úÖ ƒê√£ l∆∞u cache th√†nh c√¥ng');
                
            } catch (error) {
                console.error('Error saving cache:', error);
                // Don't fail the whole process if cache saving fails
                updateStatus('‚ö†Ô∏è Kh√¥ng th·ªÉ l∆∞u cache, nh∆∞ng qu√©t v·∫´n th√†nh c√¥ng');
            }
        }

        // Analysis functions
        async function analyzeFiles() {
            if (!window.txtFiles || window.txtFiles.length === 0) {
                alert('Vui l√≤ng qu√©t th∆∞ m·ª•c tr∆∞·ªõc khi ph√¢n t√≠ch!');
                return;
            }
            
            updateStatus('üß† ƒêang ph√¢n t√≠ch c√°c file...');
            analysisData = [];
            
            const totalFiles = window.txtFiles.length;
            
            for (let i = 0; i < totalFiles; i++) {
                const file = window.txtFiles[i];
                updateProgress((i / totalFiles) * 100);
                updateStatus(`üß† ƒêang ph√¢n t√≠ch file: ${file.name}`);
                
                try {
                    // Download file content
                    const response = await gapi.client.drive.files.get({
                        fileId: file.id,
                        alt: 'media'
                    });
                    
                    const content = response.body;
                    const analysis = await analyzeStoryContent(content, file.name);
                    analysisData.push(analysis);
                    
                } catch (error) {
                    console.error(`Error analyzing file ${file.name}:`, error);
                    analysisData.push({
                        fileName: file.name,
                        error: error.message
                    });
                }
            }
            
            displayAnalysisResults();
            document.getElementById('generateBtn').disabled = false;
            updateProgress(100);
            updateStatus(`‚úÖ Ho√†n th√†nh ph√¢n t√≠ch ${totalFiles} file`);
            
            setTimeout(() => updateProgress(0), 2000);
        }

        // AI Analysis function
        async function analyzeStoryContent(content, fileName) {
            // Simulate AI analysis delay
            await new Promise(resolve => setTimeout(resolve, 1000));
            
            const analysis = {
                fileName: fileName,
                timestamp: new Date().toLocaleString('vi-VN'),
                
                // Ph√¢n t√≠ch c∆° b·∫£n
                wordCount: content.split(/\s+/).length,
                characterCount: content.length,
                paragraphCount: content.split('\n\n').length,
                
                // Ph√¢n t√≠ch n√¢ng cao
                themes: extractThemes(content),
                characters: extractCharacters(content),
                plotStructure: analyzePlotStructure(content),
                writingStyle: analyzeWritingStyle(content),
                emotions: analyzeEmotions(content),
                setting: analyzeSetting(content),
                dialogues: extractDialogues(content),
                symbolism: analyzeSymbolism(content),
                
                // N·ªôi dung g·ªëc
                originalContent: content.substring(0, 500) + (content.length > 500 ? '...' : '')
            };
            
            return analysis;
        }

        // Analysis helper functions
        function extractThemes(content) {
            const themes = [];
            const themeKeywords = {
                'T√¨nh y√™u': ['y√™u', 'th∆∞∆°ng', 'y√™u th∆∞∆°ng', 't√¨nh c·∫£m', 'l√£ng m·∫°n', 'tim', 'tr√°i tim'],
                'Gia ƒë√¨nh': ['gia ƒë√¨nh', 'b·ªë', 'm·∫π', 'con', 'anh em', 'ch·ªã em', '√¥ng b√†'],
                'T√¨nh b·∫°n': ['b·∫°n', 'b·∫°n b√®', 't√¨nh b·∫°n', 'ƒë·ªìng nghi·ªáp', 'c√πng nhau'],
                'Phi√™u l∆∞u': ['phi√™u l∆∞u', 'kh√°m ph√°', 'h√†nh tr√¨nh', 'du l·ªãch', 'm·∫°o hi·ªÉm'],
                'Chi·∫øn ƒë·∫•u': ['chi·∫øn ƒë·∫•u', 'ƒë√°nh nhau', 'chi·∫øn tranh', 'v√µ thu·∫≠t', 'anh h√πng'],
                'T√¢m linh': ['th·∫ßn', 'ph·∫≠t', 't√¢m linh', 't√¥n gi√°o', 'c·∫ßu nguy·ªán', 'thi·ªÅn']
            };
            
            for (const [theme, keywords] of Object.entries(themeKeywords)) {
                const count = keywords.reduce((acc, keyword) => {
                    return acc + (content.toLowerCase().match(new RegExp(keyword, 'g')) || []).length;
                }, 0);
                if (count > 0) {
                    themes.push({ theme, relevance: count });
                }
            }
            
            return themes.sort((a, b) => b.relevance - a.relevance).slice(0, 5);
        }

        function extractCharacters(content) {
            const characters = [];
            // T√¨m t√™n ng∆∞·ªùi (t·ª´ vi·∫øt hoa ƒë·∫ßu c√¢u)
            const namePattern = /\b[A-Z√Ä-·ª∏][a-z√†-·ªπ]+(?:\s[A-Z√Ä-·ª∏][a-z√†-·ªπ]+)*\b/g;
            const matches = content.match(namePattern) || [];
            
            const characterCounts = {};
            matches.forEach(match => {
                if (match.length > 2 && match.length < 30) {
                    characterCounts[match] = (characterCounts[match] || 0) + 1;
                }
            });
            
            return Object.entries(characterCounts)
                .sort(([,a], [,b]) => b - a)
                .slice(0, 10)
                .map(([name, count]) => ({ name, appearances: count }));
        }

        function analyzePlotStructure(content) {
            const sentences = content.split(/[.!?]+/).filter(s => s.trim());
            const totalSentences = sentences.length;
            
            return {
                structure: 'Ba h·ªìi',
                exposition: Math.round(totalSentences * 0.25),
                rising_action: Math.round(totalSentences * 0.5),
                climax: Math.round(totalSentences * 0.15),
                resolution: Math.round(totalSentences * 0.1),
                pacing: totalSentences > 50 ? 'Ch·∫≠m' : totalSentences > 20 ? 'V·ª´a ph·∫£i' : 'Nhanh'
            };
        }

        function analyzeWritingStyle(content) {
            const sentences = content.split(/[.!?]+/).filter(s => s.trim());
            const avgSentenceLength = content.length / sentences.length;
            
            return {
                tone: avgSentenceLength > 100 ? 'Trang tr·ªçng' : 'Th√¢n m·∫≠t',
                complexity: avgSentenceLength > 80 ? 'Ph·ª©c t·∫°p' : 'ƒê∆°n gi·∫£n',
                narrative_perspective: content.includes('t√¥i') ? 'Ng√¥i th·ª© nh·∫•t' : 'Ng√¥i th·ª© ba',
                average_sentence_length: Math.round(avgSentenceLength)
            };
        }

        function analyzeEmotions(content) {
            const emotions = {
                'Vui v·∫ª': ['vui', 'h·∫°nh ph√∫c', 'c∆∞·ªùi', 'vui m·ª´ng', 'h√¢n hoan', 'ph·∫•n kh√≠ch'],
                'Bu·ªìn b√£': ['bu·ªìn', 'kh√≥c', 'ƒëau kh·ªï', 'th∆∞∆°ng ti·∫øc', 'tang t√≥c'],
                'T·ª©c gi·∫≠n': ['gi·∫≠n', 't·ª©c', 'ph·∫´n n·ªô', 'b·ª±c b·ªôi', 'c√°u k·ªânh'],
                'S·ª£ h√£i': ['s·ª£', 'h√£i', 'kinh ho√†ng', 'lo l·∫Øng', 'b·∫•t an'],
                'Y√™u th∆∞∆°ng': ['y√™u', 'th∆∞∆°ng', '√¢u y·∫øm', 'tr√¨u m·∫øn', 'c∆∞ng chi·ªÅu']
            };
            
            const results = [];
            for (const [emotion, keywords] of Object.entries(emotions)) {
                const count = keywords.reduce((acc, keyword) => {
                    return acc + (content.toLowerCase().match(new RegExp(keyword, 'g')) || []).length;
                }, 0);
                if (count > 0) {
                    results.push({ emotion, intensity: count });
                }
            }
            
            return results.sort((a, b) => b.intensity - a.intensity);
        }

        function analyzeSetting(content) {
            const locations = [];
            const timeKeywords = ['s√°ng', 'chi·ªÅu', 't·ªëi', 'ƒë√™m', 'h√¥m nay', 'h√¥m qua', 'ng√†y mai'];
            const placeKeywords = ['nh√†', 'tr∆∞·ªùng', 'c√¥ng vi√™n', 'th√†nh ph·ªë', 'l√†ng', 'r·ª´ng', 'bi·ªÉn'];
            
            const timeFound = timeKeywords.filter(t => content.toLowerCase().includes(t));
            const placeFound = placeKeywords.filter(p => content.toLowerCase().includes(p));
            
            return {
                time_period: timeFound.length > 0 ? timeFound : ['Kh√¥ng x√°c ƒë·ªãnh'],
                locations: placeFound.length > 0 ? placeFound : ['Kh√¥ng x√°c ƒë·ªãnh'],
                atmosphere: content.includes('t·ªëi') || content.includes('ƒë√™m') ? 'U √°m' : 'T∆∞∆°i s√°ng'
            };
        }

        function extractDialogues(content) {
            const dialoguePattern = /"[^"]*"/g;
            const dialogues = content.match(dialoguePattern) || [];
            
            return {
                count: dialogues.length,
                samples: dialogues.slice(0, 5),
                dialogue_ratio: (dialogues.join('').length / content.length * 100).toFixed(2) + '%'
            };
        }

        function analyzeSymbolism(content) {
            const symbols = {
                'Hoa': 'V·∫ª ƒë·∫πp, s·ª± t∆∞∆°i m·ªõi',
                'M·∫∑t tr·ªùi': 'Hy v·ªçng, s·ª©c m·∫°nh',
                'M·∫∑t trƒÉng': 'T√¨nh y√™u, b√≠ ·∫©n',
                'N∆∞·ªõc': 'S·ª± thanh khi·∫øt, d√≤ng ch·∫£y c·ªßa th·ªùi gian',
                'N√∫i': 'S·ª± v·ªØng ch√£i, th√°ch th·ª©c',
                'C√¢y': 'S·ª± ph√°t tri·ªÉn, s·ª©c s·ªëng'
            };
            
            const foundSymbols = [];
            for (const [symbol, meaning] of Object.entries(symbols)) {
                if (content.toLowerCase().includes(symbol.toLowerCase())) {
                    foundSymbols.push({ symbol, meaning });
                }
            }
            
            return foundSymbols;
        }

        // Display functions
        function displayAnalysisResults() {
            const container = document.getElementById('analysisResults');
            container.innerHTML = '';
            
            analysisData.forEach((analysis, index) => {
                if (analysis.error) {
                    container.innerHTML += `
                        <div class="file-card">
                            <div class="file-header">
                                <span class="file-name">‚ùå ${analysis.fileName}</span>
                            </div>
                            <div class="error">L·ªói: ${analysis.error}</div>
                        </div>
                    `;
                    return;
                }
                
                const card = document.createElement('div');
                card.className = 'file-card';
                card.innerHTML = `
                    <div class="file-header">
                        <span class="file-name">üìÑ ${analysis.fileName}</span>
                        <small>Ph√¢n t√≠ch l√∫c: ${analysis.timestamp}</small>
                    </div>
                    <div class="analysis-content">
                        <h4>üìä Th·ªëng k√™ c∆° b·∫£n:</h4>
                        <p>‚Ä¢ S·ªë t·ª´: ${analysis.wordCount} | S·ªë k√Ω t·ª±: ${analysis.characterCount} | S·ªë ƒëo·∫°n vƒÉn: ${analysis.paragraphCount}</p>
                        
                        <h4>üé≠ Ch·ªß ƒë·ªÅ ch√≠nh:</h4>
                        <p>${analysis.themes.map(t => `${t.theme} (${t.relevance})`).join(', ') || 'Kh√¥ng x√°c ƒë·ªãnh'}</p>
                        
                        <h4>üë• Nh√¢n v·∫≠t:</h4>
                        <p>${analysis.characters.map(c => `${c.name} (${c.appearances} l·∫ßn)`).join(', ') || 'Kh√¥ng x√°c ƒë·ªãnh'}</p>
                        
                        <h4>üìñ C·∫•u tr√∫c c·ªët truy·ªán:</h4>
                        <p>‚Ä¢ Ki·ªÉu: ${analysis.plotStructure.structure}</p>
                        <p>‚Ä¢ Nh·ªãp ƒë·ªô: ${analysis.plotStructure.pacing}</p>
                        
                        <h4>‚úçÔ∏è Phong c√°ch vi·∫øt:</h4>
                        <p>‚Ä¢ Gi·ªçng ƒëiÏ°∞: ${analysis.writingStyle.tone}</p>
                        <p>‚Ä¢ ƒê·ªô ph·ª©c t·∫°p: ${analysis.writingStyle.complexity}</p>
                        <p>‚Ä¢ G√≥c nh√¨n: ${analysis.writingStyle.narrative_perspective}</p>
                        
                        <h4>üòä C·∫£m x√∫c:</h4>
                        <p>${analysis.emotions.map(e => `${e.emotion} (${e.intensity})`).join(', ') || 'Kh√¥ng x√°c ƒë·ªãnh'}</p>
                        
                        <h4>üåç B·ªëi c·∫£nh:</h4>
                        <p>‚Ä¢ Th·ªùi gian: ${analysis.setting.time_period.join(', ')}</p>
                        <p>‚Ä¢ ƒê·ªãa ƒëi·ªÉm: ${analysis.setting.locations.join(', ')}</p>
                        <p>‚Ä¢ Kh√¥ng kh√≠: ${analysis.setting.atmosphere}</p>
                        
                        <h4>üí¨ ƒê·ªëi tho·∫°i:</h4>
                        <p>‚Ä¢ S·ªë l∆∞·ª£ng: ${analysis.dialogues.count} | T·ª∑ l·ªá: ${analysis.dialogues.dialogue_ratio}</p>
                        
                        <h4>üîÆ Bi·ªÉu t∆∞·ª£ng:</h4>
                        <p>${analysis.symbolism.map(s => `${s.symbol} (${s.meaning})`).join(', ') || 'Kh√¥ng c√≥'}</p>
                        
                        <h4>üìù ƒêo·∫°n tr√≠ch g·ªëc:</h4>
                        <div style="background: #e9ecef; padding: 10px; border-radius: 5px; font-style: italic;">
                            "${analysis.originalContent}"
                        </div>
                    </div>
                `;
                container.appendChild(card);
            });
        }

        // Story generation functions
        async function generateStories() {
            if (analysisData.length === 0) {
                alert('Vui l√≤ng ph√¢n t√≠ch file tr∆∞·ªõc khi t·∫°o truy·ªán!');
                return;
            }
            
            updateStatus('‚úçÔ∏è ƒêang t·∫°o truy·ªán t·ª´ ph√¢n t√≠ch...');
            generatedStories = [];
            
            for (let i = 0; i < analysisData.length; i++) {
                const analysis = analysisData[i];
                if (analysis.error) continue;
                
                updateProgress((i / analysisData.length) * 100);
                updateStatus(`‚úçÔ∏è ƒêang t·∫°o truy·ªán t·ª´: ${analysis.fileName}`);
                
                try {
                    const story = await generateStoryFromAnalysis(analysis);
                    generatedStories.push(story);
                } catch (error) {
                    console.error(`Error generating story from ${analysis.fileName}:`, error);
                    generatedStories.push({
                        fileName: analysis.fileName,
                        error: error.message
                    });
                }
            }
            
            displayGeneratedStories();
            document.getElementById('saveBtn').disabled = false;
            updateProgress(100);
            updateStatus(`‚úÖ ƒê√£ t·∫°o ${generatedStories.length} truy·ªán m·ªõi`);
            
            setTimeout(() => updateProgress(0), 2000);
        }

        // AI Story Generation function
        async function generateStoryFromAnalysis(analysis) {
            // Simulate AI processing time
            await new Promise(resolve => setTimeout(resolve, 2000));
            
            const story = {
                fileName: analysis.fileName,
                originalTitle: analysis.fileName.replace('.txt', ''),
                generatedTitle: generateTitle(analysis),
                timestamp: new Date().toLocaleString('vi-VN'),
                
                // T·∫°o n·ªôi dung truy·ªán d·ª±a tr√™n ph√¢n t√≠ch
                content: await createStoryContent(analysis),
                
                // Th√¥ng tin meta
                genre: determineGenre(analysis),
                targetAudience: determineAudience(analysis),
                estimatedReadingTime: 0, // S·∫Ω t√≠nh sau
                
                // Ph√¢n t√≠ch c·ªßa truy·ªán m·ªõi
                newAnalysis: {
                    themes: analysis.themes,
                    mainCharacters: analysis.characters.slice(0, 3),
                    plotSummary: generatePlotSummary(analysis),
                    moralLesson: generateMoralLesson(analysis)
                }
            };
            
            // T√≠nh th·ªùi gian ƒë·ªçc (250 t·ª´/ph√∫t)
            story.estimatedReadingTime = Math.ceil(story.content.split(' ').length / 250);
            
            return story;
        }

        // Story creation helper functions
        function generateTitle(analysis) {
            const themes = analysis.themes.map(t => t.theme);
            const characters = analysis.characters.slice(0, 2).map(c => c.name);
            
            const titleTemplates = [
                `C√¢u Chuy·ªán C·ªßa ${characters[0] || 'M·ªôt Ng∆∞·ªùi'}`,
                `${themes[0] || 'H√†nh Tr√¨nh'} V√† Nh·ªØng ƒêi·ªÅu K·ª≥ Di·ªáu`,
                `Khi ${characters[0] || 'Con Tim'} G·∫∑p ${themes[0] || 'S·ªë Ph·∫≠n'}`,
                `${characters[0] || 'Ng∆∞·ªùi'} V√† ${themes[0] || 'Cu·ªôc ƒê·ªùi'}`,
                `Nh·ªØng Ng√†y Th√°ng C·ªßa ${characters[0] || 'Tu·ªïi Tr·∫ª'}`
            ];
            
            return titleTemplates[Math.floor(Math.random() * titleTemplates.length)];
        }

        async function createStoryContent(analysis) {
            // T·∫°o n·ªôi dung truy·ªán t·ª´ ph√¢n t√≠ch
            const characters = analysis.characters.slice(0, 3);
            const mainTheme = analysis.themes[0] || { theme: 'Cu·ªôc s·ªëng', relevance: 1 };
            const setting = analysis.setting;
            const emotions = analysis.emotions;
            
            let story = '';
            
            // M·ªü ƒë·∫ßu
            story += generateOpening(characters, setting, mainTheme);
            story += '\n\n';
            
            // Ph√°t tri·ªÉn
            story += generateDevelopment(characters, mainTheme, emotions, analysis);
            story += '\n\n';
            
            // Cao tr√†o
            story += generateClimax(characters, mainTheme, emotions);
            story += '\n\n';
            
            // K·∫øt th√∫c
            story += generateResolution(characters, mainTheme, analysis);
            
            return story;
        }

        function generateOpening(characters, setting, theme) {
            const mainChar = characters[0]?.name || 'Lan';
            const location = setting.locations[0] || 'l√†ng qu√™';
            const timeOfDay = setting.time_period[0] || 'bu·ªïi s√°ng';
            
            const openings = [
                `V√†o m·ªôt ${timeOfDay} ƒë·∫πp tr·ªùi t·∫°i ${location}, ${mainChar} th·ª©c d·∫≠y v·ªõi t√¢m tr·∫°ng ƒë·∫∑c bi·ªát. Kh√¥ng kh√≠ trong l√†nh v√† nh·ªØng tia n·∫Øng ƒë·∫ßu ng√†y khi·∫øn ${mainChar} c·∫£m th·∫•y nh∆∞ c√≥ ƒëi·ªÅu g√¨ ƒë√≥ tuy·ªát v·ªùi s·∫Øp x·∫£y ra.`,
                
                `${mainChar} ƒë√£ s·ªëng ·ªü ${location} su·ªët ${Math.floor(Math.random() * 10) + 15} nƒÉm qua, nh∆∞ng ${timeOfDay} h√¥m nay c√≥ g√¨ ƒë√≥ kh√°c l·∫°. C√≥ l·∫Ω l√† v√¨ ${theme.theme.toLowerCase()} ƒëang d·∫ßn thay ƒë·ªïi cu·ªôc s·ªëng c·ªßa ${mainChar}.`,
                
                `C√¢u chuy·ªán b·∫Øt ƒë·∫ßu t·ª´ ${timeOfDay} ·ªü ${location}, n∆°i ${mainChar} ƒëang s·ªëng m·ªôt cu·ªôc s·ªëng b√¨nh th∆∞·ªùng cho ƒë·∫øn khi ${theme.theme.toLowerCase()} xu·∫•t hi·ªán trong cu·ªôc ƒë·ªùi.`
            ];
            
            return openings[Math.floor(Math.random() * openings.length)];
        }

        function generateDevelopment(characters, theme, emotions, analysis) {
            const mainChar = characters[0]?.name || 'Lan';
            const secondChar = characters[1]?.name || 'Minh';
            const mainEmotion = emotions[0]?.emotion || 'h·∫°nh ph√∫c';
            
            let development = '';
            
            // G·∫∑p g·ªü th·ª≠ th√°ch
            development += `Ng√†y qua ng√†y, ${mainChar} nh·∫≠n ra r·∫±ng ${theme.theme.toLowerCase()} kh√¥ng ƒë∆°n gi·∫£n nh∆∞ ${mainChar} t∆∞·ªüng. `;
            
            if (secondChar && secondChar !== mainChar) {
                development += `Khi g·∫∑p ${secondChar}, ${mainChar} hi·ªÉu ƒë∆∞·ª£c √Ω nghƒ©a th·∫≠t s·ª± c·ªßa ${theme.theme.toLowerCase()}. `;
            }
            
            development += `Nh·ªØng c·∫£m x√∫c ${mainEmotion.toLowerCase()} kh√¥ng ng·ª´ng d√¢ng tr√†o trong l√≤ng ${mainChar}. `;
            
            // Th√™m chi ti·∫øt t·ª´ ph√¢n t√≠ch
            if (analysis.symbolism.length > 0) {
                const symbol = analysis.symbolism[0];
                development += `${symbol.symbol} trong v∆∞·ªùn nh√† nh∆∞ m·ªôt bi·ªÉu t∆∞·ª£ng c·ªßa ${symbol.meaning.toLowerCase()}, nh·∫Øc nh·ªü ${mainChar} v·ªÅ h√†nh tr√¨nh m√† ${mainChar} ƒëang tr·∫£i qua. `;
            }
            
            development += `M·ªói ng√†y tr√¥i qua, ${mainChar} h·ªçc ƒë∆∞·ª£c nh·ªØng b√†i h·ªçc qu√Ω gi√° v·ªÅ cu·ªôc s·ªëng v√† v·ªÅ ch√≠nh b·∫£n th√¢n m√¨nh.`;
            
            return development;
        }

        function generateClimax(characters, theme, emotions) {
            const mainChar = characters[0]?.name || 'Lan';
            const strongEmotion = emotions[0]?.emotion || 'c·∫£m ƒë·ªông';
            
            const climaxScenarios = [
                `ƒê·∫øn m·ªôt l√∫c n√†o ƒë√≥, ${mainChar} ph·∫£i ƒë·ªëi m·∫∑t v·ªõi th·ª≠ th√°ch l·ªõn nh·∫•t. L√∫c n√†y, t·∫•t c·∫£ nh·ªØng g√¨ ${mainChar} ƒë√£ h·ªçc ƒë∆∞·ª£c v·ªÅ ${theme.theme.toLowerCase()} s·∫Ω ƒë∆∞·ª£c th·ªÉ hi·ªán. C·∫£m gi√°c ${strongEmotion.toLowerCase()} tr√†n ng·∫≠p trong tim ${mainChar}.`,
                
                `Kho·∫£nh kh·∫Øc quy·∫øt ƒë·ªãnh ƒë·∫øn khi ${mainChar} nh·∫≠n ra r·∫±ng ${theme.theme.toLowerCase()} ch√≠nh l√† ƒëi·ªÅu ${mainChar} c·∫ßn ƒë·ªÉ v∆∞·ª£t qua kh√≥ khƒÉn. V·ªõi t√¢m tr·∫°ng ${strongEmotion.toLowerCase()}, ${mainChar} quy·∫øt ƒë·ªãnh h√†nh ƒë·ªông.`,
                
                `Trong gi√¢y ph√∫t quan tr·ªçng nh·∫•t, ${mainChar} hi·ªÉu r·∫±ng ${theme.theme.toLowerCase()} ƒë√£ thay ƒë·ªïi ${mainChar} ho√†n to√†n. C·∫£m x√∫c ${strongEmotion.toLowerCase()} khi·∫øn ${mainChar} c√≥ ƒë·ªß d≈©ng kh√≠ ƒë·ªÉ l√†m ƒëi·ªÅu ƒë√∫ng ƒë·∫Øn.`
            ];
            
            return climaxScenarios[Math.floor(Math.random() * climaxScenarios.length)];
        }

        function generateResolution(characters, theme, analysis) {
            const mainChar = characters[0]?.name || 'Lan';
            const writingStyle = analysis.writingStyle.tone;
            
            let resolution = '';
            
            if (writingStyle === 'Trang tr·ªçng') {
                resolution = `Cu·ªëi c√πng, ${mainChar} ƒë√£ t√¨m ƒë∆∞·ª£c c√¢u tr·∫£ l·ªùi cho t·∫•t c·∫£ nh·ªØng th·∫Øc m·∫Øc trong l√≤ng. ${theme.theme} kh√¥ng ch·ªâ l√† m·ªôt kh√°i ni·ªám m√† l√† m·ªôt ph·∫ßn kh√¥ng th·ªÉ thi·∫øu trong cu·ªôc s·ªëng. `;
            } else {
                resolution = `V√† r·ªìi, m·ªçi chuy·ªán ƒë∆∞·ª£c gi·∫£i quy·∫øt m·ªôt c√°ch tuy·ªát v·ªùi! ${mainChar} hi·ªÉu ra r·∫±ng ${theme.theme.toLowerCase()} ch√≠nh l√† ch√¨a kh√≥a h·∫°nh ph√∫c. `;
            }
            
            resolution += `T·ª´ ƒë√≥ v·ªÅ sau, cu·ªôc s·ªëng c·ªßa ${mainChar} tr·ªü n√™n √Ω nghƒ©a h∆°n r·∫•t nhi·ªÅu. M·ªói khi nh√¨n l·∫°i h√†nh tr√¨nh v·ª´a qua, ${mainChar} l·∫°i c·∫£m th·∫•y bi·∫øt ∆°n v√¨ ƒë√£ c√≥ c∆° h·ªôi tr·∫£i nghi·ªám nh·ªØng ƒëi·ªÅu tuy·ªát v·ªùi n√†y.`;
            
            // Th√™m k·∫øt th√∫c ƒë·∫πp
            resolution += `\n\nC√¢u chuy·ªán c·ªßa ${mainChar} l√† minh ch·ª©ng cho th·∫•y r·∫±ng trong cu·ªôc s·ªëng, ${theme.theme.toLowerCase()} lu√¥n t·ªìn t·∫°i xung quanh ch√∫ng ta, ch·ªâ c·∫ßn ch√∫ng ta bi·∫øt c√°ch nh·∫≠n ra v√† tr√¢n tr·ªçng.`;
            
            return resolution;
        }

        function determineGenre(analysis) {
            const themes = analysis.themes.map(t => t.theme);
            
            if (themes.includes('T√¨nh y√™u')) return 'L√£ng m·∫°n';
            if (themes.includes('Phi√™u l∆∞u')) return 'Phi√™u l∆∞u';
            if (themes.includes('Gia ƒë√¨nh')) return 'Gia ƒë√¨nh';
            if (themes.includes('T√¢m linh')) return 'Tri·∫øt l√Ω';
            if (themes.includes('Chi·∫øn ƒë·∫•u')) return 'H√†nh ƒë·ªông';
            
            return 'ƒê·ªùi s·ªëng';
        }

        function determineAudience(analysis) {
            const complexity = analysis.writingStyle.complexity;
            const themes = analysis.themes.map(t => t.theme);
            
            if (complexity === 'ƒê∆°n gi·∫£n' && themes.includes('Gia ƒë√¨nh')) return 'Tr·∫ª em v√† gia ƒë√¨nh';
            if (themes.includes('T√¨nh y√™u')) return 'Thanh ni√™n v√† ng∆∞·ªùi l·ªõn';
            if (complexity === 'Ph·ª©c t·∫°p') return 'Ng∆∞·ªùi l·ªõn';
            
            return 'M·ªçi l·ª©a tu·ªïi';
        }

        function generatePlotSummary(analysis) {
            const mainChar = analysis.characters[0]?.name || 'nh√¢n v·∫≠t ch√≠nh';
            const theme = analysis.themes[0]?.theme || 'cu·ªôc s·ªëng';
            
            return `C√¢u chuy·ªán k·ªÉ v·ªÅ h√†nh tr√¨nh c·ªßa ${mainChar} trong vi·ªác kh√°m ph√° v√† hi·ªÉu s√¢u v·ªÅ ${theme.toLowerCase()}. Qua nh·ªØng tr·∫£i nghi·ªám v√† th·ª≠ th√°ch, ${mainChar} ƒë√£ h·ªçc ƒë∆∞·ª£c nh·ªØng b√†i h·ªçc qu√Ω gi√° v√† tr∆∞·ªüng th√†nh h∆°n.`;
        }

        function generateMoralLesson(analysis) {
            const theme = analysis.themes[0]?.theme || 'cu·ªôc s·ªëng';
            
            const lessons = {
                'T√¨nh y√™u': 'T√¨nh y√™u ch√¢n th·∫≠t c·∫ßn ƒë∆∞·ª£c nu√¥i d∆∞·ª°ng b·∫±ng s·ª± hi·ªÉu bi·∫øt v√† chia s·∫ª.',
                'Gia ƒë√¨nh': 'Gia ƒë√¨nh l√† n∆°i ta lu√¥n c√≥ th·ªÉ tr·ªü v·ªÅ v√† t√¨m th·∫•y s·ª± ·∫•m √°p.',
                'T√¨nh b·∫°n': 'T√¨nh b·∫°n ƒë√≠ch th·ª±c l√† b√°u v·∫≠t qu√Ω gi√° nh·∫•t trong ƒë·ªùi.',
                'Phi√™u l∆∞u': 'D≈©ng c·∫£m kh√°m ph√° s·∫Ω mang ƒë·∫øn nh·ªØng tr·∫£i nghi·ªám tuy·ªát v·ªùi.',
                'Chi·∫øn ƒë·∫•u': 'S·ª©c m·∫°nh th·∫≠t s·ª± ƒë·∫øn t·ª´ l√≤ng d≈©ng c·∫£m v√† √Ω ch√≠ ki√™n c∆∞·ªùng.',
                'T√¢m linh': 'T√¨m hi·ªÉu b·∫£n th√¢n v√† √Ω nghƒ©a cu·ªôc s·ªëng l√† h√†nh tr√¨nh c·∫£ ƒë·ªùi.'
            };
            
            return lessons[theme] || 'M·ªói ng√†y ƒë·ªÅu mang ƒë·∫øn nh·ªØng b√†i h·ªçc qu√Ω gi√° cho cu·ªôc s·ªëng.';
        }

        // Display generated stories
        function displayGeneratedStories() {
            const container = document.getElementById('analysisResults');
            
            generatedStories.forEach((story, index) => {
                if (story.error) {
                    container.innerHTML += `
                        <div class="file-card">
                            <div class="file-header">
                                <span class="file-name">‚ùå L·ªói t·∫°o truy·ªán: ${story.fileName}</span>
                            </div>
                            <div class="error">L·ªói: ${story.error}</div>
                        </div>
                    `;
                    return;
                }
                
                const card = document.createElement('div');
                card.className = 'file-card';
                card.innerHTML = `
                    <div class="file-header">
                        <span class="file-name">‚úçÔ∏è ${story.generatedTitle}</span>
                        <small>T·ª´: ${story.originalTitle} | T·∫°o l√∫c: ${story.timestamp}</small>
                    </div>
                    <div class="analysis-content">
                        <h4>üìö Th√¥ng tin truy·ªán:</h4>
                        <p>‚Ä¢ Th·ªÉ lo·∫°i: ${story.genre} | ƒê·ªëi t∆∞·ª£ng: ${story.targetAudience} | Th·ªùi gian ƒë·ªçc: ~${story.estimatedReadingTime} ph√∫t</p>
                        
                        <h4>üìñ T√≥m t·∫Øt c·ªët truy·ªán:</h4>
                        <p>${story.newAnalysis.plotSummary}</p>
                        
                        <h4>üí° B√†i h·ªçc:</h4>
                        <p>${story.newAnalysis.moralLesson}</p>
                        
                        <h4>üë• Nh√¢n v·∫≠t ch√≠nh:</h4>
                        <p>${story.newAnalysis.mainCharacters.map(c => c.name).join(', ') || 'C√°c nh√¢n v·∫≠t ƒë∆∞·ª£c t·∫°o m·ªõi'}</p>
                        
                        <h4>üìù N·ªôi dung truy·ªán:</h4>
                        <div class="story-output">${story.content}</div>
                    </div>
                `;
                container.appendChild(card);
            });
        }

        // Save to Google Drive
        async function saveToGoogleDrive() {
            if (generatedStories.length === 0) {
                alert('Kh√¥ng c√≥ truy·ªán n√†o ƒë·ªÉ l∆∞u!');
                return;
            }
            
            updateStatus('üíæ ƒêang l∆∞u k·∫øt qu·∫£ l√™n Google Drive...');
            
            try {
                // T·∫°o th∆∞ m·ª•c k·∫øt qu·∫£ n·∫øu ch∆∞a c√≥
                const timestamp = new Date().toISOString().split('T')[0];
                const folderName = `KetQuaPhanTich_${timestamp}`;
                
                const folderResponse = await gapi.client.drive.files.create({
                    resource: {
                        name: folderName,
                        mimeType: 'application/vnd.google-apps.folder'
                    }
                });
                
                const folderId = folderResponse.result.id;
                updateProgress(20);
                
                // L∆∞u file ph√¢n t√≠ch t·ªïng h·ª£p
                const analysisReport = generateAnalysisReport();
                await gapi.client.request({
                    path: 'https://www.googleapis.com/upload/drive/v3/files',
                    method: 'POST',
                    params: {
                        uploadType: 'multipart'
                    },
                    headers: {
                        'Content-Type': 'multipart/related; boundary="boundary"'
                    },
                    body: createMultipartBody({
                        name: `BaoCaoPhanTich_${timestamp}.txt`,
                        parents: [folderId]
                    }, analysisReport)
                });
                
                updateProgress(40);
                
                // L∆∞u t·ª´ng truy·ªán ƒë∆∞·ª£c t·∫°o
                for (let i = 0; i < generatedStories.length; i++) {
                    const story = generatedStories[i];
                    if (story.error) continue;
                    
                    updateProgress(40 + (i / generatedStories.length) * 50);
                    
                    const storyContent = formatStoryForSave(story);
                    await gapi.client.request({
                        path: 'https://www.googleapis.com/upload/drive/v3/files',
                        method: 'POST',
                        params: {
                            uploadType: 'multipart'
                        },
                        headers: {
                            'Content-Type': 'multipart/related; boundary="boundary"'
                        },
                        body: createMultipartBody({
                            name: `${story.generatedTitle}.txt`,
                            parents: [folderId]
                        }, storyContent)
                    });
                }
                
                updateProgress(100);
                updateStatus(`‚úÖ ƒê√£ l∆∞u th√†nh c√¥ng ${generatedStories.length} truy·ªán v√†o th∆∞ m·ª•c ${folderName}`);
                
                setTimeout(() => updateProgress(0), 3000);
                
            } catch (error) {
                console.error('Error saving to Google Drive:', error);
                updateStatus(`‚ùå L·ªói khi l∆∞u: ${error.message}`);
                updateProgress(0);
            }
        }

        // Helper functions for saving
        function generateAnalysisReport() {
            let report = `B√ÅO C√ÅO PH√ÇN T√çCH TRUY·ªÜN\n`;
            report += `Th·ªùi gian t·∫°o: ${new Date().toLocaleString('vi-VN')}\n`;
            report += `S·ªë file ƒë√£ ph√¢n t√≠ch: ${analysisData.length}\n`;
            report += `S·ªë truy·ªán ƒë√£ t·∫°o: ${generatedStories.filter(s => !s.error).length}\n`;
            report += `\n${'='.repeat(50)}\n\n`;
            
            analysisData.forEach((analysis, index) => {
                if (analysis.error) {
                    report += `${index + 1}. ${analysis.fileName} - L·ªñI: ${analysis.error}\n\n`;
                    return;
                }
                
                report += `${index + 1}. PH√ÇN T√çCH: ${analysis.fileName}\n`;
                report += `Th·ªùi gian: ${analysis.timestamp}\n`;
                report += `Th·ªëng k√™: ${analysis.wordCount} t·ª´, ${analysis.characterCount} k√Ω t·ª±\n`;
                report += `Ch·ªß ƒë·ªÅ: ${analysis.themes.map(t => t.theme).join(', ')}\n`;
                report += `Nh√¢n v·∫≠t: ${analysis.characters.map(c => c.name).join(', ')}\n`;
                report += `C·∫£m x√∫c: ${analysis.emotions.map(e => e.emotion).join(', ')}\n`;
                report += `\n${'-'.repeat(30)}\n\n`;
            });
            
            return report;
        }

        function formatStoryForSave(story) {
            let content = `${story.generatedTitle.toUpperCase()}\n`;
            content += `${'='.repeat(story.generatedTitle.length)}\n\n`;
            content += `T√°c gi·∫£: AI Story Generator\n`;
            content += `Ngu·ªìn g·ªëc: ${story.originalTitle}\n`;
            content += `Th·ªÉ lo·∫°i: ${story.genre}\n`;
            content += `ƒê·ªëi t∆∞·ª£ng ƒë·ªôc gi·∫£: ${story.targetAudience}\n`;
            content += `Th·ªùi gian ƒë·ªçc ∆∞·ªõc t√≠nh: ${story.estimatedReadingTime} ph√∫t\n`;
            content += `Ng√†y t·∫°o: ${story.timestamp}\n\n`;
            content += `T√ìM T·∫ÆT:\n${story.newAnalysis.plotSummary}\n\n`;
            content += `B√ÄI H·ªåC:\n${story.newAnalysis.moralLesson}\n\n`;
            content += `${'='.repeat(50)}\n\n`;
            content += `N·ªòI DUNG TRUY·ªÜN:\n\n`;
            content += story.content;
            
            return content;
        }

        function createMultipartBody(metadata, data) {
            const delimiter = 'boundary';
            let body = '';
            
            body += `--${delimiter}\r\n`;
            body += 'Content-Type: application/json\r\n\r\n';
            body += JSON.stringify(metadata) + '\r\n';
            body += `--${delimiter}\r\n`;
            body += 'Content-Type: text/plain\r\n\r\n';
            body += data + '\r\n';
            body += `--${delimiter}--`;
            
            return body;
        }

        // Utility functions
        function updateStatus(message) {
            document.getElementById('statusInfo').innerHTML = `<p>${message}</p>`;
        }

        function updateProgress(percent) {
            document.getElementById('progressBar').style.width = percent + '%';
        }

        // Initialize when page loads
        window.onload = function() {
            // Load Google APIs
            if (typeof gapi !== 'undefined') {
                gapiLoaded();
            }
            if (typeof google !== 'undefined') {
                gisLoaded();
            }
            
            // Show initial status
            updateStatus('üî¥ Ch∆∞a k·∫øt n·ªëi Google Drive');
        };
    </script>
</body>
</html>
