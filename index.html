<!DOCTYPE html>
<html lang="vi">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, viewport-fit=cover">
    <title>Tr√¨nh Ph√¢n T√≠ch & T·∫°o Truy·ªán N√¢ng Cao</title>
    <script src="https://apis.google.com/js/api.js"></script>
    <script src="https://accounts.google.com/gsi/client"></script>
    <style>
        :root {
           --primary-color: #9b59b6;
           --secondary-color: #2980b9;
           --dark-color: #1e1e1e;
           --light-color: #bdc3c7;
           --accent-color: #e74c3c;
           --success-color: #2ecc71;
           --warning-color: #f39c12;
           --text-color: #ecf0f1;
           --card-bg: rgba(30, 30, 30, 0.95);
           --border-radius: 16px;
           --shadow: 0 4px 20px rgba(0, 0, 0, 0.6);
           --safe-area-inset-top: env(safe-area-inset-top);
           --safe-area-inset-bottom: env(safe-area-inset-bottom);
           --safe-area-inset-left: env(safe-area-inset-left);
           --safe-area-inset-right: env(safe-area-inset-right);
        }
        * {margin:0;padding:0;box-sizing:border-box;}
        body {background:#121212;color:var(--text-color);font-family:sans-serif;min-height:100vh;}
        .container {padding:16px;padding-bottom:80px;}
        .header {text-align:center;color:#fff;margin-bottom:20px;}
        .card {background:var(--card-bg);border-radius:var(--border-radius);padding:20px;margin-bottom:20px;}
        .bottom-menu {position:fixed;bottom:0;left:0;right:0;display:flex;justify-content:space-around;padding:12px;background:#2c3e50;}
        .menu-item {color:var(--light-color);text-decoration:none;font-size:0.8rem;opacity:0.7;}
        .menu-item.active {opacity:1;}
        .tab-content{display:none;}
        .tab-content.active{display:block;}
        .btn{background:var(--primary-color);color:#fff;border:none;padding:10px 16px;border-radius:8px;margin:4px;cursor:pointer;}
        .btn:disabled{background:#777;cursor:not-allowed;}
        .story-content{background:#1e1e1e;padding:12px;border-radius:8px;margin:8px 0;max-height:50vh;overflow-y:auto;}
        .progress-bar {background:#333;border-radius:5px;margin:10px 0;}
        .progress-fill {height:10px;background:var(--primary-color);border-radius:5px;transition:width 0.3s;}
    </style>
</head>
<body>
<div class="container">
  <div class="header">
    <h1>üìñ Tr√¨nh Ph√¢n T√≠ch & T·∫°o Truy·ªán</h1>
    <p>Ph√¢n t√≠ch n√¢ng cao v√† t·∫°o truy·ªán t·ª± ƒë·ªông</p>
  </div>
  <div id="tab-analysis" class="tab-content active">
    <div class="card">
      <h3>üîç Ph√¢n t√≠ch ngu·ªìn truy·ªán</h3>
      <div class="status-info" id="statusInfo">üî¥ Ch∆∞a k·∫øt n·ªëi Google Drive</div>
      <div class="detailed-status" id="detailedStatus"></div>
      <div class="progress-bar"><div class="progress-fill" id="progressBar" style="width:0%"></div></div>
      <button class="btn" onclick="handleAuthClick()">üìÅ K·∫øt n·ªëi Google Drive</button>
      <button class="btn" id="scanBtn" onclick="scanFolder()" disabled>üîç Qu√©t th∆∞ m·ª•c</button>
      <button class="btn" id="analyzeBtn" onclick="analyzeFiles()" disabled>üß† Ph√¢n t√≠ch n√¢ng cao</button>
      <button class="btn" id="downloadAnalysisBtn" onclick="downloadAnalysisFromDrive()" disabled>üì• T·∫£i ph√¢n t√≠ch</button>
      <button class="btn" onclick="loadAnalysisLocal()">üîÑ T·∫£i cache local</button>
      <button class="btn" onclick="uploadAnalysisToDrive()">‚òÅÔ∏è Upload ph√¢n t√≠ch</button>
    </div>
    <div class="card">
      <h3>üìä K·∫øt qu·∫£ ph√¢n t√≠ch</h3>
      <div id="analysisResults"><p>Ch∆∞a c√≥ d·ªØ li·ªáu ph√¢n t√≠ch.</p></div>
    </div>
  </div>
</div>
<div class="bottom-menu">
  <a href="#" class="menu-item active" onclick="switchTab('tab-analysis')">üîç Ph√¢n t√≠ch</a>
</div>

<script>
// ===== CONSTANTS & GLOBALS =====
const CLIENT_ID = '398509518475-7bjid324tkuuh9gv8b0g92lhsgv8nrl5.apps.googleusercontent.com';
const API_KEY = 'AIzaSyAbcWr0UPvC4YpsunE6uAa7E5pan9iys2o';
const DISCOVERY_DOC = 'https://www.googleapis.com/discovery/v1/apis/drive/v3/rest';
const SCOPES = 'https://www.googleapis.com/auth/drive';
const ROOT_FOLDER_NAME = "QuanLyTruyen";

let tokenClient, gapi_inited = false, gsi_inited = false;
let analysisData = [];
let txtFiles = [];

// ===== WORD DICTIONARIES (Moved to top) =====
const sensitiveWords = {
    romantic: ['y√™u', 'th∆∞∆°ng', 'h√¥n', '√¥m', '·∫•p √¥m', '√¢m √°p', 'say ƒë·∫Øm', 'ƒëam m√™', 'd·ªãu d√†ng', 'ng·ªçt ng√†o', 'quy·∫øn r≈©', 'm√™ ho·∫∑c', 'th√¢n m·∫≠t', 'g·∫ßn g≈©i'],
    sexual: [
        'g·ªëi chƒÉn', 'ph√≤ng the', '√¢n √°i', 'l√†m t√¨nh', 'quan h·ªá', 't√¨nh d·ª•c',
        'd√¢m', 'd·ª•c', 'kho√°i c·∫£m', 'k√≠ch th√≠ch', 'kho·∫£ th√¢n', 'l√µa th·ªÉ',
        's∆∞·ªõng', 'r√™n r·ªâ', 'n·ª©ng', '∆∞·ªõt √°t', 'cao tr√†o', 'c·ª±c kho√°i', 'xu·∫•t tinh',
        'd∆∞∆°ng v·∫≠t', 'c·∫∑c', 'bu·ªìi', 'chim', 'c√°i ·∫•y',
        '√¢m ƒë·∫°o', 'l·ªìn', 'b∆∞·ªõm', '√¢m h·ªô', 'h·ªôt le', 'mu', 'l·ªó', 'xo·∫°c',
        'b√∫ v√∫', 'v√∫ to', 'v√∫ cƒÉng', 'b√∫ m√∫t', 'ng·ª±c tr·∫ßn', 'ng·ª±c kh·ªßng', 'ƒë·∫ßu ti',
        'b√∫ l·ªìn', 'b√∫ c·∫∑c', 'li·∫øm l·ªìn', 'li·∫øm bi', 'nu·ªët tinh', 'b√∫ h·ªôt le', 'b√∫ ƒë·∫ßu c·∫∑c',
        't·ª≠ cung', 'b·∫Øn v√†o t·ª≠ cung', 'c·∫∑c d√†i 20cm', 'ng·∫≠m tinh', 'ch·ªãch', 'ƒë·ªãt', 'n·∫Øc',
        'th·ªïi k√®n', 'bj', 'hj', 'anal', 'doggy', '69', 'threesome', 'th·ªß d√¢m',
        'ch∆°i g√°i', 'ƒëƒ©', 'g√°i m·∫°i d√¢m', 'm√¥ng to', 'th·ª•t ra th·ª•t v√†o', 'c·∫Øm s√¢u',
        's·ªù so·∫°ng', 'm√∫t', 'c·∫Øn', 'xoa', 'vu·ªët ve', 'h√∫p s√≤', 'ph√™', 'nghi·ªán sex',
        'xo·∫°c l·ªìn', 'xo·∫°c c·∫∑c', 'tra t·∫•n t√¨nh d·ª•c', 'h√†nh x√°c', 'ch·ªãu tr·∫≠n',
        'nh√©t', 'ƒë√∫t', 'l√†m nh·ª•c', 'b√≥p v√∫', 't√©t ƒë√≠t', 'v·ªó m√¥ng', 't√∫m t√≥c',
        'b·∫°o d√¢m', 'c∆∞·ª°ng hi·∫øp', 'hi·∫øp d√¢m', 'lo·∫°n lu√¢n', 'th·∫±ng cha', '√¥ng gi√† d√¢m ƒë√£ng',
        'con ƒëƒ©', 'con cave', 'ch·ªã d√¢u', 'em d√¢u', 'anh r·ªÉ', 'ch·ªã g√°i', 'm·∫π ch·ªìng', 'cha con', 'm·∫π con',
        'r√™n la', 'r√™n r·ªâ', 'h√©t l√™n v√¨ s∆∞·ªõng', 'm·∫Øt l·ªù ƒë·ªù', 'm·ªì h√¥i nh·ªÖ nh·∫°i',
        'b·∫Øn tinh', 'phun tinh', 'tinh d·ªãch', 'tinh tr√†n', 'nu·ªët s·∫°ch tinh',
        'm√πi tanh', 'v·ªã m·∫∑n', '∆∞·ªõt ƒë·∫´m', 'n∆∞·ªõc nh·ªùn', 'd·ªãch nh·ªùn',
        'b·ªë ch·ªìng', 'con d√¢u', 'cha ch·ªìng', 'n√†ng d√¢u',
        '"b·ªë ch·ªìng"', '"con d√¢u"', '"cha ch·ªìng"', '"n√†ng d√¢u"',
        '"b·ªë ch·ªìng ∆°i"', '"con d√¢u ngoan"', '"b·ªë ch·ªìng l√†m cho con"',
        '"con d√¢u c·ªßa b·ªë"', '"b·ªë mu·ªën con"', '"b·ªë ch·ªìng kh√¥ng ch·ªãu n·ªïi"',
        '"con d√¢u s∆∞·ªõng qu√°"', '"l√†m d√¢u b·ªë"', '"b·ªë ch·ªìng y√™u con d√¢u"',
        'quan h·ªá v·ªõi b·ªë ch·ªìng', 'quan h·ªá c√πng con d√¢u', 
        'ch·ªãch con d√¢u', 'b·ªë ch·ªìng ƒë·ª• con d√¢u', 'b·ªë ch·ªìng hi·∫øp con d√¢u',
        'l√†m t√¨nh v·ªõi con d√¢u', 'b·ªë ch·ªìng √¥m con d√¢u',
        'con d√¢u r√™n', 'b·ªë ch·ªìng th·ªèa m√£n', 'b·ªë ch·ªìng c∆∞·ª°ng hi·∫øp'
    ],
    negative: ['gh√©t', 'h·∫≠n', 'gi·∫≠n', 't·ª©c', 't·ªßi', 'bu·ªìn', 'ƒëau', 'kh·ªï', 's·∫ßu', 'th·∫£m', 'bi', 'tang', 't·ª≠', 'ch·∫øt', 'gi·∫øt', 'h·∫°i', '√°c', 'd·ªØ', 'hung'],
    family: ['b·ªë', 'm·∫π', 'cha', 'con', 'ch·ªìng', 'v·ª£', 'd√¢u', 'r·ªÉ', 'anh', 'ch·ªã', 'em', '√¥ng', 'b√†', 'ch√∫', 'b√°c', 'c√¥', 'd√¨', 'c·∫≠u', 'm·ª£'],
    secret: ['b√≠ m·∫≠t', 'gi·∫•u gi·∫øm', 'che gi·∫•u', 'gi·∫•u di·∫øm', 'l√©n l√∫t', 'v·ª•ng tr·ªôm', '√¢m th·∫ßm', 'l·∫∑ng l·∫Ω', 'k√≠n ƒë√°o', 'ri√™ng t∆∞']
};

const emotionalWords = {
    positive: ['vui', 'h·∫°nh ph√∫c', 'y√™u', 'th∆∞∆°ng', 'tuy·ªát v·ªùi', 'ƒë·∫πp', 't·ªët', 'xu·∫•t s·∫Øc', 'th√†nh c√¥ng', 'hy v·ªçng'],
    negative: ['bu·ªìn', 'ƒëau', 'kh·ªï', 't·ªá', 'x·∫•u', 'th·∫•t b·∫°i', 'tuy·ªát v·ªçng', 'gh√©t', 't·ª©c gi·∫≠n', 'lo l·∫Øng', 's·ª£ h√£i', 'kh√≥c', 'tang th∆∞∆°ng', 'b·∫•t h·∫°nh', 'd·ªëi tr√°', 'ph·∫£n b·ªôi', 'l·ª´a d·ªëi', 'x√≥t xa', 'ƒëau ƒë·ªõn', 'x·∫•u h·ªï', 't·ªßi nh·ª•c'],
    neutral: ['b√¨nh th∆∞·ªùng', 'th√¥ng th∆∞·ªùng', 'trung b√¨nh', '·ªïn', 'ƒë∆∞·ª£c', 't·∫°m ·ªïn']
};

const dialogueIndicators = ['n√≥i', 'b·∫£o', 'h·ªèi', 'ƒë√°p', 'th∆∞a', 'k√™u', 'g·ªçi', 'h√©t', 'la', 'th√©t', 'th√¨ th·∫ßm', 'r·ªß r·ªâ', 'l√™n ti·∫øng', 'ph√°t bi·ªÉu', 'tr·∫£ l·ªùi', 'h·ªèi l·∫°i', 'ƒë√°p l·∫°i'];
const dialoguePunctuation = ['"', "'", ':', ';', '-', '‚Äî', '‚Äì'];

// ===== GOOGLE API INITIALIZATION =====
function gapiLoaded() {
    gapi.load('client', initializeGapiClient);
}

async function initializeGapiClient() {
    await gapi.client.init({
        apiKey: API_KEY,
        discoveryDocs: [DISCOVERY_DOC]
    });
    gapi_inited = true;
    maybeEnableButtons();
}

function gisLoaded() {
    tokenClient = google.accounts.oauth2.initTokenClient({
        client_id: CLIENT_ID,
        scope: SCOPES,
        callback: ''
    });
    gsi_inited = true;
    maybeEnableButtons();
}

function maybeEnableButtons() {
    if (gapi_inited && gsi_inited) {
        document.getElementById('scanBtn').disabled = false;
    }
}

function handleAuthClick() {
    tokenClient.callback = async (resp) => {
        if (resp.error !== undefined) {
            throw (resp);
        }
        gapi.client.setToken({access_token: resp.access_token});
        updateStatus('üü¢ ƒê√£ k·∫øt n·ªëi Google Drive');
        document.getElementById('scanBtn').disabled = false;
        document.getElementById('downloadAnalysisBtn').disabled = false;
    };

    if (gapi.client.getToken() === null) {
        tokenClient.requestAccessToken({prompt: 'consent'});
    } else {
        tokenClient.requestAccessToken({prompt: ''});
    }
}

// ===== UI UPDATE FUNCTIONS =====
function updateStatus(msg) {
    document.getElementById('statusInfo').innerText = msg;
}

function updateProgress(p) {
    document.getElementById('progressBar').style.width = p + '%';
}

function updateDetailedStatus(msg) {
    document.getElementById('detailedStatus').innerText = msg;
}

// ===== LOCAL STORAGE FUNCTIONS =====
function saveAnalysisLocal() {
    const analysisContent = {
        analysisData: analysisData,
        timestamp: new Date().toISOString()
    };
    localStorage.setItem('analysisResults', JSON.stringify(analysisContent));
}

function loadAnalysisLocal() {
    const data = localStorage.getItem('analysisResults');
    if (data) {
        try {
            const parsed = JSON.parse(data);
            analysisData = parsed.analysisData || [];
            displayAdvancedAnalysisResults();
            updateStatus('‚úÖ ƒê√£ t·∫£i cache local');
            return true;
        } catch (e) {
            console.error('Error loading local cache:', e);
        }
    }
    return false;
}

// ===== GOOGLE DRIVE FUNCTIONS =====
function uploadAnalysisToDrive() {
    if (!analysisData || analysisData.length === 0) {
        alert("‚ö†Ô∏è Kh√¥ng c√≥ d·ªØ li·ªáu ph√¢n t√≠ch ƒë·ªÉ upload!");
        return;
    }

    const fileContent = JSON.stringify(analysisData, null, 2);
    const file = new Blob([fileContent], { type: 'application/json' });

    const metadata = {
        name: "analysisData.json",
        mimeType: "application/json"
    };

    const accessToken = gapi.client.getToken().access_token;
    const form = new FormData();
    form.append("metadata", new Blob([JSON.stringify(metadata)], { type: "application/json" }));
    form.append("file", file);

    fetch("https://www.googleapis.com/upload/drive/v3/files?uploadType=multipart&fields=id", {
        method: "POST",
        headers: new Headers({ "Authorization": "Bearer " + accessToken }),
        body: form
    }).then(res => res.json()).then(val => {
        alert("‚úÖ ƒê√£ upload ph√¢n t√≠ch l√™n Google Drive: " + val.id);
    }).catch(err => {
        console.error("Upload l·ªói:", err);
        alert("‚ùå L·ªói khi upload: " + err.message);
    });
}

async function downloadAnalysisFromDrive() {
    try {
        const accessToken = gapi.client.getToken().access_token;

        let res = await fetch(
            "https://www.googleapis.com/drive/v3/files?q=name='analysisData.json'&fields=files(id,name)",
            { headers: new Headers({ "Authorization": "Bearer " + accessToken }) }
        );
        let data = await res.json();

        if (!data.files || data.files.length === 0) {
            alert("‚ö†Ô∏è Kh√¥ng t√¨m th·∫•y file analysisData.json tr√™n Google Drive!");
            return;
        }

        const fileId = data.files[0].id;

        let fileRes = await fetch(
            `https://www.googleapis.com/drive/v3/files/${fileId}?alt=media`,
            { headers: new Headers({ "Authorization": "Bearer " + accessToken }) }
        );
        let content = await fileRes.json();

        analysisData = content;
        saveAnalysisLocal();

        alert("‚úÖ ƒê√£ t·∫£i ph√¢n t√≠ch v·ªÅ t·ª´ Google Drive!");
        displayAdvancedAnalysisResults();

    } catch (err) {
        console.error("Download l·ªói:", err);
        alert("‚ùå L·ªói khi t·∫£i ph√¢n t√≠ch t·ª´ Google Drive: " + err.message);
    }
}

// ===== SCAN FOLDER FUNCTION =====
async function scanFolder() {
    updateStatus("üîç ƒêang qu√©t th∆∞ m·ª•c QuanLyTruyen...");
    updateProgress(5);

    try {
        const folderRes = await gapi.client.drive.files.list({
            q: `mimeType='application/vnd.google-apps.folder' and name='${ROOT_FOLDER_NAME}' and trashed=false`,
            fields: "files(id, name)"
        });

        if (!folderRes.result.files || folderRes.result.files.length === 0) {
            updateStatus("‚ùå Kh√¥ng t√¨m th·∫•y th∆∞ m·ª•c QuanLyTruyen tr√™n Google Drive!");
            return;
        }

        const rootFolderId = folderRes.result.files[0].id;
        txtFiles = [];
        await fetchFilesRecursive(rootFolderId, ROOT_FOLDER_NAME);

        if (txtFiles.length === 0) {
            updateStatus("‚ö†Ô∏è Kh√¥ng c√≥ file .txt n√†o trong QuanLyTruyen.");
            return;
        }

        updateStatus(`‚úÖ ƒê√£ qu√©t ƒë∆∞·ª£c ${txtFiles.length} file .txt`);
        updateProgress(100);
        document.getElementById("analyzeBtn").disabled = false;

    } catch (err) {
        console.error("‚ùå L·ªói khi qu√©t th∆∞ m·ª•c:", err);
        updateStatus("‚ùå L·ªói khi qu√©t th∆∞ m·ª•c: " + err.message);
    }
}

// --- Thay th·∫ø fetchFilesRecursive ƒë·ªÉ l∆∞u c·∫£ mimeType (n√™n d√°n thay h√†m c≈©) ---
async function fetchFilesRecursive(folderId, path){
  let pageToken=null;
  do{
    const res = await gapi.client.drive.files.list({
      q:`'${folderId}' in parents and trashed=false`,
      fields:"nextPageToken, files(id,name,mimeType)", pageToken
    });
    for(const f of res.result.files){
      if(f.mimeType==="application/vnd.google-apps.folder"){
        await fetchFilesRecursive(f.id, path+"/"+f.name);
      } else if(
        f.mimeType==="text/plain" ||
        f.name.toLowerCase().endsWith(".txt") ||
        f.mimeType==="application/vnd.google-apps.document" // h·ªó tr·ª£ Google Docs
      ){
        txtFiles.push({id:f.id,name:f.name,path, mimeType:f.mimeType});
      }
    }
    pageToken=res.result.nextPageToken;
  }while(pageToken);
}


// --- analyzeFiles n√¢ng cao ---
async function analyzeFiles(){
  if(!txtFiles.length){ alert("Ch∆∞a c√≥ file"); return; }
  analysisData=[];
  document.getElementById("detailedStatus").innerText = "";
  try{
    for(let i=0;i<txtFiles.length;i++){
      const f = txtFiles[i];
      updateProgress(Math.round((i/txtFiles.length)*100));
      let record = { file: f.name, path: f.path, words:0, sample:'', meta:{}, counts:{}, dialogueCounts:{}, error:null };
      try{
        const text = await readFileFromDrive(f.id, f.mimeType);
        record.words = text.split(/\s+/).filter(Boolean).length;
        record.sample = text.substring(0,300);
        const meta = parseMetadataFromText(text);
        record.meta = meta;

        // ƒë·∫øm sensitiveWords
        if(meta.sensitiveWords && meta.sensitiveWords.length){
          for(const w of meta.sensitiveWords){
            record.counts[w] = countOccurrences(text, w);
          }
        }

        // ƒë·∫øm dialogueIndicators
        if(meta.dialogueIndicators && meta.dialogueIndicators.length){
          for(const d of meta.dialogueIndicators){
            record.dialogueCounts[d] = countOccurrences(text, d);
          }
        }

      } catch(err){
        record.error = err.message || String(err);
      }
      analysisData.push(record);
      updateProgress(Math.round(((i+1)/txtFiles.length)*100));
    }

    // Hi·ªÉn th·ªã k·∫øt qu·∫£
    displayAnalysis();

  } catch(e){
    document.getElementById("detailedStatus").innerText = "L·ªói ph√¢n t√≠ch chung: "+e.message;
    console.error(e);
  }
}
// --- displayAnalysis n√¢ng cao ---
function displayAnalysis(){
  let html = `<h4>ƒê√£ ph√¢n t√≠ch ${analysisData.length} file</h4>`;
  let overallErrors = [];
  analysisData.forEach(d=>{
    html += `<div class='story-content'><b>${d.file}</b> <small>(${d.path})</small><br/>`;
    if(d.error){
      html += `<div style="color:#ff6b6b"><b>L·ªói:</b> ${d.error}</div>`;
      overallErrors.push(`${d.file}: ${d.error}`);
    } else {
      html += `S·ªë t·ª´: ${d.words}<br/>M·∫´u: <code>${escapeHtml(d.sample)}</code><br/>`;
      html += `<b>Metadata t√¨m ƒë∆∞·ª£c:</b><br/>`;
      html += `<pre>${JSON.stringify(d.meta, null, 2)}</pre>`;
      if(Object.keys(d.counts).length){
        html += `<b>ƒê·∫øm sensitiveWords:</b><ul>`;
        for(const k in d.counts) html += `<li>${escapeHtml(k)} ‚Üí ${d.counts[k]}</li>`;
        html += `</ul>`;
      }
      if(Object.keys(d.dialogueCounts).length){
        html += `<b>ƒê·∫øm dialogueIndicators:</b><ul>`;
        for(const k in d.dialogueCounts) html += `<li>${escapeHtml(k)} ‚Üí ${d.dialogueCounts[k]}</li>`;
        html += `</ul>`;
      }
    }
    html += `</div>`;
  });
  document.getElementById("analysisResults").innerHTML = html;
  if(overallErrors.length){
    document.getElementById("detailedStatus").innerText = "M·ªôt s·ªë file ph√¢n t√≠ch b·ªã l·ªói ‚Äî xem chi ti·∫øt ·ªü b√™n d∆∞·ªõi.";
    console.warn("Analysis errors:", overallErrors);
  } else {
    document.getElementById("detailedStatus").innerText = "Ph√¢n t√≠ch ho√†n t·∫•t ‚Äî kh√¥ng th·∫•y l·ªói.";
  }
}

// --- escapeHtml helper ƒë·ªÉ hi·ªÉn th·ªã an to√†n trong HTML ---
function escapeHtml(s){
  return String(s||'').replace(/[&<>"']/g, function(m){ return ({'&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;',"'":'&#39;'}[m]); });
}
// --- readFileFromDrive: x·ª≠ l√Ω export cho Google Docs + ki·ªÉm tra l·ªói HTTP ---
async function readFileFromDrive(fileId, mimeType){
  const token = gapi.client.getToken();
  if(!token || !token.access_token) throw new Error("Kh√¥ng c√≥ access token ‚Äî h√£y ƒëƒÉng nh·∫≠p tr∆∞·ªõc khi qu√©t/ ph√¢n t√≠ch.");
  const accessToken = token.access_token;

  // N·∫øu l√† Google Docs, ph·∫£i export v·ªÅ text/plain
  if(mimeType === 'application/vnd.google-apps.document'){
    const res = await fetch(`https://www.googleapis.com/drive/v3/files/${fileId}/export?mimeType=text/plain`, {
      headers:{ Authorization: `Bearer ${accessToken}` }
    });
    if(!res.ok) throw new Error(`L·ªói export Google Doc: ${res.status} ${res.statusText}`);
    return await res.text();
  } else {
    const res = await fetch(`https://www.googleapis.com/drive/v3/files/${fileId}?alt=media`, {
      headers:{ Authorization: `Bearer ${accessToken}` }
    });
    if(!res.ok) throw new Error(`L·ªói download: ${res.status} ${res.statusText}`);
    return await res.text();
  }
}
// --- helper: escape regex ---
function escapeRegExp(s){ return s.replace(/[.*+?^${}()|[\]\\]/g, '\\$&'); }
// --- helper: ƒë·∫øm occurrences (case-insensitive) ---
function countOccurrences(text, needle){
  if(!needle) return 0;
  try{
    const re = new RegExp(escapeRegExp(needle), 'gi');
    const m = text.match(re);
    return m ? m.length : 0;
  } catch(e){
    return 0;
  }
}
// --- helper: parse array-like value cho key (h·ªó tr·ª£ JS-assignment, JSON, YAML list) ---
function parseArrayKeyFromText(text, key){
  // 1) JS or JSON style: key = [...], "key": [...], key: [...]
  let patterns = [
    new RegExp(key + '\\s*[:=]\\s*(\\[[\\s\\S]*?\\])','i'),
    new RegExp('"' + key + '"\\s*:\\s*(\\[[\\s\\S]*?\\])','i'),
    // YAML list under key:
    new RegExp(key + '\\s*:\\s*\\n(\\s*\\-\\s.*(?:\\n\\s*\\-.*)*)','i')
  ];
  for(const p of patterns){
    const m = text.match(p);
    if(m){
      let arrText = m[1].trim();
      // YAML list case (lines starting with -)
      if(arrText.split(/\r?\n/).every(line => line.trim().startsWith('-'))){
        return arrText.split(/\r?\n/).map(l=>l.replace(/^\s*-\s*/,'').trim()).filter(Boolean);
      }
      // Else try normalize to valid JSON array
      try{
        // replace single quotes -> double quotes (naive but works for common cases)
        let candidate = arrText.replace(/'/g, '"').replace(/,\s*]/g,']').replace(/,\s*}/g,'}');
        return JSON.parse(candidate);
      } catch(e){
        // Fallback: split by commas and trim quotes
        const items = arrText.replace(/^\[|\]$/g,'').split(',').map(s=>s.trim().replace(/^['"]|['"]$/g,'')).filter(Boolean);
        return items;
      }
    }
  }
  return null;
}
// --- parse metadata t·ªïng qu√°t (tr·∫£ v·ªÅ object: sensitiveWords, dialogueIndicators, errors) ---
function parseMetadataFromText(text){
  const out = { sensitiveWords: [], dialogueIndicators: [], errors: [] };

  // 1) YAML frontmatter (--- ... ---)
  const yamlMatch = text.match(/^---\s*([\s\S]*?)\s*---/);
  if(yamlMatch){
    try{
      const body = yamlMatch[1];
      // t√¨m keys trong YAML
      const sw = body.match(/sensitiveWords\s*:\s*((?:\n\s*-\s.*)+)/i);
      if(sw) out.sensitiveWords = sw[1].split(/\r?\n/).map(l=>l.replace(/^\s*-\s*/,'').trim()).filter(Boolean);
      const di = body.match(/dialogueIndicators\s*:\s*((?:\n\s*-\s.*)+)/i);
      if(di) out.dialogueIndicators = di[1].split(/\r?\n/).map(l=>l.replace(/^\s*-\s*/,'').trim()).filter(Boolean);
    } catch(e){
      out.errors.push("YAML parse error: "+e.message);
    }
  }

  // 2) JS/JSON style (sensitiveWords = [..], "sensitiveWords": [..], etc.)
  if(!out.sensitiveWords.length){
    const parsed = parseArrayKeyFromText(text, 'sensitiveWords');
    if(parsed) out.sensitiveWords = parsed;
  }
  if(!out.dialogueIndicators.length){
    const parsed = parseArrayKeyFromText(text, 'dialogueIndicators');
    if(parsed) out.dialogueIndicators = parsed;
  }

  // 3) N·∫øu v·∫´n kh√¥ng c√≥, th·ª≠ t√¨m ki·ªÉu t√™n bi·∫øn v·ªõi camelCase ho·∫∑c snake_case
  if(!out.sensitiveWords.length){
    const parsed2 = parseArrayKeyFromText(text, 'sensitive_words') || parseArrayKeyFromText(text, 'sensitiveWords');
    if(parsed2) out.sensitiveWords = parsed2;
  }
  if(!out.dialogueIndicators.length){
    const parsed2 = parseArrayKeyFromText(text, 'dialogue_indicators') || parseArrayKeyFromText(text, 'dialogueIndicators');
    if(parsed2) out.dialogueIndicators = parsed2;
  }

  return out;
}

// ===== STORY ANALYSIS FUNCTIONS =====
async function performAdvancedAnalysis(content, fileName, folderPath) {
    const structure = analyzeStoryStructure(content);
    const wordCount = content.split(/\s+/).filter(word => word.length > 0).length;

    return {
        fileName: fileName,
        folderPath: folderPath,
        timestamp: new Date().toLocaleString('vi-VN'),
        basicStats: { 
            wordCount: wordCount,
            charCount: content.length,
            lineCount: content.split('\n').length
        },
        contentSample: content.substring(0, 200) + (content.length > 200 ? '...' : ''),
        storyStructure: structure
    };
}

function analyzeStoryStructure(content) {
    const lower = content.toLowerCase();
    
    // Helper function to find matches
    function findMatches(words) {
        return words.filter(w => lower.includes(w.toLowerCase()));
    }

    // 1. Structural analysis
    const contentLength = content.length;
    const moBai = content.substring(0, Math.min(300, contentLength));
    const ketBai = contentLength > 300 ? content.substring(Math.max(0, contentLength - 300)) : '';
    const thanBai = contentLength > 600 ? content.substring(300, contentLength - 300) : content.substring(300);

    // 2. Narrative perspective
    let ngoike = "Ng√¥i th·ª© ba";
    if (/\bt√¥i\b|\bta\b|\bch√∫ng t√¥i\b/i.test(content)) ngoike = "Ng√¥i th·ª© nh·∫•t";
    if (/\bb·∫°n\b|\bc·∫≠u\b|\bm√†y\b/i.test(content)) ngoike = "Ng√¥i th·ª© hai";

    // 3. Character detection (proper nouns)
    let characterMatches = content.match(/\b[A-Z√Ä√Å·∫¢√É·∫†√ÇƒÇƒê√ä√î∆†∆Ø][a-z√†√°·∫£√£·∫°√¢ƒÉƒë√™√¥∆°∆∞]+\b/g) || [];
    let uniqueChars = [...new Set(characterMatches)].slice(0, 10);

    // 4. Dialogue detection
    let dialogues = [];
    const lines = content.split('\n');
    for (const line of lines) {
        if (/["'].*["']/.test(line) || dialogueIndicators.some(ind => line.toLowerCase().includes(ind))) {
            dialogues.push(line.trim());
            if (dialogues.length >= 5) break;
        }
    }

    // 5. Time and place keywords
    const timeKeywords = ["s√°ng", "tr∆∞a", "chi·ªÅu", "t·ªëi", "ƒë√™m", "h√¥m qua", "ng√†y mai", "nƒÉm", "th√°ng", "tu·∫ßn", "gi·ªù"];
    const placeKeywords = ["nh√†", "l√†ng", "th√†nh ph·ªë", "r·ª´ng", "bi·ªÉn", "n√∫i", "tr∆∞·ªùng", "ch·ª£", "s√¥ng", "ph·ªë", "qu√™"];
    const eventKeywords = ["g·∫∑p g·ª°", "chia ly", "th·ª≠ th√°ch", "xung ƒë·ªôt", "chi·∫øn ƒë·∫•u", "gi·∫£i c·ª©u", "b√≠ m·∫≠t", "c∆∞·ªõi", "ch·∫øt"];

    let times = findMatches(timeKeywords);
    let places = findMatches(placeKeywords);
    let events = findMatches(eventKeywords);

    // 6. Sensitive content analysis
    let romantic = findMatches(sensitiveWords.romantic);
    let sexual = findMatches(sensitiveWords.sexual);
    let negative = findMatches(sensitiveWords.negative);
    let family = findMatches(sensitiveWords.family);
    let secret = findMatches(sensitiveWords.secret);

    // 7. Emotional analysis
    let emotionPos = findMatches(emotionalWords.positive);
    let emotionNeg = findMatches(emotionalWords.negative);
    let emotionNeu = findMatches(emotionalWords.neutral);

    return {
        moBai: moBai,
        thanBai: thanBai.substring(0, 500) + (thanBai.length > 500 ? '...' : ''),
        ketBai: ketBai,
        ngoike: ngoike,
        nhanVat: uniqueChars,
        hoiThoai: dialogues,
        thoiGian: times,
        diaDiem: places,
        tinhHuong: events,
        tuNgu18: sexual, // Renamed for consistency
        romantic: romantic,
        sexual: sexual,
        negative: negative,
        family: family,
        secret: secret,
        emotion: {
            positive: emotionPos,
            negative: emotionNeg,
            neutral: emotionNeu
        }
    };
}

// ===== DISPLAY RESULTS FUNCTION =====
function displayAdvancedAnalysisResults() {
    const safeArray = v => Array.isArray(v) ? v : [];
    const safeJoin = (value, separator = ', ') => {
        if (Array.isArray(value)) {
            return value.join(separator);
        }
        if (typeof value === "string") {
            return value;
        }
        return "";
    };

    const container = document.getElementById('analysisResults');
    if (!analysisData || analysisData.length === 0) {
        container.innerHTML = '<p>Ch∆∞a c√≥ d·ªØ li·ªáu ph√¢n t√≠ch.</p>';
        return;
    }

    let html = `<h4>üìä ƒê√£ ph√¢n t√≠ch ${analysisData.length} file truy·ªán</h4>`;

    // Statistics summary
    const totalWords = analysisData.reduce((sum, d) => sum + (d.basicStats?.wordCount || 0), 0);
    const avgWords = Math.round(totalWords / analysisData.length);
    html += `<div style="background:#2c3e50;padding:10px;margin:10px 0;border-radius:8px;">
        <p><strong>üìà Th·ªëng k√™ t·ªïng quan:</strong></p>
        <p>‚Ä¢ T·ªïng s·ªë t·ª´: ${totalWords.toLocaleString()} t·ª´</p>
        <p>‚Ä¢ Trung b√¨nh: ${avgWords.toLocaleString()} t·ª´/file</p>
    </div>`;

    analysisData.forEach((d, index) => {
        if (d.error) {
            html += `<div style="background:#e74c3c;padding:10px;margin:10px 0;border-radius:8px;">
                ‚ùå <strong>${d.fileName}</strong>: ${d.error}
            </div>`;
        } else {
            const struct = d.storyStructure || {};
            html += `<div style="background:#34495e;padding:15px;margin:10px 0;border-radius:8px;">
                <h5>üìÑ ${d.fileName}</h5>
                <p style="color:#bdc3c7;font-size:0.9em;">${d.folderPath} ‚Ä¢ ${d.timestamp}</p>
                
                <div style="display:grid;grid-template-columns:1fr 1fr;gap:10px;margin:10px 0;">
                    <div><strong>üìä S·ªë t·ª´:</strong> ${(d.basicStats?.wordCount || 0).toLocaleString()}</div>
                    <div><strong>üìù Ng√¥i k·ªÉ:</strong> ${struct.ngoike || 'Kh√¥ng x√°c ƒë·ªãnh'}</div>
                </div>

                <div style="margin:10px 0;">
                    <p><strong>üë• Nh√¢n v·∫≠t:</strong> ${safeJoin(struct.nhanVat)}</p>
                    <p><strong>‚è∞ Th·ªùi gian:</strong> ${safeJoin(struct.thoiGian)}</p>
                    <p><strong>üåç ƒê·ªãa ƒëi·ªÉm:</strong> ${safeJoin(struct.diaDiem)}</p>
                    <p><strong>üé≠ T√¨nh hu·ªëng:</strong> ${safeJoin(struct.tinhHuong)}</p>
                </div>

                <!-- Content Structure -->
                <div style="margin:10px 0;">
                    <details>
                        <summary style="cursor:pointer;color:#3498db;"><strong>üìñ M·ªü b√†i</strong></summary>
                        <div class="story-content">${struct.moBai || 'Kh√¥ng c√≥ d·ªØ li·ªáu'}</div>
                    </details>
                    
                    <details>
                        <summary style="cursor:pointer;color:#3498db;"><strong>üìñ Th√¢n b√†i</strong></summary>
                        <div class="story-content">${struct.thanBai || 'Kh√¥ng c√≥ d·ªØ li·ªáu'}</div>
                    </details>
                    
                    <details>
                        <summary style="cursor:pointer;color:#3498db;"><strong>üìñ K·∫øt b√†i</strong></summary>
                        <div class="story-content">${struct.ketBai || 'Kh√¥ng c√≥ d·ªØ li·ªáu'}</div>
                    </details>
                </div>

                <!-- Dialogue -->
                ${struct.hoiThoai && struct.hoiThoai.length > 0 ? `
                <details>
                    <summary style="cursor:pointer;color:#2ecc71;"><strong>üí¨ H·ªôi tho·∫°i (${struct.hoiThoai.length})</strong></summary>
                    <div class="story-content">
                        ${struct.hoiThoai.map(dialogue => `<p>‚Ä¢ ${dialogue}</p>`).join('')}
                    </div>
                </details>` : ''}

                <!-- Emotional Analysis -->
                <div style="margin:10px 0;">
                    <p><strong>üòä C·∫£m x√∫c t√≠ch c·ª±c:</strong> ${safeJoin(safeArray(struct.emotion?.positive))}</p>
                    <p><strong>üò¢ C·∫£m x√∫c ti√™u c·ª±c:</strong> ${safeJoin(safeArray(struct.emotion?.negative))}</p>
                    <p><strong>üòê C·∫£m x√∫c trung t√≠nh:</strong> ${safeJoin(safeArray(struct.emotion?.neutral))}</p>
                </div>

                <!-- Content Categories -->
                <div style="margin:10px 0;">
                    <p><strong>üíù Ng√¥n ng·ªØ t√¨nh c·∫£m:</strong> ${safeJoin(struct.romantic)}</p>
                    <p><strong>üë®‚Äçüë©‚Äçüëß‚Äçüë¶ Gia ƒë√¨nh:</strong> ${safeJoin(struct.family)}</p>
                    <p><strong>ü§´ B√≠ m·∫≠t:</strong> ${safeJoin(struct.secret)}</p>
                    <p><strong>‚ö†Ô∏è Ti√™u c·ª±c:</strong> ${safeJoin(struct.negative)}</p>
                    ${struct.sexual && struct.sexual.length > 0 ? `
                        <p><strong>üîû N·ªôi dung nh·∫°y c·∫£m:</strong> <span style="color:#e74c3c;">${struct.sexual.length} t·ª´ kh√≥a ph√°t hi·ªán</span></p>
                    ` : ''}
                </div>

                <!-- Content Sample -->
                <details>
                    <summary style="cursor:pointer;color:#95a5a6;"><strong>üìù M·∫´u n·ªôi dung</strong></summary>
                    <div class="story-content" style="font-style:italic;">${d.contentSample || 'Kh√¥ng c√≥ d·ªØ li·ªáu'}</div>
                </details>
            </div>`;
        }
    });

    container.innerHTML = html;
}

// ===== UI NAVIGATION =====
function switchTab(id) {
    document.querySelectorAll('.tab-content').forEach(t => t.classList.remove('active'));
    document.querySelectorAll('.menu-item').forEach(m => m.classList.remove('active'));
    
    document.getElementById(id).classList.add('active');
    event.target.classList.add('active');
}

// ===== INITIALIZATION =====
document.addEventListener('DOMContentLoaded', function() {
    // Try to load cached analysis on page load
    loadAnalysisLocal();
});
</script>

<script async defer src="https://apis.google.com/js/api.js" onload="gapiLoaded()"></script>
<script async defer src="https://accounts.google.com/gsi/client" onload="gisLoaded()"></script>
</body>
</html>
