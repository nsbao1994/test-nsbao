<!doctype html>
<html lang="vi">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover" />
  <title>Qu·∫£n L√Ω Truy·ªán ‚Äî Drive + TensorFlow.js + ml5 (50 ch∆∞∆°ng)</title>

  <!-- Google Identity Services + Google API Client -->
  <script src="https://accounts.google.com/gsi/client" async defer></script>
  <script async defer src="https://apis.google.com/js/api.js"></script>

  <!-- TensorFlow.js + Universal Sentence Encoder (TFJS) -->
  <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@4.21.0/dist/tf.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/@tensorflow-models/universal-sentence-encoder"></script>

  <!-- ml5.js (sentiment) -->
  <script src="https://unpkg.com/ml5@0.12.2/dist/ml5.min.js"></script>

  <style>
    :root{ --bg:#0a0f14; --card:#0f1620; --text:#e6eef7; --muted:#9ab0c8; --accent:#4ea1ff; --line:#203047; --good:#25c059; --warn:#f0b429; --bad:#ff6b6b; }
    *{box-sizing:border-box}
    html,body{height:100%}
    body{ margin:0; font-family:system-ui,-apple-system,Segoe UI,Roboto,Helvetica,Arial; background:linear-gradient(180deg,#0a0f14,#101827); color:var(--text); padding-bottom:76px; }
    header{position:sticky;top:0;z-index:50; backdrop-filter:saturate(1.2) blur(6px); background:rgba(10,15,20,.7); border-bottom:1px solid var(--line); display:flex; align-items:center; justify-content:space-between; gap:12px; padding:16px 16px 12px;}
    h1{margin:0; font-size:16px; font-weight:600}
    .btn{border:1px solid var(--line); background:#0d1420; color:var(--text); padding:10px 14px; border-radius:12px; cursor:pointer; transition:.15s ease; font-weight:600}
    .btn:hover{border-color:var(--accent); transform:translateY(-1px)}
    .btn.primary{background:linear-gradient(180deg,#16263b,#0f1a2a); border-color:#2f4d78}
    .wrap{max-width:980px; margin:0 auto; padding:14px 14px 24px}
    .card{background:var(--card); border:1px solid var(--line); border-radius:16px; padding:16px; margin-top:14px}
    .row{display:grid; grid-template-columns:1fr; gap:14px}
    @media(min-width:960px){ .row{grid-template-columns:1.1fr .9fr} }
    label{display:block; font-size:12px; color:var(--muted); margin-bottom:6px}
    input[type="number"], input[type="text"], textarea, select{ width:100%; padding:12px 12px; border-radius:12px; border:1px solid #1b283c; background:#0c1420; color:var(--text); -webkit-appearance:none; appearance:none; }
    textarea{min-height:160px; resize:vertical; line-height:1.55}
    .muted{color:var(--muted)}
    .pill{display:inline-flex; align-items:center; gap:6px; padding:6px 10px; border-radius:999px; background:#0e2034; border:1px solid #183654; color:#b9d7ff; font-size:12px; margin:2px 6px 2px 0}
    .progress{height:10px; background:#0b1420; border-radius:8px; overflow:hidden; border:1px solid #1c2b42}
    .bar{height:100%; width:0%; background:linear-gradient(90deg,#4ea1ff,#7bd4ff)}
    .status{font-size:13px}
    .list{font-family:ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas; font-size:13px; white-space:pre-wrap}
    .grid2{display:grid; grid-template-columns:1fr 1fr; gap:10px}
    .grid3{display:grid; grid-template-columns:1fr 1fr 1fr; gap:10px}
    .kbd{font-family:ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas; background:#0d1520; border:1px solid #21324a; padding:3px 6px; border-radius:6px}
    .bottom-nav{position:fixed; bottom:0; left:0; right:0; z-index:60; background:rgba(9,14,20,.8); backdrop-filter:saturate(1.2) blur(8px); border-top:1px solid var(--line); display:flex; height:64px; padding-bottom:env(safe-area-inset-bottom);} .tab{flex:1; display:flex; flex-direction:column; align-items:center; justify-content:center; gap:4px; color:var(--muted); font-size:11px; cursor:pointer; user-select:none} .tab.active{color:#d6e7ff}
    .page{display:none} .page.active{display:block}

    /* T·ªëi ∆∞u cho iPhone X */
    @media only screen and (max-width: 375px) and (max-height: 812px) and (-webkit-device-pixel-ratio: 3) {
      :root {
        --safe-area-inset-top: env(safe-area-inset-top);
        --safe-area-inset-bottom: env(safe-area-inset-bottom);
        --safe-area-inset-left: env(safe-area-inset-left);
        --safe-area-inset-right: env(safe-area-inset-right);
      }
      
      body {
        padding-top: var(--safe-area-inset-top);
        padding-bottom: calc(76px + var(--safe-area-inset-bottom));
      }
      
      header {
        padding-top: calc(16px + var(--safe-area-inset-top));
        padding-left: calc(16px + var(--safe-area-inset-left));
        padding-right: calc(16px + var(--safe-area-inset-right));
      }
      
      .wrap {
        padding-left: calc(14px + var(--safe-area-inset-left));
        padding-right: calc(14px + var(--safe-area-inset-right));
      }
      
      .bottom-nav {
        padding-left: var(--safe-area-inset-left);
        padding-right: var(--safe-area-inset-right);
        padding-bottom: var(--safe-area-inset-bottom);
        height: calc(64px + var(--safe-area-inset-bottom));
      }
      
      .grid3, .grid2 {
        grid-template-columns: 1fr;
      }
      
      .btn {
        padding: 12px 14px;
        font-size: 14px;
      }
    }
  </style>
</head>
<body>
<header>
  <h1>üìö Qu·∫£n L√Ω Truy·ªán ‚Äî Google Drive + TensorFlow.js + ml5</h1>
  <div style="display:flex; gap:8px; align-items:center">
    <button id="signin" class="btn">ƒêƒÉng nh·∫≠p Google</button>
    <button id="signout" class="btn" style="display:none">ƒêƒÉng xu·∫•t</button>
  </div>
</header>

<div class="wrap">
  <div class="card">
    <div style="display:flex; gap:10px; align-items:center; flex-wrap:wrap">
      <div class="pill">Th∆∞ m·ª•c g·ªëc: <b>QuanLyTruyen</b></div>
      <div class="pill" id="authState">Ch∆∞a ƒëƒÉng nh·∫≠p</div>
      <div class="pill" id="qltState">Ch∆∞a t·∫£i d·ªØ li·ªáu</div>
      <div class="status" id="status"></div>
    </div>
    <div class="progress" style="margin-top:10px"><div class="bar" id="bar"></div></div>
  </div>

  <!-- PAGE: D·ªÆ LI·ªÜU -->
  <section id="page-data" class="page active">
    <div class="row">
      <div class="card">
        <h3 style="margin:0 0 8px">1) N·∫°p d·ªØ li·ªáu t·ª´ Drive</h3>
        <div class="grid3">
          <div>
            <label>Gi·ªõi h·∫°n s·ªë file</label>
            <input id="maxFiles" type="number" value="200" min="1" />
          </div>
          <div>
            <label>K√≠ch th∆∞·ªõc t·ªëi ƒëa t·∫£i (MB)</label>
            <input id="maxMB" type="number" value="50" min="1" />
          </div>
          <div>
            <label>Ch·ªâ l·∫•y trong th∆∞ m·ª•c con</label>
            <input id="subFolder" type="text" placeholder="(tu·ª≥ ch·ªçn) V√≠ d·ª•: TruyenNguon" />
          </div>
        </div>
        <div style="margin-top:10px; display:flex; gap:10px; flex-wrap:wrap">
          <button id="loadTexts" class="btn primary">T·∫£i .txt trong "QuanLyTruyen"</button>
          <button id="clearAll" class="btn">Xo√° d·ªØ li·ªáu trong RAM</button>
          <button id="saveCache" class="btn">L∆∞u cache ph√¢n t√≠ch l√™n Drive</button>
          <button id="loadCache" class="btn">T·∫£i cache ph√¢n t√≠ch</button>
        </div>
        <div class="footer muted" style="margin-top:8px">C·∫ßn quy·ªÅn: <span class="kbd">drive.readonly</span> + <span class="kbd">drive.file</span> ƒë·ªÉ l∆∞u cache/ch∆∞∆°ng.</div>
        <div id="filesInfo" class="muted" style="margin-top:10px"></div>
        <textarea id="corpusPreview" placeholder="Xem tr∆∞·ªõc v√†i ƒëo·∫°n ƒë√£ n·∫°p..."></textarea>
      </div>

      <div class="card">
        <h3 style="margin:0 0 8px">2) Ph√¢n t√≠ch n√¢ng cao (TF.js + ml5 sentiment)</h3>
        <div style="display:flex; gap:10px; flex-wrap:wrap">
          <button id="analyze" class="btn">Ph√¢n t√≠ch</button>
          <button id="exportStats" class="btn">Xu·∫•t JSON th·ªëng k√™</button>
        </div>
        <div id="analysis" class="list" style="margin-top:10px"></div>
      </div>
    </div>
  </section>

  <!-- PAGE: VI·∫æT TRUY·ªÜN -->
  <section id="page-write" class="page">
    <div class="card">
      <h3 style="margin:0 0 8px">3) Vi·∫øt truy·ªán 50 ch∆∞∆°ng (ng√¥i th·ª© nh·∫•t)</h3>
      <div class="grid3">
        <div>
          <label>M·ª•c ti√™u t·ª´ m·ªói ch∆∞∆°ng</label>
          <input id="wordsPerChapter" type="number" value="2300" min="1200" max="4000" />
        </div>
        <div>
          <label>B·∫≠c Markov (n-gram theo t·ª´)</label>
          <input id="order" type="number" value="3" min="1" max="5" />
        </div>
        <div>
          <label>C·∫£m x√∫c m·ª•c ti√™u (‚àí1‚Ä¶+1)</label>
          <input id="targetSentiment" type="number" step="0.1" min="-1" max="1" value="0.1" />
        </div>
      </div>
      <div class="grid2" style="margin-top:10px">
        <div>
          <label>H·∫°t gi·ªëng m·ªü truy·ªán (t√πy ch·ªçn)</label>
          <input id="seed" type="text" placeholder="V√≠ d·ª•: 'T√¥i t·ªânh d·∫≠y gi·ªØa ƒë√™m m∆∞a...'" />
        </div>
        <div>
          <label>T√™n truy·ªán (ƒë·ªÉ tr·ªëng ƒë·ªÉ AI t·ª± ƒë·∫∑t)</label>
          <input id="titleInput" type="text" placeholder="AI s·∫Ω t·ª± ƒë·ªÅ xu·∫•t" />
        </div>
      </div>
      <div style="margin-top:10px; display:flex; gap:10px; flex-wrap:wrap">
        <button id="generateOutline" class="btn">T·∫°o d√†n √Ω 50 ch∆∞∆°ng</button>
        <button id="startBook" class="btn primary">B·∫Øt ƒë·∫ßu sinh & upload 50 ch∆∞∆°ng</button>
        <button id="cancelGen" class="btn">Hu·ª∑</button>
      </div>
      <div class="progress" style="margin-top:10px"><div class="bar" id="bookBar"></div></div>
      <div id="bookStatus" class="list" style="margin-top:10px"></div>
      <textarea id="outlineBox" placeholder="D√†n √Ω 50 ch∆∞∆°ng s·∫Ω hi·ªÉn th·ªã t·∫°i ƒë√¢y..."></textarea>
    </div>

    <!-- Th√™m card chi ti·∫øt sinh truy·ªán -->
    <div class="card" id="generation-details" style="display: none; margin-top: 16px;">
      <h3 style="margin:0 0 8px">Chi ti·∫øt sinh truy·ªán</h3>
      <div class="grid2">
        <div>
          <label>C·∫£m x√∫c ch√≠nh</label>
          <div id="current-emotion" class="pill">Ch∆∞a x√°c ƒë·ªãnh</div>
        </div>
        <div>
          <label>Th√†nh ph·∫ßn n·ªôi dung</label>
          <div id="content-components" class="pill">ƒêang t√≠nh to√°n...</div>
        </div>
      </div>
      <div class="progress" style="margin-top:10px">
        <div class="bar" id="detail-bar"></div>
      </div>
      <div id="generation-stats" class="status"></div>
    </div>
  </section>

  <!-- PAGE: TH√äM TRUY·ªÜN -->
  <section id="page-add" class="page">
    <div class="card">
      <h3 style="margin:0 0 8px">4) Th√™m truy·ªán</h3>
      <div class="grid2">
        <div>
          <h4 style="margin:6px 0">T·∫°o th∆∞ m·ª•c truy·ªán m·ªõi</h4>
          <label>T√™n truy·ªán</label>
          <input id="newStoryTitle" type="text" placeholder="Nh·∫≠p t√™n truy·ªán..." />
          <div style="margin-top:8px; display:flex; gap:10px; flex-wrap:wrap">
            <button id="createStoryFolder" class="btn primary">T·∫°o th∆∞ m·ª•c trong QuanLyTruyen</button>
          </div>
          <div id="createStoryResult" class="muted" style="margin-top:8px"></div>
        </div>
        <div>
          <h4 style="margin:6px 0">Ch·ªçn th∆∞ m·ª•c truy·ªán ƒë√£ c√≥</h4>
          <label>Danh s√°ch th∆∞ m·ª•c con (t·∫£i)</label>
          <button id="listSubfolders" class="btn">Li·ªát k√™</button>
          <select id="subfolders" size="8" style="margin-top:8px"></select>
          <div class="muted" style="margin-top:8px">Ch·ªçn ƒë·ªÉ d√πng l√†m n∆°i upload ch∆∞∆°ng.</div>
        </div>
      </div>
    </div>
  </section>

  <!-- PAGE: TI·∫æN TR√åNH -->
  <section id="page-progress" class="page">
    <div class="card">
      <h3 style="margin:0 0 8px">Ti·∫øn tr√¨nh & nh·∫≠t k√Ω</h3>
      <div id="log" class="list"></div>
    </div>
  </section>
</div>

<!-- Bottom navigation -->
<nav class="bottom-nav">
  <div class="tab active" data-page="page-data">üìÇ<div>D·ªØ li·ªáu</div></div>
  <div class="tab" data-page="page-write">‚úçÔ∏è<div>Vi·∫øt truy·ªán</div></div>
  <div class="tab" data-page="page-add">‚ûï<div>Th√™m truy·ªán</div></div>
  <div class="tab" data-page="page-progress">‚è±Ô∏è<div>Ti·∫øn tr√¨nh</div></div>
</nav>

<script>
/** ================= C·∫§U H√åNH GOOGLE API ================= */
const GAPI_CONFIG = {
  apiKey: "AIzaSyAbcWr0UPvC4YpsunE6uAa7E5pan9iys2o",
  discoveryDocs: ["https://www.googleapis.com/discovery/v1/apis/drive/v3/rest"],
};

/** ================== TI·ªÜN √çCH UI ================== */
const $ = (id) => document.getElementById(id);
const setStatus = (msg) => { $("status").textContent = msg || ""; };
const setAuthState = (txt) => { $("authState").innerHTML = txt; };
const setQLTState = (txt) => { $("qltState").innerHTML = txt; };
const setBar = (p, el='bar') => { $(el).style.width = Math.max(0, Math.min(100, p)) + "%"; };
const log = (t) => { const el=$("log"); el.textContent += "\n" + new Date().toLocaleTimeString()+" ‚Ä¢ "+ t; el.scrollTop = el.scrollHeight; };

// bottom nav
for (const tab of document.querySelectorAll('.tab')){
  tab.addEventListener('click', () => {
    document.querySelectorAll('.tab').forEach(x=>x.classList.remove('active'));
    tab.classList.add('active');
    const page = tab.dataset.page;
    document.querySelectorAll('.page').forEach(p=>p.classList.remove('active'));
    document.getElementById(page).classList.add('active');
  });
}

/** ================== TR·∫†NG TH√ÅI B·ªò NH·ªö ================== */
let signedIn = false;
let accessToken = null; // GIS token
let tokenClient = null; // GIS token client
let corpusTexts = []; // m·∫£ng chu·ªói txt
let totalBytes = 0;
let sentiment;        // ml5 sentiment
let useModel;         // TF.js Universal Sentence Encoder
let qltFolderId = null; // id th∆∞ m·ª•c QuanLyTruyen
let cancelFlag = false;
let activeStoryFolderId = null; // n∆°i upload ch∆∞∆°ng

/** ================= KH·ªûI T·∫†O GAPI + GIS (m·ªõi) ================= */
function gapiLoad() { return new Promise((resolve) => gapi.load("client", resolve)); }
async function initGapi(){
  await gapiLoad();
  await gapi.client.init({ apiKey: GAPI_CONFIG.apiKey, discoveryDocs: GAPI_CONFIG.discoveryDocs });
  if (accessToken) gapi.client.setToken({access_token: accessToken});
}

function initGIS(){
  tokenClient = google.accounts.oauth2.initTokenClient({
    client_id: "398509518475-7bjid324tkuuh9gv8b0g92lhsgv8nrl5.apps.googleusercontent.com",
    scope: "https://www.googleapis.com/auth/drive.readonly https://www.googleapis.com/auth/drive.file",
    callback: (tokenResponse) => {
      accessToken = tokenResponse.access_token;
      gapi.client.setToken({ access_token: accessToken });
      signedIn = true;
      setAuthState("‚úÖ ƒê√£ ƒëƒÉng nh·∫≠p");
      $("signin").style.display = "none";
      $("signout").style.display = "inline-block";
      ensureQLT();
    }
  });
}

window.addEventListener('load', async () => {
  await initGapi();
  const waitGIS = () => new Promise(r=>{
    const iv=setInterval(()=>{
      if (window.google && google.accounts && google.accounts.oauth2){ clearInterval(iv); r(); }
    }, 50);
  });
  await waitGIS();
  initGIS();
});

$("signin").onclick = () => { if (!tokenClient){ setStatus('GIS ch∆∞a s·∫µn s√†ng'); return; } tokenClient.requestAccessToken({ prompt: 'consent' }); };
$("signout").onclick = async () => {
  try{ if (accessToken && google.accounts && google.accounts.oauth2){ google.accounts.oauth2.revoke(accessToken, ()=>{}); } }catch(e){}
  accessToken = null; signedIn = false; gapi.client.setToken(null);
  setAuthState("Ch∆∞a ƒëƒÉng nh·∫≠p");
  $("signin").style.display = "inline-block"; $("signout").style.display = "none"; setStatus('ƒê√£ ƒëƒÉng xu·∫•t.');
};

/** ================== H√ÄM GOOGLE DRIVE ================== */
async function findFolderIdByName(name, parentId=null){
  let q = `name='${name.replace(/'/g, "\\'")}' and mimeType='application/vnd.google-apps.folder' and trashed=false`;
  if (parentId) q += ` and '${parentId}' in parents`;
  const res = await gapi.client.drive.files.list({ q, fields: "files(id,name,createdTime)", orderBy: "createdTime desc", pageSize: 50 });
  const files = res.result.files || [];
  return files.length ? files[0].id : null;
}
async function createFolder(name, parentId){
  const metadata = { name, mimeType: 'application/vnd.google-apps.folder', parents: parentId ? [parentId] : undefined };
  const res = await gapi.client.drive.files.create({ resource: metadata, fields: 'id,name' });
  return res.result.id;
}
async function ensureQLT(){
  setStatus("ƒêang ki·ªÉm tra th∆∞ m·ª•c QuanLyTruyen...");
  qltFolderId = await findFolderIdByName('QuanLyTruyen');
  if (!qltFolderId){ qltFolderId = await createFolder('QuanLyTruyen', null); }
  setQLTState("üìÅ ID: " + qltFolderId);
}

async function listAllTxtRecursive(folderId, maxFiles = 200, collected = [], pageToken = null) {
  // l·∫•y file txt trong folder hi·ªán t·∫°i
  let res = await gapi.client.drive.files.list({
    q: `'${folderId}' in parents and mimeType='text/plain' and trashed=false`,
    fields: 'nextPageToken, files(id,name,size,modifiedTime)',
    pageSize: 100,
    pageToken
  });
  collected.push(...(res.result.files || []));
  if (collected.length >= maxFiles) return collected.slice(0, maxFiles);

  // l·∫•y subfolders
  let subRes = await gapi.client.drive.files.list({
    q: `'${folderId}' in parents and mimeType='application/vnd.google-apps.folder' and trashed=false`,
    fields: 'files(id,name)',
    orderBy: 'name'
  });
  for (const sub of subRes.result.files || []) {
    if (collected.length >= maxFiles) break;
    await listAllTxtRecursive(sub.id, maxFiles, collected);
  }

  return collected.slice(0, maxFiles);
}

async function listSubfolders(parentId){
  const res = await gapi.client.drive.files.list({
    q: `'${parentId}' in parents and mimeType='application/vnd.google-apps.folder' and trashed=false`,
    fields: 'files(id,name)',
    orderBy: 'name'
  });
  return res.result.files || [];
}

function getAccessToken(){
  if (accessToken) return accessToken;
  const tokenObj = gapi.client.getToken();
  return tokenObj && (tokenObj.access_token || tokenObj.accessToken);
}

async function uploadMultipart({name, mimeType, content, parents, fileId=null}){
  const boundary = '-------314159265358979323846';
  const delimiter = "\r\n--" + boundary + "\r\n";
  const closeDelim = "\r\n--" + boundary + "--";
  const metadata = { name, mimeType, parents };
  const base64Data = btoa(unescape(encodeURIComponent(content)));
  const body =
    delimiter + 'Content-Type: application/json; charset=UTF-8\r\n\r\n' + JSON.stringify(metadata) +
    delimiter + 'Content-Type: ' + mimeType + '\r\n' + 'Content-Transfer-Encoding: base64\r\n\r\n' + base64Data + closeDelim;

  const token = getAccessToken();
  const method = fileId ? 'PATCH' : 'POST';
  const url = fileId
    ? `https://www.googleapis.com/upload/drive/v3/files/${fileId}?uploadType=multipart`
    : 'https://www.googleapis.com/upload/drive/v3/files?uploadType=multipart';

  const res = await fetch(url, { method, headers: { 'Authorization': 'Bearer ' + token, 'Content-Type': 'multipart/related; boundary=' + boundary }, body });
  if (!res.ok){ throw new Error('Upload th·∫•t b·∫°i ' + res.status + ' ' + await res.text()); }
  return await res.json();
}

async function findChildByName(parentId, name){
  const res = await gapi.client.drive.files.list({ q: `'${parentId}' in parents and name='${name.replace(/'/g, "\\'")}' and trashed=false`, fields: 'files(id,name,mimeType)' });
  const files = res.result.files || [];
  return files.length ? files[0] : null;
}

async function upsertTextFile(parentId, name, content){
  const existing = await findChildByName(parentId, name);
  const ret = await uploadMultipart({ name, mimeType:'text/plain', content, parents:[parentId], fileId: existing?.id || null });
  return ret.id;
}
async function upsertJsonFile(parentId, name, obj){
  const existing = await findChildByName(parentId, name);
  const ret = await uploadMultipart({ name, mimeType:'application/json', content: JSON.stringify(obj, null, 2), parents:[parentId], fileId: existing?.id || null });
  return ret.id;
}

/** ================== N·∫†P D·ªÆ LI·ªÜU ================== */
$("clearAll").onclick = ()=>{ corpusTexts=[]; totalBytes=0; $("corpusPreview").value=''; $("filesInfo").textContent=''; setBar(0); setStatus('ƒê√£ xo√° d·ªØ li·ªáu RAM.'); };
$("loadTexts").onclick = loadAllTextsFromDriveFolder;
$("saveCache").onclick = saveCacheToDrive;
$("loadCache").onclick = loadCacheFromDrive;

async function loadAllTextsFromDriveFolder(){
  if (!signedIn){ setStatus('Vui l√≤ng ƒëƒÉng nh·∫≠p.'); return; }
  await ensureQLT();
  setStatus("ƒêang li·ªát k√™ .txt..."); setBar(5);
  const maxFiles = parseInt($("maxFiles").value || '200', 10);
  const maxMB = parseInt($("maxMB").value || '50', 10);
  const byteLimit = maxMB * 1024 * 1024;
  const sub = $("subFolder").value.trim();
  let folderId = qltFolderId;
  if (sub){ folderId = await findFolderIdByName(sub, qltFolderId) || await createFolder(sub, qltFolderId); }

  const fileList = await listAllTxtRecursive(folderId, maxFiles);
  if (!fileList.length){ setStatus('Kh√¥ng c√≥ .txt trong th∆∞ m·ª•c.'); setBar(0); return; }

  corpusTexts=[]; totalBytes=0; $("corpusPreview").value=''; $("filesInfo").innerHTML='';
  let loaded=0;
  for (const f of fileList){
    if (totalBytes >= byteLimit) break;
    try{
      const txt = await downloadTxtFile(f.id);
      const bytes = new Blob([txt]).size;
      if (totalBytes + bytes > byteLimit){ setStatus(`ƒê·∫°t gi·ªõi h·∫°n ~${maxMB}MB, d·ª´ng.`); break; }
      corpusTexts.push(txt); totalBytes += bytes; loaded++;
      const pct = Math.round((loaded / fileList.length) * 100);
      setBar(Math.min(97, 5 + pct * 0.9));
    }catch(e){ console.error(e); log('L·ªói t·∫£i: '+f.name); }
  }

  const preview = corpusTexts.slice(0,2).map(t=>t.substring(0,500)).join("\n---\n");
  $("corpusPreview").value = preview;
  $("filesInfo").innerHTML = `ƒê√£ n·∫°p <b>${loaded}</b> / ${fileList.length} file (~${(totalBytes/1024/1024).toFixed(2)} MB).`;
  setStatus('Ho√†n t·∫•t n·∫°p.'); setBar(100);
}

async function downloadTxtFile(fileId){
  const token = getAccessToken();
  const res = await fetch(`https://www.googleapis.com/drive/v3/files/${fileId}?alt=media`, { headers:{ Authorization:'Bearer '+token } });
  if (!res.ok) throw new Error('T·∫£i file th·∫•t b·∫°i '+res.status);
  return await res.text();
}

/** ================== TI·∫æNG VI·ªÜT: tokenize + stopwords ================== */
const VI_STOPWORDS = new Set(['v√†','l√†','c·ªßa','nh·ªØng','c√°c','m·ªôt','nh∆∞','ƒë√£','ƒëang','s·∫Ω','r·∫±ng','th√¨','l·∫°i','ƒë∆∞·ª£c','b·ªã','trong','tr√™n','d∆∞·ªõi','t·ª´','v·ªõi','cho','ƒë·∫øn','khi','n√†y','kia','ƒë√≥','·∫•y','nhi·ªÅu','√≠t','r·∫•t','h∆°n','c≈©ng','nh∆∞ng','n·∫øu','v·∫´n','ƒë·ªÅu','ƒëi','v·ªÅ','t·∫°i','qua','sau','tr∆∞·ªõc','gi·ªØa','hay','ho·∫∑c','v√¨','n√™n','do','m√†','n∆°i','ai','g√¨','ƒë√¢u','n√†o','ƒë√¢y','t√¥i','ta','m√¨nh','ch√∫ng','anh','em','ch·ªã','c√¥','ch√∫','b√°c','√¥ng','b√†','n√≥','h·ªç','c·∫≠u','v·∫≠y','th·∫ø','∆°i','√†','·ª´','·ªù','∆°','h·∫£','h·ª≠','nh·ªâ','nh√©','c·∫£','b·ªüi','ƒë·∫øn','kho·∫£ng','ngo√†i','c√πng','t·ª´ng','m·ªói','m·ªçi','r·ªìi','n·ªØa','th√™m','b·ªõt','g·∫ßn','xa','h·∫øt','ƒë·ªß']);
function tokenizeVI(text){ const tokens = (text||'').toLowerCase().match(/[\p{L}\p{M}\d']+/gu) || []; return tokens.filter(w=>w && !VI_STOPWORDS.has(w)); }
function splitSentencesVI(text){ return (text||'').split(/(?<=[\.!?‚Ä¶])\s+/).filter(s=>s.trim().length>0); }

/** ================== PH√ÇN T√çCH (TF.js + ml5) ================== */
$("analyze").onclick = analyzeCorpus;
$("exportStats").onclick = ()=>{ if (!window._lastStats){ setStatus('Ch∆∞a c√≥ th·ªëng k√™.'); return; } const data = window._lastStats; const blob = new Blob([JSON.stringify(data,null,2)], {type:'application/json'}); const url = URL.createObjectURL(blob); const a = document.createElement('a'); a.href=url; a.download='stats.json'; a.click(); URL.revokeObjectURL(url); };

async function ensureSentiment(){ if (!sentiment){ sentiment = ml5.sentiment('movieReviews'); } }
async function ensureUSE(){ if (!useModel){ useModel = await use.load(); } }

function topWords(tokens, n=40){ const f=new Map(); for(const w of tokens) f.set(w,(f.get(w)||0)+1); return [...f.entries()].sort((a,b)=>b[1]-a[1]).slice(0,n); }
function ngrams(tokens, n){ const m=new Map(); for(let i=0;i<=tokens.length-n;i++){ const key=tokens.slice(i,i+n).join(' '); const next=tokens[i+n]; if (!next) continue; if(!m.has(key)) m.set(key,[]); m.get(key).push(next);} return m; }

async function analyzeCorpus(){
  if (!corpusTexts.length){ setStatus('Ch∆∞a c√≥ d·ªØ li·ªáu.'); return; }
  await ensureSentiment();
  const joined = corpusTexts.join('\n');
  const sentences = splitSentencesVI(joined);
  const tokens = tokenizeVI(joined);
  const uniq = new Set(tokens).size;
  const sampleSize = Math.min(200, sentences.length);
  let sum=0; for(let i=0;i<sampleSize;i++){ const s = sentences[Math.floor(Math.random()*sentences.length)]; try{ sum += sentiment.predict(s).score||0; }catch{} }
  const avgSent = sampleSize? (sum/sampleSize) : 0;
  const order = 3; const model = ngrams(tokens, order);
  const vocabSize = new Set(tokens).size;
  const tops = topWords(tokens, 40).map(([w,c])=>`${w.padEnd(16,' ')} : ${c}`).join('\n');
  const stats = { chars: joined.length, words: tokens.length, uniqueWords: uniq, vocabSize, avgSentiment: +avgSent.toFixed(4), topWords: [...topWords(tokens, 100)], order, modelKeys: model.size };
  window._lastStats = stats; window._lastTokens = tokens; window._lastModel = model;
  $("analysis").textContent =
`T·ªïng k√Ω t·ª±      : ${joined.length.toLocaleString()}
T·ªïng t·ª´          : ${tokens.length.toLocaleString()}
S·ªë t·ª´ kh√°c nhau  : ${uniq.toLocaleString()}
K√≠ch th∆∞·ªõc vocab : ${vocabSize.toLocaleString()}
ƒêi·ªÉm c·∫£m x√∫c TB  : ${avgSent.toFixed(3)} (ml5: movieReviews)
S·ªë kh√≥a n-gram   : ${model.size.toLocaleString()}
Top 40 t·ª´ ph·ªï bi·∫øn:\n${tops}`;
  setStatus('ƒê√£ ph√¢n t√≠ch.'); log('Ph√¢n t√≠ch xong.');
}

/** ================== CACHE PH√ÇN T√çCH (Drive) ================== */
async function saveCacheToDrive(){
  if (!qltFolderId){ await ensureQLT(); }
  if (!window._lastTokens || !window._lastStats){ setStatus('Ch∆∞a ph√¢n t√≠ch ƒë·ªÉ l∆∞u.'); return; }
  const cache = { when: new Date().toISOString(), stats: window._lastStats };
  const vocab = { tokens: window._lastTokens.slice(0, 500000) };
  await upsertJsonFile(qltFolderId, 'QLT_analysis.json', cache);
  await upsertJsonFile(qltFolderId, 'QLT_vocab.json', vocab);
  setStatus('ƒê√£ l∆∞u cache ph√¢n t√≠ch l√™n Drive.'); log('L∆∞u cache th√†nh c√¥ng.');
}
async function loadCacheFromDrive(){
  if (!qltFolderId){ await ensureQLT(); }
  async function downloadJsonIfExists(name){
    const f = await findChildByName(qltFolderId, name);
    if (!f){ return null; }
    const token = getAccessToken();
    const res = await fetch(`https://www.googleapis.com/drive/v3/files/${f.id}?alt=media`, { headers:{ Authorization:'Bearer '+token } });
    if (!res.ok) return null; return await res.json();
  }
  const cache = await downloadJsonIfExists('QLT_analysis.json');
  const vocab = await downloadJsonIfExists('QLT_vocab.json');
  if (cache && vocab){
    window._lastStats = cache.stats;
    window._lastTokens = vocab.tokens;
    $("analysis").textContent = JSON.stringify(cache, null, 2);
    window._lastModel = ngrams(window._lastTokens, cache.stats.order || 3);
    setStatus('ƒê√£ t·∫£i cache ph√¢n t√≠ch.'); log('T·∫£i cache th√†nh c√¥ng.');
  } else { setStatus('Kh√¥ng t√¨m th·∫•y cache.'); }
}

/** ================== L·ªöP SINH TRUY·ªÜN N√ÇNG CAO ================== */
class StoryGenerator {
  constructor(model, order) {
    this.model = model;
    this.order = order;
    this.dialoguePatterns = [
      "{char} n√≥i: \"{dialogue}\"",
      "\"{dialogue}\", {char} n√≥i",
      "{char} nh√¨n t√¥i ch·∫±m ch·∫±m: \"{dialogue}\"",
      "\"{dialogue}\", {char} th·ªü d√†i",
      "T√¥i nghe th·∫•y {char} n√≥i: \"{dialogue}\"",
      "{char} c∆∞·ªùi nh·∫π: \"{dialogue}\"",
      "√Ånh m·∫Øt {char} l·∫•p l√°nh: \"{dialogue}\"",
      "Gi·ªçng {char} run run: \"{dialogue}\""
    ];
    this.characters = ["Lan", "H√πng", "Minh", "An", "B√°c sƒ©", "Gi√°o s∆∞", "B·∫°n t√¥i", "Ng∆∞·ªùi l·∫°", "M·∫π", "B·ªë", "Ch·ªã g√°i", "Em trai"];
    this.emotions = ["vui", "bu·ªìn", "t·ª©c gi·∫≠n", "s·ª£ h√£i", "ng·∫°c nhi√™n", "b√¨nh tƒ©nh", "x√∫c ƒë·ªông", "ph·∫•n kh√≠ch", "th·∫•t v·ªçng", "hy v·ªçng"];
    this.locations = ["trong c√¥ng vi√™n", "t·∫°i qu√°n c√† ph√™", "trong ph√≤ng l√†m vi·ªác", "tr√™n ƒë∆∞·ªùng ph·ªë", "·ªü b·ªánh vi·ªán", "t·∫°i nh√† t√¥i", "trong th∆∞ vi·ªán", "tr√™n xe bu√Ωt", "·ªü s√¢n bay", "trong r·ª´ng", "b√™n b·ªù s√¥ng", "tr√™n n√∫i"];
    this.sceneElements = {
      "weather": ["tr·ªùi n·∫Øng ƒë·∫πp", "m∆∞a r∆°i l·∫•t ph·∫•t", "gi√≥ th·ªïi nh·∫π", "tr·ªùi √¢m u", "n·∫Øng g·∫Øt", "m∆∞a nh∆∞ tr√∫t n∆∞·ªõc", "s∆∞∆°ng m√π d√†y ƒë·∫∑c", "tr·ªùi se l·∫°nh"],
      "time": ["s√°ng s·ªõm", "bu·ªïi tr∆∞a", "chi·ªÅu t√†", "ƒë√™m khuya", "r·∫°ng s√°ng", "ho√†ng h√¥n", "gi·ªØa tr∆∞a", "n·ª≠a ƒë√™m"],
      "sounds": ["ti·∫øng chim h√≥t", "ti·∫øng c√≤i xe", "ti·∫øng m∆∞a r∆°i", "ti·∫øng gi√≥ r√≠t", "ti·∫øng n√≥i chuy·ªán xa xa", "ti·∫øng nh·∫°c du d∆∞∆°ng", "ti·∫øng b∆∞·ªõc ch√¢n", "ti·∫øng l√° x√†o x·∫°c"]
    };
  }

  // T·∫°o ƒëo·∫°n h·ªôi tho·∫°i
  generateDialogue() {
    const pattern = this.dialoguePatterns[Math.floor(Math.random() * this.dialoguePatterns.length)];
    const char = this.characters[Math.floor(Math.random() * this.characters.length)];
    const dialogue = this.generateSentence(5 + Math.floor(Math.random() * 10));
    
    return pattern
      .replace("{char}", char)
      .replace("{dialogue}", dialogue);
  }

  // T·∫°o c√¢u v·ªõi c·∫£m x√∫c
  generateEmotionalSentence(emotion) {
    const emotionalPhrases = {
      "vui": ["vui m·ª´ng kh√¥n xi·∫øt", "c∆∞·ªùi r·∫°ng r·ª°", "tr√†n ƒë·∫ßy h·∫°nh ph√∫c", "l√≤ng ph∆°i ph·ªõi", "m·∫∑t r·∫°ng r·ª° ni·ªÅm vui"],
      "bu·ªìn": ["bu·ªìn b√£ v√¥ c√πng", "l√≤ng trƒ©u n·∫∑ng", "n∆∞·ªõc m·∫Øt l∆∞ng tr√≤ng", "t√¢m tr·∫°ng u √°m", "tr√°i tim tan n√°t"],
      "t·ª©c gi·∫≠n": ["t·ª©c gi·∫≠n v√¥ c√πng", "m·∫∑t ƒë·ªè b·ª´ng", "n·∫Øm ch·∫∑t tay", "m√°u s√¥i l√™n", "gi·∫≠n d·ªØ ƒë·∫øn run ng∆∞·ªùi"],
      "s·ª£ h√£i": ["run s·ª£", "tim ƒë·∫≠p lo·∫°n nh·ªãp", "to√°t m·ªì h√¥i l·∫°nh", "s·ª£ h√£i t·ªôt ƒë·ªô", "ch√¢n tay b·ªßn r·ªßn"],
      "ng·∫°c nhi√™n": ["kinh ng·∫°c", "m·∫Øt m·ªü to", "kh√¥ng tin v√†o m·∫Øt m√¨nh", "s·ª≠ng s·ªët", "h√° h·ªëc m·ªìm"],
      "b√¨nh tƒ©nh": ["b√¨nh tƒ©nh l·∫°i", "th·ªü s√¢u", "l·∫•y l·∫°i t·ª± ch·ªß", "tƒ©nh t√¢m", "gi·ªØ v·ªØng tinh th·∫ßn"],
      "x√∫c ƒë·ªông": ["x√∫c ƒë·ªông m·∫°nh", "ngh·∫πn ng√†o", "l√≤ng xao xuy·∫øn", "r∆°i n∆∞·ªõc m·∫Øt", "c·∫£m ƒë·ªông s√¢u s·∫Øc"],
      "ph·∫•n kh√≠ch": ["ph·∫•n kh√≠ch t·ªôt ƒë·ªô", "h√†o h·ª©ng v√¥ c√πng", "reo l√™n v√¨ vui s∆∞·ªõng", "nh·∫£y c·∫´ng l√™n", "tr√†n ƒë·∫ßy nƒÉng l∆∞·ª£ng"],
      "th·∫•t v·ªçng": ["th·∫•t v·ªçng tr√†n tr·ªÅ", "nu·ªëi ti·∫øc kh√¥n ngu√¥i", "ch√°n n·∫£n", "tuy·ªát v·ªçng", "m·∫∑t ·ªß r≈©"],
      "hy v·ªçng": ["tr√†n ƒë·∫ßy hy v·ªçng", "l·∫°c quan", "tin v√†o t∆∞∆°ng lai", "·∫•p ·ªß ∆∞·ªõc m∆°", "v·ªØng ni·ªÅm tin"]
    };
    
    const phrase = emotionalPhrases[emotion] 
      ? emotionalPhrases[emotion][Math.floor(Math.random() * emotionalPhrases[emotion].length)]
      : emotionalPhrases["b√¨nh tƒ©nh"][0];
    
    return `T√¥i ${phrase}, ${this.generateSentence(5 + Math.floor(Math.random() * 8))}`;
  }

  // T·∫°o m√¥ t·∫£ b·ªëi c·∫£nh
  generateSceneDescription() {
    const location = this.locations[Math.floor(Math.random() * this.locations.length)];
    const time = this.sceneElements.time[Math.floor(Math.random() * this.sceneElements.time.length)];
    const weather = this.sceneElements.weather[Math.floor(Math.random() * this.sceneElements.weather.length)];
    const sound = this.sceneElements.sounds[Math.floor(Math.random() * this.sceneElements.sounds.length)];
    
    return `V√†o m·ªôt bu·ªïi ${time} ${location}, ${weather}. ${sound}. ${this.generateSentence(8 + Math.floor(Math.random() * 6))}`;
  }

  // T·∫°o c√¢u t·ª´ model
  generateSentence(length) {
    const keys = [...this.model.keys()];
    if (keys.length === 0) return "T√¥i kh√¥ng bi·∫øt ph·∫£i n√≥i g√¨.";
    
    let key = keys[Math.floor(Math.random() * keys.length)];
    let output = key.split(' ');
    
    for (let i = 0; i < length; i++) {
      const nextWords = this.model.get(key);
      if (!nextWords || nextWords.length === 0) {
        // N·∫øu kh√¥ng t√¨m th·∫•y t·ª´ ti·∫øp theo, ch·ªçn key ng·∫´u nhi√™n kh√°c
        key = keys[Math.floor(Math.random() * keys.length)];
        output = output.concat(key.split(' '));
        continue;
      }
      
      const nextWord = nextWords[Math.floor(Math.random() * nextWords.length)];
      output.push(nextWord);
      
      // C·∫≠p nh·∫≠t key
      const keyParts = key.split(' ');
      keyParts.shift();
      keyParts.push(nextWord);
      key = keyParts.join(' ');
    }
    
    // Vi·∫øt hoa ch·ªØ c√°i ƒë·∫ßu v√† th√™m d·∫•u ch·∫•m
    let sentence = output.join(' ');
    sentence = sentence.charAt(0).toUpperCase() + sentence.slice(1);
    
    if (!/[.!?]$/.test(sentence)) {
      sentence += '.';
    }
    
    return sentence;
  }

  // T·∫°o ƒëo·∫°n vƒÉn phong ph√∫
  generateRichParagraph(targetWords, emotion) {
    const components = [];
    const targetLength = targetWords;
    let currentLength = 0;
    
    // Th√™m m√¥ t·∫£ b·ªëi c·∫£nh (20%)
    if (Math.random() < 0.8) {
      const scene = this.generateSceneDescription();
      components.push(scene);
      currentLength += scene.split(/\s+/).length;
    }
    
    // Th√™m c√¢u c·∫£m x√∫c (30%)
    const emotionalSentence = this.generateEmotionalSentence(emotion);
    components.push(emotionalSentence);
    currentLength += emotionalSentence.split(/\s+/).length;
    
    // Th√™m ƒëo·∫°n h·ªôi tho·∫°i (30%)
    if (Math.random() < 0.7 && currentLength < targetLength * 0.7) {
      const dialogue = this.generateDialogue();
      components.push(dialogue);
      currentLength += dialogue.split(/\s+/).length;
    }
    
    // Th√™m n·ªôi dung t·ª´ Markov ƒë·ªÉ ƒë·∫°t ƒë·ªô d√†i y√™u c·∫ßu
    const remainingWords = targetWords - currentLength;
    if (remainingWords > 3) {
      const markovContent = this.generateSentence(remainingWords);
      components.push(markovContent);
    }
    
    return components.join(" ");
  }
}

/** ================== VI·∫æT TRUY·ªÜN 50 CH∆Ø∆†NG ================== */
$("generateOutline").onclick = suggestOutline;
$("startBook").onclick = startGeneratingBook;
$("cancelGen").onclick = ()=>{ cancelFlag = true; setStatus('ƒê√£ g·ª≠i y√™u c·∫ßu hu·ª∑.'); };

function pick(arr){ return arr[Math.floor(Math.random()*arr.length)]; }
function buildWordModel(tokens, order){
  const m = new Map();
  for(let i=0;i<=tokens.length - order; i++){
    const key = tokens.slice(i,i+order).join(' ');
    const next = tokens[i+order];
    if (!next) continue;
    if (!m.has(key)) m.set(key, []);
    m.get(key).push(next);
  }
  return m;
}
async function ensureModel(){
  if (!window._lastTokens){
    if (!corpusTexts.length){ setStatus('Ch∆∞a c√≥ d·ªØ li·ªáu ƒë·ªÉ h·ªçc.'); throw new Error('no data'); }
    const tokens = tokenizeVI(corpusTexts.join('\n'));
    window._lastTokens = tokens;
  }
  if (!window._lastModel){
    const order = parseInt($("order").value || '3', 10);
    window._lastModel = buildWordModel(window._lastTokens, order);
  }
  await ensureSentiment();
  await ensureUSE();
}

function proposeTitleFromTokens(tokens){
  const freq = new Map();
  for(const w of tokens) freq.set(w,(freq.get(w)||0)+1);
  const weighted = [...freq.entries()].filter(([w])=>w.length>2 && !VI_STOPWORDS.has(w));
  weighted.sort((a,b)=>b[1]-a[1]);
  const pool = weighted.slice(0,120).map(([w,c])=>({w,score:c}));
  const pickN = (n)=>{ const arr=[]; for(let i=0;i<n;i++){ const r = pool[Math.floor(Math.random()*pool.length)]; if(!r) break; arr.push(r.w); } return arr; };
  const form1 = ["h√†nh tr√¨nh", "b√≠ ·∫©n", "k√Ω ·ª©c", "b√≥ng ƒë√™m", "m√πa gi√≥", "d·∫•u ch√¢n", "l·∫±n ranh", "m·∫∑t tr·ªùi", "ƒë√°m m√¢y", "c∆°n m∆∞a"];
  let cand = pick(form1) + ' ' + pickN(2).join(' ');
  cand = cand.replace(/\b\w/g, m=>m.toUpperCase());
  return cand;
}

async function suggestOutline(){
  await ensureModel();
  const title = ($("titleInput").value.trim() || proposeTitleFromTokens(window._lastTokens)).replace(/\s+/g,' ').trim();
  const chapters = [];
  const arcs = ['Kh·ªüi ƒë·∫ßu & g·ªçi m·ªùi cu·ªôc phi√™u l∆∞u','B∆∞·ªõc ch√¢n ƒë·∫ßu ti√™n & m√¢u thu·∫´n nhen nh√≥m','L·ªùi h·ª©a v√† b√≠ m·∫≠t','G·∫∑p g·ª° ƒë·ªìng minh','Th·ª≠ th√°ch nh·ªè, h·∫≠u qu·∫£ l·ªõn','D·∫•u v·∫øt qu√° kh·ª©','ƒê·ªëi ƒë·∫ßu l·∫ßn ƒë·∫ßu','V√πng t·ªëi c·ªßa t√¥i','L·ª±a ch·ªçn kh√≥ khƒÉn','M·∫•t m√°t th·ª© nh·∫•t','Manh m·ªëi l·ªô di·ªán','N√¢ng t·∫ßm xung ƒë·ªôt','C√°nh c·ª≠a kh√©p h·ªù','B∆∞·ªõc ngo·∫∑t','L·ªùi n√≥i d·ªëi','Ch·∫°y tr·ªën','T√°i ng·ªô','H·ªçc c√°ch tin','ƒê·ªïi vai','B∆∞·ªõc v√†o t√¢m b√£o','ƒê√™m tr∆∞·ªõc b√£o','S·ª± th·∫≠t th·ª© nh·∫•t','V·ª° v·ª•n','Nh·∫∑t t·ª´ng m·∫£nh','Th·∫Øp l·ª≠a','√Çm m∆∞u l·ªô m·∫∑t','C√°i b·∫´y','Hi sinh','S·ª•p ƒë·ªï','V·ª±c d·∫≠y','ƒê·ªëi m·∫∑t cu·ªëi','C√°i gi√° ph·∫£i tr·∫£','M·ªü kho√° b√≠ ·∫©n','√Ånh s√°ng r·∫°ng ƒë√¥ng','V·∫øt s·∫πo c√≤n l·∫°i','Tha th·ª©','Tr·ªü v·ªÅ','C√°nh c·ª≠a m·ªõi','Ch·ªçn con ƒë∆∞·ªùng','L·ªùi h·ª©a gi·ªØ l·∫•y','Vi·∫øt ti·∫øp','M√πa m∆∞a n·ªØa','B√¨nh y√™n mong manh','D·∫•u ch·∫•m h·∫øt','Ngo·∫°i truy·ªán 1','Ngo·∫°i truy·ªán 2','Ngo·∫°i truy·ªán 3','Ngo·∫°i truy·ªán 4','Ngo·∫°i truy·ªán 5','Kh√©p l·∫°i & m·ªü ra'];
  for(let i=1;i<=50;i++){ const arc = arcs[i-1] || `Ch∆∞∆°ng ${i}`; chapters.push({ index:i, name: arc }); }
  const outline = { title, chapters };
  $("outlineBox").value = JSON.stringify(outline, null, 2);
  setStatus('ƒê√£ t·∫°o d√†n √Ω 50 ch∆∞∆°ng.');
}

// H√†m t√≠nh to√°n cung c·∫£m x√∫c theo v·ªã tr√≠ ch∆∞∆°ng
function calculateEmotionalArc(chapterIndex, totalChapters, baseSentiment) {
  const progression = chapterIndex / totalChapters;
  let primaryEmotion, target;
  
  if (progression < 0.25) {
    // Kh·ªüi ƒë·∫ßu: c·∫£m x√∫c trung l·∫≠p ho·∫∑c t√≠ch c·ª±c nh·∫π
    primaryEmotion = "b√¨nh tƒ©nh";
    target = baseSentiment + (Math.random() * 0.2 - 0.1);
  } else if (progression < 0.5) {
    // Xung ƒë·ªôt tƒÉng: c·∫£m x√∫c ti√™u c·ª±c
    primaryEmotion = ["t·ª©c gi·∫≠n", "s·ª£ h√£i", "bu·ªìn"][Math.floor(Math.random() * 3)];
    target = baseSentiment - 0.3 - (Math.random() * 0.2);
  } else if (progression < 0.75) {
    // Cao tr√†o: c·∫£m x√∫c m·∫°nh
    primaryEmotion = ["t·ª©c gi·∫≠n", "s·ª£ h√£i", "ng·∫°c nhi√™n"][Math.floor(Math.random() * 3)];
    target = baseSentiment - 0.4 - (Math.random() * 0.2);
  } else {
    // Gi·∫£i quy·∫øt: c·∫£m x√∫c t√≠ch c·ª±c d·∫ßn
    primaryEmotion = ["vui", "x√∫c ƒë·ªông", "b√¨nh tƒ©nh"][Math.floor(Math.random() * 3)];
    target = baseSentiment + 0.2 + (Math.random() * 0.2);
  }
  
  return { primaryEmotion, target: Math.max(-1, Math.min(1, target)) };
}

// H√†m t√≠nh ƒëi·ªÉm ƒëa d·∫°ng cho n·ªôi dung
function calculateDiversityBonus(text) {
  let bonus = 0;
  
  // Ki·ªÉm tra c√≥ h·ªôi tho·∫°i kh√¥ng (d·∫•u ngo·∫∑c k√©p)
  if (text.includes('"')) bonus += 0.3;
  
  // Ki·ªÉm tra c√≥ d·∫•u c·∫£m x√∫c kh√¥ng
  if (text.includes('!') || text.includes('?')) bonus += 0.2;
  
  // Ki·ªÉm tra c√≥ t·ª´ ch·ªâ c·∫£m x√∫c
  const emotionWords = ["vui", "bu·ªìn", "t·ª©c", "gi·∫≠n", "s·ª£", "ng·∫°c nhi√™n", "x√∫c ƒë·ªông", "c∆∞·ªùi", "kh√≥c"];
  if (emotionWords.some(word => text.includes(word))) bonus += 0.2;
  
  // Ki·ªÉm tra c√≥ t·ª´ ch·ªâ ƒë·ªãa ƒëi·ªÉm
  const locationWords = ["t·∫°i", "trong", "tr√™n", "·ªü", "c√¥ng vi√™n", "qu√°n", "ph√≤ng", "nh√†", "ƒë∆∞·ªùng"];
  if (locationWords.some(word => text.includes(word))) bonus += 0.2;
  
  // Ki·ªÉm tra c√≥ t·ª´ ch·ªâ th·ªùi gian
  const timeWords = ["s√°ng", "tr∆∞a", "chi·ªÅu", "t·ªëi", "ƒë√™m", "ng√†y", "gi·ªù", "ph√∫t"];
  if (timeWords.some(word => text.includes(word))) bonus += 0.1;
  
  return Math.min(1, bonus);
}

function truncateToWords(text, targetWords){
  const tokens = text.split(/\s+/);
  if (tokens.length <= targetWords) return text;
  // c·∫Øt ƒë·∫øn d·∫•u c√¢u g·∫ßn nh·∫•t sau target
  let idx = targetWords;
  for (let i=targetWords; i<Math.min(tokens.length, targetWords+200); i++){
    if (/[.!?‚Ä¶]$/.test(tokens[i])){ idx = i+1; break; }
  }
  return tokens.slice(0, idx).join(' ');
}

async function generateChapter({model, order, wordsTarget, seed, targetSent=0.1, chapterIndex, totalChapters}){
  await ensureSentiment();
  await ensureUSE();

  const storyGenerator = new StoryGenerator(model, order);
  const seedWords = seed ? tokenizeVI(seed) : null;
  
  // X√°c ƒë·ªãnh c·∫£m x√∫c ch√≠nh d·ª±a tr√™n v·ªã tr√≠ ch∆∞∆°ng trong c·ªët truy·ªán
  const emotionalArc = calculateEmotionalArc(chapterIndex, totalChapters, targetSent);
  
  // Hi·ªÉn th·ªã th√¥ng tin chi ti·∫øt
  $("generation-details").style.display = "block";
  $("#current-emotion").textContent = emotionalArc.primaryEmotion;
  $("#content-components").textContent = "ƒêang sinh...";
  setBar(10, "detail-bar");
  
  const themeText = seed || "T√¥i k·ªÉ chuy·ªán ƒë·ªùi m√¨nh v·ªõi nh·ªØng ng√£ r·∫Ω gia ƒë√¨nh, m√¢u thu·∫´n, v√† l·ª±a ch·ªçn.";
  const themeEmb = await useModel.embed([themeText]);
  const themeVec = themeEmb;

  const candidates = [];
  const K = 5; // TƒÉng s·ªë ·ª©ng vi√™n ƒë·ªÉ l·ª±a ch·ªçn t·ªët h∆°n
  
  for (let i = 0; i < K; i++) {
    // C·∫≠p nh·∫≠t ti·∫øn tr√¨nh
    setBar(10 + (i/K)*40, "detail-bar");
    $("#generation-stats").textContent = `ƒêang t·∫°o ·ª©ng vi√™n ${i+1}/${K}...`;
    
    // T·∫°o n·ªôi dung phong ph√∫ v·ªõi c√°c th√†nh ph·∫ßn m·ªõi
    const richContent = storyGenerator.generateRichParagraph(
      Math.round(wordsTarget * 1.15), 
      emotionalArc.primaryEmotion
    );
    
    const chopped = truncateToWords(richContent, Math.round(wordsTarget * 1.05));
    const sentScore = await scoreBySentiment(chopped, emotionalArc.target);
    const useScore = await scoreByUSE(chopped, themeVec);
    const len = chopped.split(/\s+/).length;
    const lenPenalty = Math.abs(len - wordsTarget) / wordsTarget;
    
    const sentimentFitness = 1 - Math.min(1, sentScore.dist);
    const useFitness = Math.max(0, Math.min(1, (useScore.sim + 1) / 2));
    const lengthFitness = 1 - Math.min(1, lenPenalty);
    
    // Th√™m ƒëi·ªÉm cho ƒë·ªô ƒëa d·∫°ng (c√≥ h·ªôi tho·∫°i, c·∫£m x√∫c, b·ªëi c·∫£nh)
    const diversityBonus = calculateDiversityBonus(chopped);
    
    const score = 0.35 * useFitness + 0.35 * sentimentFitness + 0.10 * lengthFitness + 0.20 * diversityBonus;
    
    candidates.push({text: chopped, score, use: useScore.sim, sent: sentScore.avg, len});
  }

  // Ch·ªçn t·ªët nh·∫•t
  candidates.sort((a, b) => b.score - a.score);
  const best = candidates[0];
  
  // Hi·ªÉn th·ªã th·ªëng k√™
  const components = [];
  if (best.text.includes('"')) components.push("H·ªôi tho·∫°i");
  if (best.text.includes('!') || best.text.includes('?')) components.push("C·∫£m x√∫c");
  if (best.text.includes("t·∫°i") || best.text.includes("trong") || best.text.includes("tr√™n")) components.push("B·ªëi c·∫£nh");
  
  $("#content-components").textContent = components.join(", ") || "M√¥ t·∫£ thu·∫ßn";
  $("#generation-stats").textContent = `ƒêi·ªÉm: ${best.score.toFixed(2)} | C·∫£m x√∫c: ${best.sent.toFixed(2)} | T·ª´: ${best.len}`;
  setBar(100, "detail-bar");
  
  tf.dispose(themeVec);
  
  return best.text;
}

async function scoreBySentiment(text, targetSent){
  const sents = splitSentencesVI(text);
  let sum=0, n=0;
  for (const s of sents.slice(0,80)){ // l·∫•y t·ªëi ƒëa 80 c√¢u ƒë·ªÉ nhanh
    try{ sum += sentiment.predict(s).score||0; n++; }catch{}
  }
  const avg = n? sum/n : 0;
  return {avg, dist: Math.abs(avg - targetSent)};
}

async function scoreByUSE(text, themeEmbedding){
  // D√πng sentence embeddings ƒë·ªÉ t√≠nh g·∫ßn g≈©i ch·ªß ƒë·ªÅ
  const paras = text.split(/\n{2,}/).slice(0, 8).map(s=>s.trim()).filter(Boolean);
  if (!paras.length) return {sim:0};
  const emb = await useModel.embed(paras);
  const mean = tf.tidy(()=> emb.mean(0));
  const sim = tf.tidy(()=> {
    const a = mean;
    const b = themeEmbedding;
    const na = tf.norm(a);
    const nb = tf.norm(b);
    return tf.div(tf.sum(tf.mul(a,b)), tf.mul(na, nb));
  });
  const val = (await sim.data())[0];
  tf.dispose([emb, mean, sim]);
  return {sim: val};
}

async function startGeneratingBook(){
  cancelFlag = false;
  try{
    await ensureModel();
    await ensureQLT();

    let outline;
    try{ outline = JSON.parse($("outlineBox").value || '{}'); }catch{ outline=null; }
    if (!outline || !outline.title){ await suggestOutline(); outline = JSON.parse($("outlineBox").value); }

    const title = outline.title;
    const storyFolderId = await findFolderIdByName(title, qltFolderId) || await createFolder(title, qltFolderId);
    activeStoryFolderId = storyFolderId;

    const meta = {
      title,
      chapters: outline.chapters,
      createdAt: new Date().toISOString(),
      generator: 'Markov-W (TF.js+ml5 sentiment + USE steering)',
      wordsPerChapter:+$("wordsPerChapter").value
    };
    await upsertJsonFile(storyFolderId, 'metadata.json', meta);

    const order = parseInt($("order").value || '3', 10);
    const wordsTarget = parseInt($("wordsPerChapter").value || '2300', 10);
    const targetSent = parseFloat($("targetSentiment").value || '0.1');

    const chapters = outline.chapters || Array.from({length:50}, (_,i)=>({index:i+1, name:`Ch∆∞∆°ng ${i+1}`}));

    for (let i=0; i<chapters.length; i++){
      if (cancelFlag){ setStatus('ƒê√£ hu·ª∑.'); break; }
      const ch = chapters[i];
      $("bookStatus").textContent = `ƒêang sinh: Ch∆∞∆°ng ${ch.index} ‚Äì ${ch.name}`;
      log(`Sinh ch∆∞∆°ng ${ch.index}`);

      const seed = (i===0? ($("seed").value.trim()||'T√¥i') : `T√¥i ${ch.name.toLowerCase()}`);

      const text = await generateChapter({
        model: window._lastModel,
        order,
        wordsTarget,
        seed,
        targetSent,
        chapterIndex: i,
        totalChapters: chapters.length
      });

      const titleName = ch.name || `Ch∆∞∆°ng ${i+1}`;
      const fileName = `${String(ch.index).padStart(2,'0')} - ${titleName}.txt`;
      const header = `${titleName.toUpperCase()}\n\n`;
      await upsertTextFile(storyFolderId, fileName, header + text + "\n");

      const p = Math.round(((i+1)/chapters.length)*100);
      setBar(p,'bookBar');
      $("bookStatus").textContent = `ƒê√£ upload: ${fileName}`;
      await new Promise(r=>setTimeout(r, 250));
    }

    await upsertJsonFile(storyFolderId, 'generation_summary.json', {
      finishedAt: new Date().toISOString(),
      wordsPerChapter: wordsTarget,
      order,
      targetSent
    });
    setStatus('Ho√†n t·∫•t sinh & upload.'); log('Ho√†n t·∫•t to√†n b·ªô.');
  }catch(e){
    console.error(e);
    setStatus('L·ªói: '+e.message);
    log('L·ªói: '+e.message);
  }
}

/** ============ TH√äM TRUY·ªÜN (UI) ============ */
$("createStoryFolder").onclick = async ()=>{
  try{
    await ensureQLT();
    const name = $("newStoryTitle").value.trim();
    if (!name){ setStatus('Nh·∫≠p t√™n truy·ªán.'); return; }
    const id = await findFolderIdByName(name, qltFolderId) || await createFolder(name, qltFolderId);
    $("createStoryResult").textContent = `ƒê√£ s·∫µn s√†ng th∆∞ m·ª•c: ${name} (ID: ${id})`;
    activeStoryFolderId = id;
  }catch(e){ setStatus('L·ªói t·∫°o th∆∞ m·ª•c: '+e.message); }
};
$("listSubfolders").onclick = async ()=>{
  await ensureQLT();
  const subs = await listSubfolders(qltFolderId);
  const sel = $("subfolders");
  sel.innerHTML='';
  for (const f of subs){
    const opt = document.createElement('option');
    opt.value=f.id; opt.textContent=f.name;
    sel.appendChild(opt);
  }
  sel.onchange = ()=>{
    activeStoryFolderId = sel.value;
    setStatus('Ch·ªçn th∆∞ m·ª•c: '+ sel.options[sel.selectedIndex].text);
  };
};
</script>
</body>
</html>
