<!DOCTYPE html>
<html lang="vi">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Tr√¨nh Ph√¢n T√≠ch Truy·ªán AI - N√¢ng C·∫•p</title>
    <script src="https://apis.google.com/js/api.js"></script>
    <script src="https://accounts.google.com/gsi/client"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            color: #333;
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
            padding: 20px;
        }

        .header {
            text-align: center;
            margin-bottom: 30px;
            color: white;
        }

        .header h1 {
            font-size: 2.5em;
            margin-bottom: 10px;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.3);
        }

        .header p {
            font-size: 1.2em;
            opacity: 0.9;
        }

        .auth-section, .status-section, .control-panel, .analysis-section {
            background: white;
            border-radius: 15px;
            padding: 30px;
            margin-bottom: 30px;
            box-shadow: 0 15px 35px rgba(0,0,0,0.1);
        }

        .login-btn, .control-btn {
            background: linear-gradient(45deg, #4285f4, #34a853);
            color: white;
            border: none;
            padding: 15px 30px;
            border-radius: 50px;
            font-size: 1.1em;
            cursor: pointer;
            transition: all 0.3s ease;
            box-shadow: 0 5px 15px rgba(0,0,0,0.2);
            margin: 5px;
        }

        .control-btn {
            background: linear-gradient(45deg, #ff6b6b, #ee5a24);
            padding: 12px 25px;
            font-size: 1em;
        }

        .control-btn.secondary {
            background: linear-gradient(45deg, #54a0ff, #2e86de);
        }

        .control-btn.success {
            background: linear-gradient(45deg, #00d2d3, #01a3a4);
        }

        .login-btn:hover, .control-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 8px 25px rgba(0,0,0,0.3);
        }

        .control-btn:disabled {
            background: #ccc;
            cursor: not-allowed;
            transform: none;
        }

        .file-card {
            background: #f8f9fa;
            border: 1px solid #dee2e6;
            border-radius: 10px;
            padding: 20px;
            margin-bottom: 20px;
            transition: all 0.3s ease;
        }

        .file-card:hover {
            box-shadow: 0 5px 15px rgba(0,0,0,0.1);
            transform: translateY(-2px);
        }

        .analysis-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
            gap: 20px;
            margin: 20px 0;
        }

        .analysis-item {
            background: #f8f9fa;
            border-radius: 8px;
            padding: 15px;
            border-left: 4px solid #007bff;
        }

        .analysis-item h5 {
            color: #495057;
            margin-bottom: 8px;
            font-size: 1.1em;
        }

        .progress-bar {
            width: 100%;
            height: 20px;
            background: #e9ecef;
            border-radius: 10px;
            overflow: hidden;
            margin: 10px 0;
        }

        .progress-fill {
            height: 100%;
            background: linear-gradient(45deg, #28a745, #20c997);
            width: 0%;
            transition: width 0.3s ease;
        }

        .linguistic-chart {
            background: white;
            border-radius: 8px;
            padding: 15px;
            margin: 10px 0;
            border: 1px solid #dee2e6;
        }

        .chart-bar {
            display: flex;
            align-items: center;
            margin: 8px 0;
        }

        .chart-label {
            width: 120px;
            font-weight: 500;
            font-size: 0.9em;
        }

        .chart-progress {
            flex: 1;
            height: 20px;
            background: #e9ecef;
            border-radius: 10px;
            margin: 0 10px;
            overflow: hidden;
        }

        .chart-fill {
            height: 100%;
            background: linear-gradient(45deg, #007bff, #6610f2);
            transition: width 0.5s ease;
        }

        .chart-value {
            font-weight: bold;
            color: #495057;
            min-width: 40px;
        }

        .story-output {
            background: #f8f9fa;
            border-left: 4px solid #007bff;
            padding: 20px;
            margin: 15px 0;
            border-radius: 0 10px 10px 0;
            white-space: pre-wrap;
            font-family: 'Times New Roman', serif;
            line-height: 1.8;
        }

        .hidden {
            display: none;
        }

        .error {
            background: #f8d7da;
            color: #721c24;
            border: 1px solid #f5c6cb;
            padding: 10px;
            border-radius: 5px;
            margin: 10px 0;
        }

        .success {
            background: #d4edda;
            color: #155724;
            border: 1px solid #c3e6cb;
            padding: 10px;
            border-radius: 5px;
            margin: 10px 0;
        }

        .collapsible {
            cursor: pointer;
            padding: 10px;
            background: #f1f3f4;
            border: none;
            outline: none;
            font-size: 1.1em;
            font-weight: bold;
            border-radius: 8px;
            margin: 5px 0;
            width: 100%;
            text-align: left;
            transition: background-color 0.3s;
        }

        .collapsible:hover {
            background: #e8eaed;
        }

        .collapsible.active {
            background: #d1ecf1;
        }

        .collapsible-content {
            max-height: 0;
            overflow: hidden;
            transition: max-height 0.3s ease-out;
            background: white;
            border-radius: 0 0 8px 8px;
        }

        .collapsible-content.active {
            max-height: 2000px;
            padding: 15px;
        }

        .tag {
            display: inline-block;
            background: #e3f2fd;
            color: #1976d2;
            padding: 4px 8px;
            border-radius: 12px;
            font-size: 0.8em;
            margin: 2px;
        }

        .word-cloud {
            display: flex;
            flex-wrap: wrap;
            gap: 8px;
            margin: 10px 0;
        }

        .word-item {
            display: inline-block;
            padding: 6px 12px;
            background: linear-gradient(45deg, #667eea, #764ba2);
            color: white;
            border-radius: 20px;
            font-size: 0.9em;
            font-weight: 500;
        }

        .sentiment-indicator {
            display: inline-block;
            width: 12px;
            height: 12px;
            border-radius: 50%;
            margin-right: 5px;
        }

        .sentiment-positive { background: #28a745; }
        .sentiment-negative { background: #dc3545; }
        .sentiment-neutral { background: #6c757d; }

        .loading {
            display: inline-block;
            width: 20px;
            height: 20px;
            border: 3px solid #f3f3f3;
            border-top: 3px solid #3498db;
            border-radius: 50%;
            animation: spin 1s linear infinite;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        .stats-summary {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 15px;
            margin: 20px 0;
        }

        .stat-card {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 20px;
            border-radius: 10px;
            text-align: center;
        }

        .stat-number {
            font-size: 2em;
            font-weight: bold;
            margin-bottom: 5px;
        }

        .stat-label {
            font-size: 0.9em;
            opacity: 0.9;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>ü§ñ Tr√¨nh Ph√¢n T√≠ch Truy·ªán AI - N√¢ng C·∫•p</h1>
            <p>Ph√¢n t√≠ch v√† t·∫°o truy·ªán th√¥ng minh v·ªõi AI n√¢ng cao</p>
        </div>

        <div class="auth-section">
            <div id="loginSection">
                <h2>ƒêƒÉng nh·∫≠p Google Drive</h2>
                <p>K·∫øt n·ªëi v·ªõi Google Drive ƒë·ªÉ truy c·∫≠p th∆∞ m·ª•c "QuanLyTruyen"</p>
                <br>
                <button class="login-btn" onclick="handleAuthClick()">
                    üìÅ ƒêƒÉng nh·∫≠p Google Drive
                </button>
            </div>
            <div id="loggedInSection" class="hidden">
                <h2>‚úÖ ƒê√£ k·∫øt n·ªëi th√†nh c√¥ng!</h2>
                <p id="userInfo"></p>
                <button class="control-btn" onclick="handleSignoutClick()">ƒêƒÉng xu·∫•t</button>
            </div>
        </div>

        <div class="status-section">
            <h3>üìä Tr·∫°ng th√°i h·ªá th·ªëng</h3>
            <div id="statusInfo">
                <p>üî¥ Ch∆∞a k·∫øt n·ªëi Google Drive</p>
            </div>
            <div class="progress-bar">
                <div class="progress-fill" id="progressBar"></div>
            </div>
        </div>

        <div class="control-panel">
            <h3>üéÆ B·∫£ng ƒëi·ªÅu khi·ªÉn n√¢ng cao</h3>
            <button class="control-btn" id="scanBtn" onclick="scanFolder()" disabled>
                üîç Qu√©t th∆∞ m·ª•c QuanLyTruyen
            </button>
            <button class="control-btn secondary" id="loadAnalysisBtn" onclick="loadAnalysisResults()" disabled>
                üìÇ T·∫£i k·∫øt qu·∫£ ph√¢n t√≠ch ƒë√£ l∆∞u
            </button>
            <button class="control-btn" id="clearCacheBtn" onclick="clearCache()" disabled>
                üóëÔ∏è X√≥a cache v√† qu√©t l·∫°i
            </button>
            <button class="control-btn" id="analyzeBtn" onclick="analyzeFiles()" disabled>
                üß† Ph√¢n t√≠ch chi ti·∫øt t·∫•t c·∫£ file
            </button>
            <button class="control-btn success" id="saveAnalysisBtn" onclick="saveAnalysisResults()" disabled>
                üíæ L∆∞u k·∫øt qu·∫£ ph√¢n t√≠ch
            </button>
            <button class="control-btn" id="generateBtn" onclick="generateStories()" disabled>
                ‚úçÔ∏è T·∫°o truy·ªán t·ª´ ph√¢n t√≠ch
            </button>
            <button class="control-btn success" id="saveBtn" onclick="saveToGoogleDrive()" disabled>
                üíæ L∆∞u truy·ªán l√™n Drive
            </button>
        </div>

        <div class="analysis-section">
            <h3>üìù K·∫øt qu·∫£ ph√¢n t√≠ch chi ti·∫øt v√† truy·ªán ƒë∆∞·ª£c t·∫°o</h3>
            <div id="analysisResults">
                <p>Ch∆∞a c√≥ d·ªØ li·ªáu ph√¢n t√≠ch. Vui l√≤ng qu√©t v√† ph√¢n t√≠ch th∆∞ m·ª•c tr∆∞·ªõc.</p>
            </div>
        </div>
    </div>

    <script>
        // Google API Configuration
        const CLIENT_ID = '398509518475-7bjid324tkuuh9gv8b0g92lhsgv8nrl5.apps.googleusercontent.com';
        const API_KEY = 'AIzaSyAbcWr0UPvC4YpsunE6uAa7E5pan9iys2o';
        const DISCOVERY_DOC = 'https://www.googleapis.com/discovery/v1/apis/drive/v3/rest';
        const SCOPES = 'https://www.googleapis.com/auth/drive';

        let tokenClient;
        let gapi_inited = false;
        let gsi_inited = false;

        // Global variables
        let analysisData = [];
        let generatedStories = [];
        let scanCache = {};
        const CACHE_FILE_NAME = 'ScanCache_QuanLyTruyen.json';
        const ANALYSIS_CACHE_NAME = 'AnalysisResults_QuanLyTruyen.json';

        // Vietnamese language processing data
        const vietnameseStopWords = [
            'l√†', 'c·ªßa', 'v√†', 'c√≥', 'm·ªôt', 'ƒë∆∞·ª£c', 'trong', 'kh√¥ng', 'v·ªõi', 't·ª´', 'ƒë·ªÉ', 'ƒë√£', 's·∫Ω',
            'v·ªÅ', 'cho', 'theo', 'nh∆∞', 'khi', 'v√†o', 'ra', 'l√™n', 'xu·ªëng', 'qua', 't·∫°i', 'hay',
            'r·∫±ng', 'n·∫øu', 'm√†', 'th√¨', 'ho·∫∑c', 'nh∆∞ng', 'v√¨', 'n√™n', 'ƒë·∫øn', 'b·∫±ng', 'tr√™n', 'd∆∞·ªõi'
        ];

        const emotionalWords = {
            positive: ['vui', 'h·∫°nh ph√∫c', 'y√™u', 'th∆∞∆°ng', 'tuy·ªát v·ªùi', 'ƒë·∫πp', 't·ªët', 'xu·∫•t s·∫Øc', 'th√†nh c√¥ng', 'hy v·ªçng', 'v·∫ª vang', 'h√¢n hoan', 'ph·∫•n kh√≠ch', 'c∆∞·ªùi', 'vui m·ª´ng'],
            negative: ['bu·ªìn', 'ƒëau', 'kh·ªï', 't·ªá', 'x·∫•u', 'th·∫•t b·∫°i', 'tuy·ªát v·ªçng', 'gh√©t', 't·ª©c gi·∫≠n', 'lo l·∫Øng', 's·ª£ h√£i', 'kh√≥c', 'tang th∆∞∆°ng', 'b·∫•t h·∫°nh'],
            neutral: ['b√¨nh th∆∞·ªùng', 'th√¥ng th∆∞·ªùng', 'trung b√¨nh', '·ªïn', 'ƒë∆∞·ª£c', 't·∫°m ·ªïn']
        };

        const literaryDevices = {
            '·∫®n d·ª•': ['nh∆∞', 't·ª±a', 'gi·ªëng nh∆∞', 't∆∞∆°ng t·ª±'],
            'Nh√¢n h√≥a': ['gi√≥ th·ªïi', 'm·∫∑t tr·ªùi c∆∞·ªùi', 'c√¢y n√≥i', 'hoa kh√≥c'],
            'T∆∞∆°ng ph·∫£n': ['tr√°i ng∆∞·ª£c', 'ƒë·ªëi l·∫≠p', 'kh√°c bi·ªát', 't∆∞∆°ng ph·∫£n'],
            'L·∫∑p t·ª´': [], // S·∫Ω detect b·∫±ng thu·∫≠t to√°n
            'ƒêi·ªáp ng·ªØ': [], // S·∫Ω detect b·∫±ng thu·∫≠t to√°n
        };

        // Initialize Google APIs
        function gapiLoaded() {
            gapi.load('client', initializeGapiClient);
        }

        async function initializeGapiClient() {
            await gapi.client.init({
                apiKey: API_KEY,
                discoveryDocs: [DISCOVERY_DOC],
            });
            gapi_inited = true;
            maybeEnableButtons();
        }

        function gisLoaded() {
            tokenClient = google.accounts.oauth2.initTokenClient({
                client_id: CLIENT_ID,
                scope: SCOPES,
                callback: '',
            });
            gsi_inited = true;
            maybeEnableButtons();
        }

        function maybeEnableButtons() {
            if (gapi_inited && gsi_inited) {
                document.getElementById('scanBtn').disabled = false;
            }
        }

        // Authentication functions
        function handleAuthClick() {
            tokenClient.callback = async (resp) => {
                if (resp.error !== undefined) {
                    throw (resp);
                }
                await showLoggedInState();
            };

            if (gapi.client.getToken() === null) {
                tokenClient.requestAccessToken({prompt: 'consent'});
            } else {
                tokenClient.requestAccessToken({prompt: ''});
            }
        }

        function handleSignoutClick() {
            const token = gapi.client.getToken();
            if (token !== null) {
                google.accounts.oauth2.revoke(token.access_token);
                gapi.client.setToken('');
                showLoggedOutState();
            }
        }

        async function showLoggedInState() {
            document.getElementById('loginSection').classList.add('hidden');
            document.getElementById('loggedInSection').classList.remove('hidden');
            document.getElementById('statusInfo').innerHTML = '<p>üü¢ ƒê√£ k·∫øt n·ªëi Google Drive</p>';
            
            document.getElementById('scanBtn').disabled = false;
            document.getElementById('clearCacheBtn').disabled = false;
            document.getElementById('loadAnalysisBtn').disabled = false;
            
            try {
                const response = await gapi.client.request({
                    path: 'https://www.googleapis.com/oauth2/v1/userinfo',
                });
                document.getElementById('userInfo').textContent = `Xin ch√†o, ${response.result.name}!`;
            } catch (error) {
                console.error('Error getting user info:', error);
            }
        }

        function showLoggedOutState() {
            document.getElementById('loginSection').classList.remove('hidden');
            document.getElementById('loggedInSection').classList.add('hidden');
            document.getElementById('statusInfo').innerHTML = '<p>üî¥ Ch∆∞a k·∫øt n·ªëi Google Drive</p>';
            
            const buttons = ['scanBtn', 'clearCacheBtn', 'loadAnalysisBtn', 'analyzeBtn', 'saveAnalysisBtn', 'generateBtn', 'saveBtn'];
            buttons.forEach(id => document.getElementById(id).disabled = true);
        }

        // Advanced Analysis Functions
        async function analyzeFiles() {
            if (!window.txtFiles || window.txtFiles.length === 0) {
                alert('Vui l√≤ng qu√©t th∆∞ m·ª•c tr∆∞·ªõc khi ph√¢n t√≠ch!');
                return;
            }
            
            updateStatus('üß† B·∫Øt ƒë·∫ßu ph√¢n t√≠ch chi ti·∫øt...');
            analysisData = [];
            
            const totalFiles = Math.min(window.txtFiles.length, 50); // Gi·ªõi h·∫°n 50 file ƒë·ªÉ tr√°nh qu√° t·∫£i
            
            for (let i = 0; i < totalFiles; i++) {
                const file = window.txtFiles[i];
                updateProgress((i / totalFiles) * 100);
                updateStatus(`üß† ƒêang ph√¢n t√≠ch chi ti·∫øt: ${file.name} (${i+1}/${totalFiles})`);
                
                try {
                    const response = await gapi.client.drive.files.get({
                        fileId: file.id,
                        alt: 'media'
                    });
                    
                    const content = response.body;
                    const analysis = await performAdvancedAnalysis(content, file.name, file.folderPath);
                    analysisData.push(analysis);
                    
                    // Th√™m delay nh·ªè ƒë·ªÉ tr√°nh qu√° t·∫£i
                    await new Promise(resolve => setTimeout(resolve, 100));
                    
                } catch (error) {
                    console.error(`Error analyzing file ${file.name}:`, error);
                    analysisData.push({
                        fileName: file.name,
                        error: error.message
                    });
                }
            }
            
            displayAdvancedAnalysisResults();
            document.getElementById('generateBtn').disabled = false;
            document.getElementById('saveAnalysisBtn').disabled = false;
            updateProgress(100);
            updateStatus(`‚úÖ Ho√†n th√†nh ph√¢n t√≠ch chi ti·∫øt ${totalFiles} file`);
            
            setTimeout(() => updateProgress(0), 2000);
        }

        async function performAdvancedAnalysis(content, fileName, folderPath) {
            await new Promise(resolve => setTimeout(resolve, 500));
            
            const analysis = {
                fileName: fileName,
                folderPath: folderPath || 'Unknown',
                timestamp: new Date().toLocaleString('vi-VN'),
                
                // Ph√¢n t√≠ch c∆° b·∫£n n√¢ng cao
                basicStats: analyzeBasicStats(content),
                
                // Ph√¢n t√≠ch ng√¥n ng·ªØ h·ªçc
                linguisticAnalysis: analyzeLinguistics(content),
                
                // Ph√¢n t√≠ch c·∫•u tr√∫c vƒÉn b·∫£n
                structureAnalysis: analyzeTextStructure(content),
                
                // Ph√¢n t√≠ch nh√¢n v·∫≠t chi ti·∫øt
                characterAnalysis: analyzeCharactersAdvanced(content),
                
                // Ph√¢n t√≠ch c·∫£m x√∫c v√† t√¢m l√Ω
                emotionalAnalysis: analyzeEmotionsAdvanced(content),
                
                // Ph√¢n t√≠ch ch·ªß ƒë·ªÅ v√† √Ω nghƒ©a
                thematicAnalysis: analyzeThemes(content),
                
                // Ph√¢n t√≠ch phong c√°ch vi·∫øt
                styleAnalysis: analyzeWritingStyleAdvanced(content),
                
                // Ph√¢n t√≠ch c·ªët truy·ªán
                narrativeAnalysis: analyzeNarrativeStructure(content),
                
                // Ph√¢n t√≠ch b·ªëi c·∫£nh
                contextAnalysis: analyzeContext(content),
                
                // Ph√¢n t√≠ch bi·ªán ph√°p tu t·ª´
                rhetoricAnalysis: analyzeRhetoricalDevices(content),
                
                // Ph√¢n t√≠ch t·ª´ v·ª±ng
                vocabularyAnalysis: analyzeVocabulary(content),
                
                // N·ªôi dung g·ªëc (m·∫´u)
                contentSample: content.substring(0, 1000) + (content.length > 1000 ? '...' : '')
            };
            
            return analysis;
        }

        function analyzeBasicStats(content) {
            const sentences = content.split(/[.!?]+/).filter(s => s.trim().length > 0);
            const paragraphs = content.split(/\n\s*\n/).filter(p => p.trim().length > 0);
            const words = content.split(/\s+/).filter(w => w.length > 0);
            const characters = content.length;
            const charactersNoSpaces = content.replace(/\s/g, '').length;
            
            return {
                wordCount: words.length,
                sentenceCount: sentences.length,
                paragraphCount: paragraphs.length,
                characterCount: characters,
                characterCountNoSpaces: charactersNoSpaces,
                avgWordsPerSentence: Math.round(words.length / sentences.length * 10) / 10,
                avgSentencesPerParagraph: Math.round(sentences.length / paragraphs.length * 10) / 10,
                avgWordLength: Math.round(charactersNoSpaces / words.length * 10) / 10
            };
        }

        function analyzeLinguistics(content) {
            const words = content.toLowerCase().split(/\s+/).filter(w => w.length > 0);
            
            // Ph√¢n lo·∫°i t·ª´ lo·∫°i (ƒë∆°n gi·∫£n)
            const wordTypes = classifyWordTypes(words);
            
            // Ph√¢n t√≠ch t·∫ßn su·∫•t t·ª´
            const wordFrequency = analyzeWordFrequency(words);
            
            // ƒê·ªô ph·ª©c t·∫°p t·ª´ v·ª±ng
            const vocabularyComplexity = analyzeVocabularyComplexity(words);
            
            return {
                wordTypes: wordTypes,
                topWords: wordFrequency.slice(0, 20),
                vocabularyComplexity: vocabularyComplexity,
                uniqueWordRatio: (new Set(words).size / words.length * 100).toFixed(2) + '%'
            };
        }

        function classifyWordTypes(words) {
            const nouns = ['ng∆∞·ªùi', 'nh√†', 'tr∆∞·ªùng', 'con', 'c√¢y', 'hoa', 'n∆∞·ªõc', 't√¨nh', 'y√™u', 'tim', 'm·∫Øt', 'tay', 'ch√¢n'];
            const verbs = ['l√†', 'c√≥', 'l√†m', 'ƒëi', 'ƒë·∫øn', 'v·ªÅ', 'n√≥i', 'bi·∫øt', 'th·∫•y', 'nghe', 'ƒÉn', 'u·ªëng', 'ch·∫°y', 'bay'];
            const adjectives = ['ƒë·∫πp', 'x·∫•u', 't·ªët', 't·ªá', 'l·ªõn', 'nh·ªè', 'cao', 'th·∫•p', 'nhanh', 'ch·∫≠m', 'vui', 'bu·ªìn'];
            const adverbs = ['r·∫•t', 'kh√°', 'h∆°i', 'qu√°', 'c√†ng', 'th√™m', 'ƒë√£', 'ƒëang', 's·∫Ω', 'v·ª´a', 'm·ªõi'];
            
            let counts = {
                nouns: 0,
                verbs: 0,
                adjectives: 0,
                adverbs: 0,
                others: 0
            };
            
            words.forEach(word => {
                const cleanWord = word.replace(/[^\w√†√°·∫°·∫£√£√¢·∫ß·∫•·∫≠·∫©·∫´ƒÉ·∫±·∫Ø·∫∑·∫≥·∫µ√®√©·∫π·∫ª·∫Ω√™·ªÅ·∫ø·ªá·ªÉ·ªÖ√¨√≠·ªã·ªâƒ©√≤√≥·ªç·ªè√µ√¥·ªì·ªë·ªô·ªï·ªó∆°·ªù·ªõ·ª£·ªü·ª°√π√∫·ª•·ªß≈©∆∞·ª´·ª©·ª±·ª≠·ªØ·ª≥√Ω·ªµ·ª∑·ªπƒë]/gi, '');
                if (nouns.some(n => cleanWord.includes(n))) counts.nouns++;
                else if (verbs.some(v => cleanWord.includes(v))) counts.verbs++;
                else if (adjectives.some(a => cleanWord.includes(a))) counts.adjectives++;
                else if (adverbs.some(a => cleanWord.includes(a))) counts.adverbs++;
                else counts.others++;
            });
            
            const total = Object.values(counts).reduce((a, b) => a + b, 0);
            return Object.entries(counts).map(([type, count]) => ({
                type: type,
                count: count,
                percentage: ((count / total) * 100).toFixed(1) + '%'
            }));
        }

        function analyzeWordFrequency(words) {
            const frequency = {};
            words.forEach(word => {
                const cleanWord = word.replace(/[^\w√†√°·∫°·∫£√£√¢·∫ß·∫•·∫≠·∫©·∫´ƒÉ·∫±·∫Ø·∫∑·∫≥·∫µ√®√©·∫π·∫ª·∫Ω√™·ªÅ·∫ø·ªá·ªÉ·ªÖ√¨√≠·ªã·ªâƒ©√≤√≥·ªç·ªè√µ√¥·ªì·ªë·ªô·ªï·ªó∆°·ªù·ªõ·ª£·ªü·ª°√π√∫·ª•·ªß≈©∆∞·ª´·ª©·ª±·ª≠·ªØ·ª≥√Ω·ªµ·ª∑·ªπƒë]/gi, '').toLowerCase();
                if (cleanWord.length > 1 && !vietnameseStopWords.includes(cleanWord)) {
                    frequency[cleanWord] = (frequency[cleanWord] || 0) + 1;
                }
            });
            
            return Object.entries(frequency)
                .sort(([,a], [,b]) => b - a)
                .map(([word, count]) => ({ word, count, percentage: ((count / words.length) * 100).toFixed(2) + '%' }));
        }

        function analyzeVocabularyComplexity(words) {
            const uniqueWords = new Set(words).size;
            const totalWords = words.length;
            const longWords = words.filter(w => w.length > 6).length;
            
            return {
                lexicalDiversity: (uniqueWords / totalWords).toFixed(3),
                complexWordRatio: ((longWords / totalWords) * 100).toFixed(1) + '%',
                averageWordLength: (words.reduce((sum, word) => sum + word.length, 0) / totalWords).toFixed(1)
            };
        }

        function analyzeTextStructure(content) {
            const sentences = content.split(/[.!?]+/).filter(s => s.trim().length > 0);
            const paragraphs = content.split(/\n\s*\n/).filter(p => p.trim().length > 0);
            
            // Ph√¢n t√≠ch ƒë·ªô d√†i c√¢u
            const sentenceLengths = sentences.map(s => s.trim().split(/\s+/).length);
            const avgSentenceLength = sentenceLengths.reduce((a, b) => a + b, 0) / sentenceLengths.length;
            
            // Ph√¢n lo·∫°i c·∫•u tr√∫c c√¢u
            const shortSentences = sentenceLengths.filter(len => len <= 10).length;
            const mediumSentences = sentenceLengths.filter(len => len > 10 && len <= 20).length;
            const longSentences = sentenceLengths.filter(len => len > 20).length;
            
            return {
                sentenceStructure: {
                    short: { count: shortSentences, percentage: ((shortSentences / sentences.length) * 100).toFixed(1) + '%' },
                    medium: { count: mediumSentences, percentage: ((mediumSentences / sentences.length) * 100).toFixed(1) + '%' },
                    long: { count: longSentences, percentage: ((longSentences / sentences.length) * 100).toFixed(1) + '%' }
                },
                averageSentenceLength: Math.round(avgSentenceLength * 10) / 10,
                textFlow: analyzeTextFlow(content),
                coherence: analyzeCoherence(paragraphs)
            };
        }

        function analyzeTextFlow(content) {
            const transitionWords = ['tuy nhi√™n', 'nh∆∞ng', 'v√¨ v·∫≠y', 'do ƒë√≥', 'b√™n c·∫°nh ƒë√≥', 'h∆°n n·ªØa', 'tr∆∞·ªõc ti√™n', 'cu·ªëi c√πng', 'k·∫øt qu·∫£', 'ng∆∞·ª£c l·∫°i'];
            const transitionCount = transitionWords.reduce((count, word) => {
                return count + (content.toLowerCase().match(new RegExp(word, 'g')) || []).length;
            }, 0);
            
            return {
                transitionWordCount: transitionCount,
                flowScore: transitionCount > 5 ? 'T·ªët' : transitionCount > 2 ? 'Trung b√¨nh' : 'C·∫ßn c·∫£i thi·ªán'
            };
        }

        function analyzeCoherence(paragraphs) {
            const avgParagraphLength = paragraphs.reduce((sum, p) => sum + p.split(/\s+/).length, 0) / paragraphs.length;
            
            return {
                paragraphBalance: avgParagraphLength > 50 ? 'ƒêo·∫°n vƒÉn d√†i' : avgParagraphLength > 20 ? 'ƒêo·∫°n vƒÉn v·ª´a' : 'ƒêo·∫°n vƒÉn ng·∫Øn',
                coherenceScore: paragraphs.length > 3 ? 'C√≥ c·∫•u tr√∫c' : 'ƒê∆°n gi·∫£n'
            };
        }

        function analyzeCharactersAdvanced(content) {
            const characters = [];
            
            // T√¨m t√™n nh√¢n v·∫≠t (c·∫£i ti·∫øn)
            const namePattern = /\b[A-Z√Ä-·ª∏][a-z√†-·ªπ]{2,15}(?:\s[A-Z√Ä-·ª∏][a-z√†-·ªπ]{2,15})*\b/g;
            const potentialNames = content.match(namePattern) || [];
            
            // ƒê·∫øm t·∫ßn su·∫•t xu·∫•t hi·ªán
            const nameCounts = {};
            potentialNames.forEach(name => {
                if (name.length > 2 && name.length < 30 && !isCommonWord(name)) {
                    nameCounts[name] = (nameCounts[name] || 0) + 1;
                }
            });
            
            // L·ªçc v√† ph√¢n t√≠ch nh√¢n v·∫≠t
            Object.entries(nameCounts)
                .filter(([name, count]) => count >= 2)
                .sort(([,a], [,b]) => b - a)
                .slice(0, 10)
                .forEach(([name, count]) => {
                    const characterInfo = analyzeCharacterTraits(content, name);
                    characters.push({
                        name: name,
                        appearances: count,
                        importance: count > 5 ? 'Ch√≠nh' : count > 2 ? 'Ph·ª•' : 'N·ªÅn',
                        traits: characterInfo.traits,
                        emotions: characterInfo.emotions,
                        relationships: characterInfo.relationships
                    });
                });
            
            return {
                characterCount: characters.length,
                characters: characters,
                characterDevelopment: analyzeCharacterDevelopment(content, characters)
            };
        }

        function isCommonWord(word) {
            const commonWords = ['Vi·ªát', 'Nam', 'H√†', 'N·ªôi', 'S√†i', 'G√≤n', 'Th√†nh', 'Ph·ªë', 'Ch√∫a', 'Ph·∫≠t', 'Th√°ng', 'NƒÉm'];
            return commonWords.some(common => word.includes(common));
        }

        function analyzeCharacterTraits(content, characterName) {
            const traitKeywords = {
                'T·ªët b·ª•ng': ['t·ªët b·ª•ng', 't·ª≠ t·∫ø', 'h·∫£o t√¢m', 'nh√¢n h·∫≠u', 't·ªët'],
                'Th√¥ng minh': ['th√¥ng minh', 'kh√¥n ngoan', 's√°ng su·ªët', 'tr√≠ tu·ªá', 'h·ªçc gi·ªèi'],
                'D≈©ng c·∫£m': ['d≈©ng c·∫£m', 'can ƒë·∫£m', 'anh h√πng', 'gan d·∫°', 'kh√¥ng s·ª£'],
                'T√¨nh c·∫£m': ['y√™u th∆∞∆°ng', 'quan t√¢m', 'chƒÉm s√≥c', '·∫•m √°p', 't√¨nh c·∫£m'],
                'Quy·∫øt ƒëo√°n': ['quy·∫øt ƒëo√°n', 'm·∫°nh m·∫Ω', 'ki√™n quy·∫øt', 'c∆∞∆°ng quy·∫øt']
            };
            
            const traits = [];
            const emotions = [];
            
            // T√¨m c√¢u ch·ª©a t√™n nh√¢n v·∫≠t
            const sentences = content.split(/[.!?]+/);
            const characterSentences = sentences.filter(s => s.includes(characterName));
            
            Object.entries(traitKeywords).forEach(([trait, keywords]) => {
                const mentions = keywords.reduce((count, keyword) => {
                    return count + characterSentences.reduce((acc, sentence) => {
                        return acc + (sentence.toLowerCase().includes(keyword) ? 1 : 0);
                    }, 0);
                }, 0);
                if (mentions > 0) {
                    traits.push({ trait, mentions });
                }
            });
            
            // Ph√¢n t√≠ch c·∫£m x√∫c c·ªßa nh√¢n v·∫≠t
            Object.entries(emotionalWords).forEach(([emotion, words]) => {
                const mentions = words.reduce((count, word) => {
                    return count + characterSentences.reduce((acc, sentence) => {
                        return acc + (sentence.toLowerCase().includes(word) ? 1 : 0);
                    }, 0);
                }, 0);
                if (mentions > 0) {
                    emotions.push({ emotion, mentions });
                }
            });
            
            return {
                traits: traits.sort((a, b) => b.mentions - a.mentions),
                emotions: emotions.sort((a, b) => b.mentions - a.mentions),
                relationships: analyzeRelationships(content, characterName)
            };
        }

        function analyzeRelationships(content, characterName) {
            const relationshipKeywords = ['v√†', 'c√πng', 'v·ªõi', 'y√™u', 'th∆∞∆°ng', 'b·∫°n', 'ng∆∞·ªùi y√™u', 'v·ª£', 'ch·ªìng', 'con', 'm·∫π', 'b·ªë'];
            const sentences = content.split(/[.!?]+/);
            const relationships = [];
            
            sentences.forEach(sentence => {
                if (sentence.includes(characterName)) {
                    relationshipKeywords.forEach(keyword => {
                        if (sentence.toLowerCase().includes(keyword)) {
                            relationships.push({
                                type: keyword,
                                context: sentence.trim().substring(0, 100)
                            });
                        }
                    });
                }
            });
            
            return relationships.slice(0, 5);
        }

        function analyzeCharacterDevelopment(content, characters) {
            if (characters.length === 0) return 'Kh√¥ng c√≥ nh√¢n v·∫≠t r√µ r√†ng';
            
            const mainCharacter = characters[0];
            const developmentIndicators = ['h·ªçc ƒë∆∞·ª£c', 'thay ƒë·ªïi', 'tr∆∞·ªüng th√†nh', 'nh·∫≠n ra', 'hi·ªÉu ƒë∆∞·ª£c'];
            
            const developmentMentions = developmentIndicators.reduce((count, indicator) => {
                return count + (content.toLowerCase().match(new RegExp(indicator, 'g')) || []).length;
            }, 0);
            
            return developmentMentions > 3 ? 'C√≥ s·ª± ph√°t tri·ªÉn r√µ r√†ng' : developmentMentions > 1 ? 'C√≥ s·ª± thay ƒë·ªïi nh·∫π' : 'Nh√¢n v·∫≠t tƒ©nh';
        }

        function analyzeEmotionsAdvanced(content) {
            const emotionAnalysis = {};
            const sentences = content.split(/[.!?]+/).filter(s => s.trim());
            
            // Ph√¢n t√≠ch c·∫£m x√∫c t·ªïng th·ªÉ
            Object.entries(emotionalWords).forEach(([category, words]) => {
                const mentions = words.reduce((count, word) => {
                    return count + (content.toLowerCase().match(new RegExp(word, 'g')) || []).length;
                }, 0);
                emotionAnalysis[category] = {
                    count: mentions,
                    percentage: ((mentions / sentences.length) * 100).toFixed(1) + '%'
                };
            });
            
            // Ph√¢n t√≠ch bi·∫øn thi√™n c·∫£m x√∫c
            const emotionalJourney = analyzeEmotionalJourney(content);
            
            // C∆∞·ªùng ƒë·ªô c·∫£m x√∫c
            const emotionalIntensity = analyzeEmotionalIntensity(content);
            
            return {
                overallTone: determineOverallTone(emotionAnalysis),
                emotionBreakdown: emotionAnalysis,
                emotionalJourney: emotionalJourney,
                emotionalIntensity: emotionalIntensity,
                sentimentScore: calculateSentimentScore(emotionAnalysis)
            };
        }

        function analyzeEmotionalJourney(content) {
            const sections = content.split(/\n\s*\n/);
            const journey = [];
            
            sections.forEach((section, index) => {
                const sectionEmotions = {};
                Object.entries(emotionalWords).forEach(([category, words]) => {
                    const count = words.reduce((acc, word) => {
                        return acc + (section.toLowerCase().match(new RegExp(word, 'g')) || []).length;
                    }, 0);
                    sectionEmotions[category] = count;
                });
                
                const dominantEmotion = Object.entries(sectionEmotions)
                    .sort(([,a], [,b]) => b - a)[0];
                
                if (dominantEmotion && dominantEmotion[1] > 0) {
                    journey.push({
                        section: index + 1,
                        emotion: dominantEmotion[0],
                        intensity: dominantEmotion[1]
                    });
                }
            });
            
            return journey;
        }

        function analyzeEmotionalIntensity(content) {
            const intensifiers = ['r·∫•t', 'qu√°', 'c·ª±c k·ª≥', 'v√¥ c√πng', 'h·∫øt s·ª©c', 'tuy·ªát v·ªùi', 'kinh kh·ªßng'];
            const intensityCount = intensifiers.reduce((count, word) => {
                return count + (content.toLowerCase().match(new RegExp(word, 'g')) || []).length;
            }, 0);
            
            const words = content.split(/\s+/).length;
            const intensityRatio = (intensityCount / words) * 100;
            
            return {
                intensifierCount: intensityCount,
                intensityLevel: intensityRatio > 2 ? 'Cao' : intensityRatio > 1 ? 'Trung b√¨nh' : 'Th·∫•p',
                intensityRatio: intensityRatio.toFixed(2) + '%'
            };
        }

        function determineOverallTone(emotionAnalysis) {
            const positive = emotionAnalysis.positive?.count || 0;
            const negative = emotionAnalysis.negative?.count || 0;
            const neutral = emotionAnalysis.neutral?.count || 0;
            
            if (positive > negative && positive > neutral) return 'T√≠ch c·ª±c';
            if (negative > positive && negative > neutral) return 'Ti√™u c·ª±c';
            return 'Trung t√≠nh';
        }

        function calculateSentimentScore(emotionAnalysis) {
            const positive = emotionAnalysis.positive?.count || 0;
            const negative = emotionAnalysis.negative?.count || 0;
            const total = positive + negative;
            
            if (total === 0) return 0;
            return ((positive - negative) / total * 100).toFixed(1);
        }

        function analyzeThemes(content) {
            const themeKeywords = {
                'T√¨nh y√™u': ['y√™u', 'th∆∞∆°ng', 'y√™u th∆∞∆°ng', 't√¨nh c·∫£m', 'l√£ng m·∫°n', 'tim', 'tr√°i tim', 'h√¥n', '√¥m', 'c∆∞·ªõi'],
                'Gia ƒë√¨nh': ['gia ƒë√¨nh', 'b·ªë', 'm·∫π', 'con', 'anh em', 'ch·ªã em', '√¥ng b√†', 'h·ªç h√†ng', 'nh√†', 'qu√™ h∆∞∆°ng'],
                'T√¨nh b·∫°n': ['b·∫°n', 'b·∫°n b√®', 't√¨nh b·∫°n', 'ƒë·ªìng nghi·ªáp', 'c√πng nhau', 'ch∆°i', 'chia s·∫ª'],
                'Phi√™u l∆∞u': ['phi√™u l∆∞u', 'kh√°m ph√°', 'h√†nh tr√¨nh', 'du l·ªãch', 'm·∫°o hi·ªÉm', 'r·ª´ng', 'n√∫i', 'bi·ªÉn'],
                'Chi·∫øn ƒë·∫•u': ['chi·∫øn ƒë·∫•u', 'ƒë√°nh nhau', 'chi·∫øn tranh', 'v√µ thu·∫≠t', 'anh h√πng', 'chi·∫øn th·∫Øng', 'thua'],
                'T√¢m linh': ['th·∫ßn', 'ph·∫≠t', 't√¢m linh', 't√¥n gi√°o', 'c·∫ßu nguy·ªán', 'thi·ªÅn', 'ƒë·∫°o', 't√≠n ng∆∞·ª°ng'],
                'H·ªçc t·∫≠p': ['h·ªçc', 'tr∆∞·ªùng', 'th·∫ßy', 'c√¥', 'b√†i', 'thi', 'ki·∫øn th·ª©c', 's√°ch', 'vi·∫øt'],
                'C√¥ng vi·ªác': ['l√†m vi·ªác', 'c√¥ng ty', 's·∫øp', 'ƒë·ªìng nghi·ªáp', 'l∆∞∆°ng', 'ngh·ªÅ nghi·ªáp', 'th√†nh c√¥ng'],
                'Thi√™n nhi√™n': ['c√¢y', 'hoa', 'l√°', 'r·ª´ng', 'n√∫i', 's√¥ng', 'bi·ªÉn', 'tr·ªùi', 'm∆∞a', 'n·∫Øng'],
                'Th·ªùi gian': ['th·ªùi gian', 'qu√° kh·ª©', 'hi·ªán t·∫°i', 't∆∞∆°ng lai', 'ng√†y', 'th√°ng', 'nƒÉm', 'gi·ªù']
            };
            
            const themes = [];
            Object.entries(themeKeywords).forEach(([theme, keywords]) => {
                const mentions = keywords.reduce((count, keyword) => {
                    return count + (content.toLowerCase().match(new RegExp(keyword, 'g')) || []).length;
                }, 0);
                if (mentions > 0) {
                    themes.push({
                        theme: theme,
                        mentions: mentions,
                        relevance: mentions,
                        percentage: ((mentions / content.split(/\s+/).length) * 100).toFixed(2) + '%'
                    });
                }
            });
            
            return {
                mainThemes: themes.sort((a, b) => b.relevance - a.relevance).slice(0, 5),
                themeDistribution: calculateThemeDistribution(themes),
                thematicComplexity: themes.length > 5 ? 'Ph·ª©c t·∫°p' : themes.length > 3 ? 'V·ª´a ph·∫£i' : 'ƒê∆°n gi·∫£n'
            };
        }

        function calculateThemeDistribution(themes) {
            const total = themes.reduce((sum, theme) => sum + theme.mentions, 0);
            return themes.map(theme => ({
                ...theme,
                distribution: ((theme.mentions / total) * 100).toFixed(1) + '%'
            }));
        }

        function analyzeWritingStyleAdvanced(content) {
            const sentences = content.split(/[.!?]+/).filter(s => s.trim());
            const words = content.split(/\s+/);
            const avgSentenceLength = words.length / sentences.length;
            
            // Ph√¢n t√≠ch g√≥c nh√¨n
            const perspective = analyzePerspective(content);
            
            // Ph√¢n t√≠ch th√¨
            const tenseAnalysis = analyzeTense(content);
            
            // Ph√¢n t√≠ch gi·ªçng ƒëi·ªáu
            const toneAnalysis = analyzeTone(content);
            
            // Ph√¢n t√≠ch ƒë·ªô ph·ª©c t·∫°p
            const complexityAnalysis = analyzeComplexity(content, avgSentenceLength);
            
            return {
                perspective: perspective,
                tense: tenseAnalysis,
                tone: toneAnalysis,
                complexity: complexityAnalysis,
                averageSentenceLength: Math.round(avgSentenceLength * 10) / 10,
                writingStyle: determineWritingStyle(avgSentenceLength, perspective, toneAnalysis)
            };
        }

        function analyzePerspective(content) {
            const firstPerson = (content.match(/\b(t√¥i|m√¨nh|ta)\b/gi) || []).length;
            const secondPerson = (content.match(/\b(b·∫°n|anh|ch·ªã|em)\b/gi) || []).length;
            const thirdPerson = (content.match(/\b(h·ªç|c√¥ ·∫•y|anh ·∫•y|ch√∫ng)\b/gi) || []).length;
            
            const total = firstPerson + secondPerson + thirdPerson;
            if (total === 0) return 'Kh√¥ng x√°c ƒë·ªãnh';
            
            const max = Math.max(firstPerson, secondPerson, thirdPerson);
            if (max === firstPerson) return 'Ng√¥i th·ª© nh·∫•t';
            if (max === secondPerson) return 'Ng√¥i th·ª© hai';
            return 'Ng√¥i th·ª© ba';
        }

        function analyzeTense(content) {
            const pastTense = (content.match(/\b(ƒë√£|ƒë√£ t·ª´ng|tr∆∞·ªõc ƒë√¢y|h√¥m qua)\b/gi) || []).length;
            const presentTense = (content.match(/\b(ƒëang|hi·ªán t·∫°i|b√¢y gi·ªù|h√¥m nay)\b/gi) || []).length;
            const futureTense = (content.match(/\b(s·∫Ω|s·∫Øp|mai|t∆∞∆°ng lai)\b/gi) || []).length;
            
            const total = pastTense + presentTense + futureTense;
            if (total === 0) return 'Kh√¥ng x√°c ƒë·ªãnh';
            
            return {
                past: { count: pastTense, percentage: ((pastTense / total) * 100).toFixed(1) + '%' },
                present: { count: presentTense, percentage: ((presentTense / total) * 100).toFixed(1) + '%' },
                future: { count: futureTense, percentage: ((futureTense / total) * 100).toFixed(1) + '%' }
            };
        }

        function analyzeTone(content) {
            const formalWords = ['k√≠nh th∆∞a', 'xin ch√†o', 'c·∫£m ∆°n', 'xin l·ªói', 'k√≠nh tr·ªçng'];
            const informalWords = ['·ªßa', '∆°i', 'n√®', '√†', 'h·∫£', 'th·∫ø √†'];
            const questionMarks = (content.match(/\?/g) || []).length;
            const exclamationMarks = (content.match(/!/g) || []).length;
            
            const formalCount = formalWords.reduce((count, word) => {
                return count + (content.toLowerCase().match(new RegExp(word, 'g')) || []).length;
            }, 0);
            
            const informalCount = informalWords.reduce((count, word) => {
                return count + (content.toLowerCase().match(new RegExp(word, 'g')) || []).length;
            }, 0);
            
            return {
                formality: formalCount > informalCount ? 'Trang tr·ªçng' : informalCount > formalCount ? 'Th√¢n m·∫≠t' : 'Trung t√≠nh',
                questionCount: questionMarks,
                exclamationCount: exclamationMarks,
                expressiveness: exclamationMarks > questionMarks ? 'C·∫£m x√∫c' : questionMarks > 0 ? 'T∆∞∆°ng t√°c' : 'T∆∞·ªùng thu·∫≠t'
            };
        }

        function analyzeComplexity(content, avgSentenceLength) {
            const complexWords = content.split(/\s+/).filter(word => word.length > 8).length;
            const totalWords = content.split(/\s+/).length;
            const complexityRatio = (complexWords / totalWords) * 100;
            
            return {
                lexicalComplexity: complexityRatio.toFixed(1) + '%',
                syntacticComplexity: avgSentenceLength > 20 ? 'Cao' : avgSentenceLength > 12 ? 'Trung b√¨nh' : 'Th·∫•p',
                overallComplexity: complexityRatio > 15 && avgSentenceLength > 20 ? 'Ph·ª©c t·∫°p' : 
                                 complexityRatio > 10 || avgSentenceLength > 15 ? 'Trung b√¨nh' : 'ƒê∆°n gi·∫£n'
            };
        }

        function determineWritingStyle(avgSentenceLength, perspective, toneAnalysis) {
            const styles = [];
            
            if (avgSentenceLength > 20) styles.push('VƒÉn xu√¥i d√†i');
            else if (avgSentenceLength < 10) styles.push('VƒÉn xu√¥i ng·∫Øn');
            
            if (toneAnalysis.formality === 'Trang tr·ªçng') styles.push('Trang tr·ªçng');
            else if (toneAnalysis.formality === 'Th√¢n m·∫≠t') styles.push('Th√¢n m·∫≠t');
            
            if (toneAnalysis.expressiveness === 'C·∫£m x√∫c') styles.push('Bi·ªÉu c·∫£m');
            
            if (perspective === 'Ng√¥i th·ª© nh·∫•t') styles.push('T·ª± s·ª±');
            
            return styles.length > 0 ? styles.join(', ') : 'Trung t√≠nh';
        }

        function analyzeNarrativeStructure(content) {
            const paragraphs = content.split(/\n\s*\n/).filter(p => p.trim());
            const totalLength = content.split(/\s+/).length;
            
            // Ph√¢n t√≠ch c·∫•u tr√∫c 3 h·ªìi
            const structure = analyzeThreeActStructure(paragraphs, totalLength);
            
            // Ph√¢n t√≠ch c√°c y·∫øu t·ªë c·ªët truy·ªán
            const plotElements = analyzePlotElements(content);
            
            // Ph√¢n t√≠ch xung ƒë·ªôt
            const conflictAnalysis = analyzeConflict(content);
            
            return {
                structure: structure,
                plotElements: plotElements,
                conflict: conflictAnalysis,
                pacing: analyzePacing(paragraphs),
                climax: identifyClimax(content)
            };
        }

        function analyzeThreeActStructure(paragraphs, totalLength) {
            const act1End = Math.floor(paragraphs.length * 0.25);
            const act2End = Math.floor(paragraphs.length * 0.75);
            
            return {
                act1: {
                    paragraphs: act1End,
                    percentage: '25%',
                    description: 'M·ªü ƒë·∫ßu, gi·ªõi thi·ªáu'
                },
                act2: {
                    paragraphs: act2End - act1End,
                    percentage: '50%',
                    description: 'Ph√°t tri·ªÉn, xung ƒë·ªôt'
                },
                act3: {
                    paragraphs: paragraphs.length - act2End,
                    percentage: '25%',
                    description: 'Cao tr√†o, k·∫øt th√∫c'
                }
            };
        }

        function analyzePlotElements(content) {
            const plotKeywords = {
                'M·ªü ƒë·∫ßu': ['b·∫Øt ƒë·∫ßu', 'kh·ªüi ƒë·∫ßu', 'ng√†y x·ª≠a ng√†y x∆∞a', 'm·ªôt ng√†y', 'c√≥ m·ªôt'],
                'Xung ƒë·ªôt': ['v·∫•n ƒë·ªÅ', 'kh√≥ khƒÉn', 'tr·ªü ng·∫°i', 'th√°ch th·ª©c', 'm√¢u thu·∫´n', 'xung ƒë·ªôt'],
                'Cao tr√†o': ['cu·ªëi c√πng', 'quy·∫øt ƒë·ªãnh', 'quan tr·ªçng', 'then ch·ªët', 'l√∫c n√†y'],
                'Gi·∫£i quy·∫øt': ['gi·∫£i quy·∫øt', 'k·∫øt th√∫c', 'ho√†n th√†nh', 'th√†nh c√¥ng', 'h·∫°nh ph√∫c'],
                'K·∫øt th√∫c': ['cu·ªëi c√πng', 'k·∫øt th√∫c', 't·ª´ ƒë√≥', 'v√† th·∫ø l√†', 'sau ƒë√≥']
            };
            
            const elements = {};
            Object.entries(plotKeywords).forEach(([element, keywords]) => {
                const count = keywords.reduce((acc, keyword) => {
                    return acc + (content.toLowerCase().match(new RegExp(keyword, 'g')) || []).length;
                }, 0);
                elements[element] = count;
            });
            
            return elements;
        }

        function analyzeConflict(content) {
            const conflictTypes = {
                'N·ªôi t√¢m': ['suy nghƒ©', 'bƒÉn khoƒÉn', 'lo l·∫Øng', 'quy·∫øt ƒë·ªãnh', 'l·ª±a ch·ªçn'],
                'Nh√¢n v·∫≠t': ['c√£i nhau', 'tranh c√£i', 'b·∫•t ƒë·ªìng', 'm√¢u thu·∫´n', 'xung ƒë·ªôt'],
                'X√£ h·ªôi': ['x√£ h·ªôi', 'lu·∫≠t ph√°p', 'quy t·∫Øc', 'truy·ªÅn th·ªëng', 'ph·∫£n ƒë·ªëi'],
                'Thi√™n nhi√™n': ['b√£o t·ªë', 'l≈© l·ª•t', 'ƒë·ªông ƒë·∫•t', 'thi√™n tai', 'th·ªùi ti·∫øt']
            };
            
            const conflicts = [];
            Object.entries(conflictTypes).forEach(([type, keywords]) => {
                const mentions = keywords.reduce((count, keyword) => {
                    return count + (content.toLowerCase().match(new RegExp(keyword, 'g')) || []).length;
                }, 0);
                if (mentions > 0) {
                    conflicts.push({ type, mentions });
                }
            });
            
            return conflicts.sort((a, b) => b.mentions - a.mentions);
        }

        function analyzePacing(paragraphs) {
            const avgParagraphLength = paragraphs.reduce((sum, p) => sum + p.split(/\s+/).length, 0) / paragraphs.length;
            
            return {
                averageParagraphLength: Math.round(avgParagraphLength),
                pacing: avgParagraphLength > 100 ? 'Ch·∫≠m' : avgParagraphLength > 50 ? 'V·ª´a ph·∫£i' : 'Nhanh',
                rhythm: paragraphs.length > 10 ? 'Nhi·ªÅu ƒëo·∫°n ng·∫Øn' : '√çt ƒëo·∫°n d√†i'
            };
        }

        function identifyClimax(content) {
            const climaxIndicators = ['ƒë·ªôt nhi√™n', 'b·∫•t ng·ªù', 'l√∫c n√†y', 'cu·ªëi c√πng', 'quy·∫øt ƒë·ªãnh', 'quan tr·ªçng nh·∫•t'];
            const sentences = content.split(/[.!?]+/);
            
            let climaxSentence = '';
            let maxIndicators = 0;
            
            sentences.forEach(sentence => {
                const indicatorCount = climaxIndicators.reduce((count, indicator) => {
                    return count + (sentence.toLowerCase().includes(indicator) ? 1 : 0);
                }, 0);
                
                if (indicatorCount > maxIndicators && sentence.trim().length > 20) {
                    maxIndicators = indicatorCount;
                    climaxSentence = sentence.trim();
                }
            });
            
            return {
                identified: climaxSentence.length > 0,
                sentence: climaxSentence.substring(0, 200) + (climaxSentence.length > 200 ? '...' : ''),
                indicators: maxIndicators
            };
        }

        function analyzeContext(content) {
            // Ph√¢n t√≠ch b·ªëi c·∫£nh th·ªùi gian
            const timeContext = analyzeTimeContext(content);
            
            // Ph√¢n t√≠ch b·ªëi c·∫£nh kh√¥ng gian
            const spaceContext = analyzeSpaceContext(content);
            
            // Ph√¢n t√≠ch b·ªëi c·∫£nh vƒÉn h√≥a
            const culturalContext = analyzeCulturalContext(content);
            
            // Ph√¢n t√≠ch b·ªëi c·∫£nh x√£ h·ªôi
            const socialContext = analyzeSocialContext(content);
            
            return {
                time: timeContext,
                space: spaceContext,
                cultural: culturalContext,
                social: socialContext,
                overall: determineOverallContext(timeContext, spaceContext, culturalContext)
            };
        }

        function analyzeTimeContext(content) {
            const timeKeywords = {
                'Th·ªùi gian trong ng√†y': ['s√°ng', 'tr∆∞a', 'chi·ªÅu', 't·ªëi', 'ƒë√™m', 'r·∫°ng ƒë√¥ng', 'ho√†ng h√¥n'],
                'M√πa trong nƒÉm': ['xu√¢n', 'h·∫°', 'thu', 'ƒë√¥ng', 'm√πa xu√¢n', 'm√πa h√®', 'm√πa thu', 'm√πa ƒë√¥ng'],
                'Th·ªùi ƒë·∫°i': ['x∆∞a', 'c·ªï', 'hi·ªán ƒë·∫°i', 'ng√†y nay', 'th·∫ø k·ª∑', 'th·ªùi phong ki·∫øn', 'th·ªùi chi·∫øn tranh'],
                'Kho·∫£ng th·ªùi gian': ['ng√†y', 'tu·∫ßn', 'th√°ng', 'nƒÉm', 'th·∫≠p k·ª∑', 'm·ªôt th·ªùi gian d√†i']
            };
            
            const timeAnalysis = {};
            Object.entries(timeKeywords).forEach(([category, keywords]) => {
                const mentions = keywords.reduce((count, keyword) => {
                    return count + (content.toLowerCase().match(new RegExp(keyword, 'g')) || []).length;
                }, 0);
                if (mentions > 0) {
                    timeAnalysis[category] = mentions;
                }
            });
            
            return timeAnalysis;
        }

        function analyzeSpaceContext(content) {
            const spaceKeywords = {
                'N√¥ng th√¥n': ['l√†ng', 'qu√™', 'n√¥ng th√¥n', 'c√°nh ƒë·ªìng', 'ru·ªông l√∫a', 'v∆∞·ªùn', 'ao', 's√¥ng nh·ªè'],
                'Th√†nh th·ªã': ['th√†nh ph·ªë', 'ph·ªë', 'ƒë∆∞·ªùng', 't√≤a nh√†', 'si√™u th·ªã', 'c√¥ng vi√™n', 'b·ªánh vi·ªán'],
                'Thi√™n nhi√™n': ['r·ª´ng', 'n√∫i', 'bi·ªÉn', 's√¥ng', 'h·ªì', 'ƒë·ªìi', 'th√°c', 'hang ƒë·ªông'],
                'Trong nh√†': ['nh√†', 'ph√≤ng', 'b·∫øp', 'ph√≤ng ng·ªß', 'ph√≤ng kh√°ch', 's√¢n', 'v∆∞·ªùn nh√†'],
                'C√¥ng c·ªông': ['tr∆∞·ªùng h·ªçc', 'b·ªánh vi·ªán', 'ch√πa', 'ch·ª£', 'c√¥ng vi√™n', 'th∆∞ vi·ªán']
            };
            
            const spaceAnalysis = {};
            Object.entries(spaceKeywords).forEach(([category, keywords]) => {
                const mentions = keywords.reduce((count, keyword) => {
                    return count + (content.toLowerCase().match(new RegExp(keyword, 'g')) || []).length;
                }, 0);
                if (mentions > 0) {
                    spaceAnalysis[category] = mentions;
                }
            });
            
            return spaceAnalysis;
        }

        function analyzeCulturalContext(content) {
            const culturalKeywords = {
                'Truy·ªÅn th·ªëng Vi·ªát Nam': ['t·∫øt', 'trung thu', 'ph·∫≠t', 'ch√πa', 'l·ªÖ h·ªôi', 'b√°nh ch∆∞ng', '√°o d√†i'],
                'Gia ƒë√¨nh truy·ªÅn th·ªëng': ['√¥ng b√†', 't·ªï ti√™n', 'th·ªù c√∫ng', 'hi·∫øu th·∫£o', 'gia ƒë√¨nh ƒë√¥ng con'],
                'VƒÉn h√≥a hi·ªán ƒë·∫°i': ['internet', 'ƒëi·ªán tho·∫°i', 'facebook', 'c√¥ng ngh·ªá', 'to√†n c·∫ßu h√≥a'],
                'Gi√°o d·ª•c': ['h·ªçc h√†nh', 'tri th·ª©c', 's√°ch v·ªü', 'th·∫ßy c√¥', 'ƒë·∫°i h·ªçc', 'b·∫±ng c·∫•p']
            };
            
            const culturalAnalysis = {};
            Object.entries(culturalKeywords).forEach(([category, keywords]) => {
                const mentions = keywords.reduce((count, keyword) => {
                    return count + (content.toLowerCase().match(new RegExp(keyword, 'g')) || []).length;
                }, 0);
                if (mentions > 0) {
                    culturalAnalysis[category] = mentions;
                }
            });
            
            return culturalAnalysis;
        }

        function analyzeSocialContext(content) {
            const socialKeywords = {
                'Giai t·∫ßng x√£ h·ªôi': ['gi√†u', 'ngh√®o', 'trung l∆∞u', 'c√¥ng nh√¢n', 'n√¥ng d√¢n', 'tr√≠ th·ª©c'],
                'Quan h·ªá x√£ h·ªôi': ['c·ªông ƒë·ªìng', 'h√†ng x√≥m', 'b·∫°n b√®', 'ƒë·ªìng nghi·ªáp', 'x√£ h·ªôi'],
                'V·∫•n ƒë·ªÅ x√£ h·ªôi': ['b·∫•t c√¥ng', 'ngh√®o ƒë√≥i', 'th·∫•t nghi·ªáp', 't·ªá n·∫°n', 'tham nh≈©ng']
            };
            
            const socialAnalysis = {};
            Object.entries(socialKeywords).forEach(([category, keywords]) => {
                const mentions = keywords.reduce((count, keyword) => {
                    return count + (content.toLowerCase().match(new RegExp(keyword, 'g')) || []).length;
                }, 0);
                if (mentions > 0) {
                    socialAnalysis[category] = mentions;
                }
            });
            
            return socialAnalysis;
        }

        function determineOverallContext(timeContext, spaceContext, culturalContext) {
            const contexts = [];
            
            // X√°c ƒë·ªãnh b·ªëi c·∫£nh ch√≠nh
            const topTime = Object.entries(timeContext).sort(([,a], [,b]) => b - a)[0];
            const topSpace = Object.entries(spaceContext).sort(([,a], [,b]) => b - a)[0];
            const topCultural = Object.entries(culturalContext).sort(([,a], [,b]) => b - a)[0];
            
            if (topTime) contexts.push(topTime[0]);
            if (topSpace) contexts.push(topSpace[0]);
            if (topCultural) contexts.push(topCultural[0]);
            
            return contexts.join(' - ') || 'Kh√¥ng x√°c ƒë·ªãnh r√µ';
        }

        function analyzeRhetoricalDevices(content) {
            const devices = {};
            
            // Ph√¢n t√≠ch ·∫©n d·ª•
            devices.metaphor = analyzeMetaphor(content);
            
            // Ph√¢n t√≠ch nh√¢n h√≥a
            devices.personification = analyzePersonification(content);
            
            // Ph√¢n t√≠ch so s√°nh
            devices.simile = analyzeSimile(content);
            
            // Ph√¢n t√≠ch l·∫∑p t·ª´
            devices.repetition = analyzeRepetition(content);
            
            // Ph√¢n t√≠ch c√¢u h·ªèi tu t·ª´
            devices.rhetorical_question = analyzeRhetoricalQuestion(content);
            
            // Ph√¢n t√≠ch t∆∞∆°ng ph·∫£n
            devices.contrast = analyzeContrast(content);
            
            return devices;
        }

        function analyzeMetaphor(content) {
            const metaphorIndicators = ['l√†', 'nh∆∞', 't·ª±a nh∆∞', 'gi·ªëng nh∆∞', 'ch√≠nh l√†'];
            const metaphors = [];
            const sentences = content.split(/[.!?]+/);
            
            sentences.forEach(sentence => {
                metaphorIndicators.forEach(indicator => {
                    if (sentence.toLowerCase().includes(indicator)) {
                        const words = sentence.split(/\s+/);
                        if (words.length > 5 && words.length < 20) {
                            metaphors.push(sentence.trim());
                        }
                    }
                });
            });
            
            return {
                count: metaphors.length,
                examples: metaphors.slice(0, 3)
            };
        }

        function analyzePersonification(content) {
            const personificationPatterns = [
                /\b(m·∫∑t tr·ªùi|trƒÉng|gi√≥|n∆∞·ªõc|c√¢y|hoa|l√°)\s+(c∆∞·ªùi|kh√≥c|n√≥i|h√°t|th√¨ th·∫ßm|bu·ªìn|vui)/gi,
                /\b(r·ª´ng|n√∫i|s√¥ng|bi·ªÉn)\s+(g·ªçi|k√™u|la|h√©t|th·ªü)/gi
            ];
            
            const personifications = [];
            personificationPatterns.forEach(pattern => {
                const matches = content.match(pattern);
                if (matches) {
                    personifications.push(...matches);
                }
            });
            
            return {
                count: personifications.length,
                examples: personifications.slice(0, 3)
            };
        }

        function analyzeSimile(content) {
            const similePatterns = [
                /\w+\s+(nh∆∞|t·ª±a|gi·ªëng)\s+\w+/gi,
                /\w+\s+(b·∫±ng|h∆°n)\s+\w+/gi
            ];
            
            const similes = [];
            similePatterns.forEach(pattern => {
                const matches = content.match(pattern);
                if (matches) {
                    similes.push(...matches);
                }
            });
            
            return {
                count: similes.length,
                examples: similes.slice(0, 3)
            };
        }

        function analyzeRepetition(content) {
            const words = content.toLowerCase().split(/\s+/);
            const wordCount = {};
            
            words.forEach(word => {
                const cleanWord = word.replace(/[^\w√†√°·∫°·∫£√£√¢·∫ß·∫•·∫≠·∫©·∫´ƒÉ·∫±·∫Ø·∫∑·∫≥·∫µ√®√©·∫π·∫ª·∫Ω√™·ªÅ·∫ø·ªá·ªÉ·ªÖ√¨√≠·ªã·ªâƒ©√≤√≥·ªç·ªè√µ√¥·ªì·ªë·ªô·ªï·ªó∆°·ªù·ªõ·ª£·ªü·ª°√π√∫·ª•·ªß≈©∆∞·ª´·ª©·ª±·ª≠·ªØ·ª≥√Ω·ªµ·ª∑·ªπƒë]/gi, '');
                if (cleanWord.length > 3 && !vietnameseStopWords.includes(cleanWord)) {
                    wordCount[cleanWord] = (wordCount[cleanWord] || 0) + 1;
                }
            });
            
            const repeatedWords = Object.entries(wordCount)
                .filter(([word, count]) => count >= 3)
                .sort(([,a], [,b]) => b - a)
                .slice(0, 5);
            
            return {
                count: repeatedWords.length,
                words: repeatedWords.map(([word, count]) => ({ word, count }))
            };
        }

        function analyzeRhetoricalQuestion(content) {
            const questions = content.match(/[^.!?]*\?/g) || [];
            const rhetoricalIndicators = ['h√°', 'ch·∫≥ng', 'kh√¥ng ph·∫£i', 'c√≥ ph·∫£i', 'sao'];
            
            const rhetoricalQuestions = questions.filter(q => {
                return rhetoricalIndicators.some(indicator => 
                    q.toLowerCase().includes(indicator)
                );
            });
            
            return {
                totalQuestions: questions.length,
                rhetoricalCount: rhetoricalQuestions.length,
                examples: rhetoricalQuestions.slice(0, 2)
            };
        }

        function analyzeContrast(content) {
            const contrastWords = ['nh∆∞ng', 'tuy nhi√™n', 'tr√°i l·∫°i', 'ng∆∞·ª£c l·∫°i', 'kh√°c v·ªõi', 'm·∫∑t kh√°c'];
            const contrasts = [];
            
            contrastWords.forEach(word => {
                const matches = content.toLowerCase().match(new RegExp(word, 'g'));
                if (matches) {
                    contrasts.push(...matches);
                }
            });
            
            return {
                count: contrasts.length,
                density: (contrasts.length / content.split(/\s+/).length * 100).toFixed(2) + '%'
            };
        }

        function analyzeVocabulary(content) {
            const words = content.toLowerCase().split(/\s+/)
                .map(w => w.replace(/[^\w√†√°·∫°·∫£√£√¢·∫ß·∫•·∫≠·∫©·∫´ƒÉ·∫±·∫Ø·∫∑·∫≥·∫µ√®√©·∫π·∫ª·∫Ω√™·ªÅ·∫ø·ªá·ªÉ·ªÖ√¨√≠·ªã·ªâƒ©√≤√≥·ªç·ªè√µ√¥·ªì·ªë·ªô·ªï·ªó∆°·ªù·ªõ·ª£·ªü·ª°√π√∫·ª•·ªß≈©∆∞·ª´·ª©·ª±·ª≠·ªØ·ª≥√Ω·ªµ·ª∑·ªπƒë]/gi, ''))
                .filter(w => w.length > 2);
            
            // Ph√¢n t√≠ch ƒë·ªô phong ph√∫ t·ª´ v·ª±ng
            const uniqueWords = new Set(words);
            const vocabularyRichness = uniqueWords.size / words.length;
            
            // Ph√¢n t√≠ch ƒë·ªô d√†i t·ª´ trung b√¨nh
            const avgWordLength = words.reduce((sum, word) => sum + word.length, 0) / words.length;
            
            // T·ª´ v·ª±ng chuy√™n ng√†nh
            const specializedVocab = analyzeSpecializedVocabulary(words);
            
            // T·ª´ v·ª±ng c·∫£m x√∫c
            const emotionalVocab = analyzeEmotionalVocabulary(words);
            
            return {
                totalWords: words.length,
                uniqueWords: uniqueWords.size,
                vocabularyRichness: (vocabularyRichness * 100).toFixed(1) + '%',
                averageWordLength: avgWordLength.toFixed(1),
                specializedVocabulary: specializedVocab,
                emotionalVocabulary: emotionalVocab,
                readabilityLevel: determineReadabilityLevel(avgWordLength, vocabularyRichness)
            };
        }

        function analyzeSpecializedVocabulary(words) {
            const specializedCategories = {
                'Y t·∫ø': ['b·ªánh', 'thu·ªëc', 'b√°c sƒ©', 'b·ªánh vi·ªán', 'ƒëi·ªÅu tr·ªã', 'kh√°m', 'ch·ªØa'],
                'Gi√°o d·ª•c': ['h·ªçc', 'gi√°o vi√™n', 'sinh vi√™n', 'b√†i', 'thi', 'ƒëi·ªÉm', 'tr∆∞·ªùng'],
                'C√¥ng ngh·ªá': ['m√°y t√≠nh', 'internet', 'ƒëi·ªán tho·∫°i', 'ph·∫ßn m·ªÅm', 'website'],
                'Kinh t·∫ø': ['ti·ªÅn', 'kinh t·∫ø', 'th∆∞∆°ng m·∫°i', 'ƒë·∫ßu t∆∞', 'l·ª£i nhu·∫≠n', 'doanh nghi·ªáp'],
                'Ch√≠nh tr·ªã': ['ch√≠nh ph·ªß', 'lu·∫≠t', 'ch√≠nh s√°ch', 'nh√† n∆∞·ªõc', 'quy·ªÅn l·ª±c']
            };
            
            const specialized = {};
            Object.entries(specializedCategories).forEach(([category, categoryWords]) => {
                const count = categoryWords.reduce((acc, word) => {
                    return acc + words.filter(w => w.includes(word)).length;
                }, 0);
                if (count > 0) {
                    specialized[category] = count;
                }
            });
            
            return specialized;
        }

        function analyzeEmotionalVocabulary(words) {
            const emotionalCount = {};
            Object.entries(emotionalWords).forEach(([emotion, emotionWords]) => {
                const count = emotionWords.reduce((acc, word) => {
                    return acc + words.filter(w => w.includes(word)).length;
                }, 0);
                emotionalCount[emotion] = count;
            });
            
            return emotionalCount;
        }

        function determineReadabilityLevel(avgWordLength, vocabularyRichness) {
            if (avgWordLength > 6 && vocabularyRichness > 0.7) return 'Kh√≥';
            if (avgWordLength > 5 && vocabularyRichness > 0.5) return 'Trung b√¨nh';
            return 'D·ªÖ';
        }

        // Save and load analysis results
        async function saveAnalysisResults() {
            if (analysisData.length === 0) {
                alert('Kh√¥ng c√≥ d·ªØ li·ªáu ph√¢n t√≠ch ƒë·ªÉ l∆∞u!');
                return;
            }
            
            updateStatus('üíæ ƒêang l∆∞u k·∫øt qu·∫£ ph√¢n t√≠ch...');
            updateProgress(20);
            
            try {
                const analysisReport = {
                    timestamp: new Date().toISOString(),
                    totalFiles: analysisData.length,
                    analysisData: analysisData,
                    summary: generateAnalysisSummary()
                };
                
                // Check if analysis file already exists
                const existingResponse = await gapi.client.drive.files.list({
                    q: `name='${ANALYSIS_CACHE_NAME}' and trashed=false`,
                    fields: 'files(id)'
                });
                
                updateProgress(40);
                
                const analysisContent = JSON.stringify(analysisReport, null, 2);
                
                if (existingResponse.result.files.length > 0) {
                    // Update existing file
                    const fileId = existingResponse.result.files[0].id;
                    await gapi.client.request({
                        path: `https://www.googleapis.com/upload/drive/v3/files/${fileId}`,
                        method: 'PATCH',
                        params: { uploadType: 'media' },
                        headers: { 'Content-Type': 'application/json' },
                        body: analysisContent
                    });
                } else {
                    // Create new file
                    await gapi.client.request({
                        path: 'https://www.googleapis.com/upload/drive/v3/files',
                        method: 'POST',
                        params: { uploadType: 'multipart' },
                        headers: { 'Content-Type': 'multipart/related; boundary="boundary"' },
                        body: createMultipartBody({
                            name: ANALYSIS_CACHE_NAME,
                            description: 'K·∫øt qu·∫£ ph√¢n t√≠ch truy·ªán chi ti·∫øt'
                        }, analysisContent)
                    });
                }
                
                updateProgress(80);
                updateStatus('‚úÖ ƒê√£ l∆∞u k·∫øt qu·∫£ ph√¢n t√≠ch th√†nh c√¥ng');
                updateProgress(100);
                
                setTimeout(() => updateProgress(0), 2000);
                
            } catch (error) {
                console.error('Error saving analysis results:', error);
                updateStatus(`‚ùå L·ªói khi l∆∞u: ${error.message}`);
                updateProgress(0);
            }
        }

        async function loadAnalysisResults() {
            updateStatus('üìÇ ƒêang t√¨m ki·∫øm k·∫øt qu·∫£ ph√¢n t√≠ch ƒë√£ l∆∞u...');
            updateProgress(20);
            
            try {
                const response = await gapi.client.drive.files.list({
                    q: `name='${ANALYSIS_CACHE_NAME}' and trashed=false`,
                    fields: 'files(id, name, modifiedTime)'
                });
                
                if (response.result.files.length === 0) {
                    updateStatus('‚ùå Kh√¥ng t√¨m th·∫•y k·∫øt qu·∫£ ph√¢n t√≠ch ƒë√£ l∆∞u');
                    updateProgress(0);
                    return;
                }
                
                const analysisFile = response.result.files[0];
                updateProgress(50);
                
                // Download analysis content
                const analysisResponse = await gapi.client.drive.files.get({
                    fileId: analysisFile.id,
                    alt: 'media'
                });
                
                updateProgress(70);
                
                const analysisReport = JSON.parse(analysisResponse.body);
                analysisData = analysisReport.analysisData;
                
                updateProgress(90);
                updateStatus(`‚úÖ ƒê√£ t·∫£i k·∫øt qu·∫£ ph√¢n t√≠ch: ${analysisReport.totalFiles} file (c·∫≠p nh·∫≠t: ${new Date(analysisFile.modifiedTime).toLocaleString('vi-VN')})`);
                
                displayAdvancedAnalysisResults();
                document.getElementById('generateBtn').disabled = false;
                document.getElementById('saveAnalysisBtn').disabled = false;
                
                updateProgress(100);
                setTimeout(() => updateProgress(0), 2000);
                
            } catch (error) {
                console.error('Error loading analysis results:', error);
                updateStatus(`‚ùå L·ªói khi t·∫£i: ${error.message}`);
                updateProgress(0);
            }
        }

        function generateAnalysisSummary() {
            const totalWords = analysisData.reduce((sum, analysis) => 
                sum + (analysis.basicStats?.wordCount || 0), 0);
            
            const allThemes = {};
            const allEmotions = {};
            
            analysisData.forEach(analysis => {
                if (analysis.thematicAnalysis?.mainThemes) {
                    analysis.thematicAnalysis.mainThemes.forEach(theme => {
                        allThemes[theme.theme] = (allThemes[theme.theme] || 0) + theme.mentions;
                    });
                }
                
                if (analysis.emotionalAnalysis?.emotionBreakdown) {
                    Object.entries(analysis.emotionalAnalysis.emotionBreakdown).forEach(([emotion, data]) => {
                        allEmotions[emotion] = (allEmotions[emotion] || 0) + data.count;
                    });
                }
            });
            
            return {
                totalWords: totalWords,
                averageWordsPerFile: Math.round(totalWords / analysisData.length),
                topThemes: Object.entries(allThemes).sort(([,a], [,b]) => b - a).slice(0, 5),
                topEmotions: Object.entries(allEmotions).sort(([,a], [,b]) => b - a).slice(0, 3),
                complexityDistribution: analyzeComplexityDistribution()
            };
        }

        function analyzeComplexityDistribution() {
            const complexity = { 'ƒê∆°n gi·∫£n': 0, 'Trung b√¨nh': 0, 'Ph·ª©c t·∫°p': 0 };
            
            analysisData.forEach(analysis => {
                if (analysis.styleAnalysis?.complexity?.overallComplexity) {
                    const level = analysis.styleAnalysis.complexity.overallComplexity;
                    complexity[level] = (complexity[level] || 0) + 1;
                }
            });
            
            return complexity;
        }

        // Display advanced analysis results
        function displayAdvancedAnalysisResults() {
            const container = document.getElementById('analysisResults');
            container.innerHTML = '';
            
            // Add summary statistics
            const summary = generateDisplaySummary();
            container.appendChild(summary);
            
            analysisData.forEach((analysis, index) => {
                if (analysis.error) {
                    container.innerHTML += `
                        <div class="file-card">
                            <div class="file-header">
                                <span class="file-name">‚ùå ${analysis.fileName}</span>
                            </div>
                            <div class="error">L·ªói: ${analysis.error}</div>
                        </div>
                    `;
                    return;
                }
                
                const card = createAnalysisCard(analysis, index);
                container.appendChild(card);
            });
        }

        function generateDisplaySummary() {
            const summary = document.createElement('div');
            summary.className = 'file-card';
            
            const totalFiles = analysisData.filter(a => !a.error).length;
            const totalWords = analysisData.reduce((sum, a) => 
                sum + (a.basicStats?.wordCount || 0), 0);
            const avgWordsPerFile = Math.round(totalWords / totalFiles);
            
            summary.innerHTML = `
                <div class="file-header">
                    <span class="file-name">üìä T·ªïng quan k·∫øt qu·∫£ ph√¢n t√≠ch</span>
                    <small>C·∫≠p nh·∫≠t: ${new Date().toLocaleString('vi-VN')}</small>
                </div>
                <div class="stats-summary">
                    <div class="stat-card">
                        <div class="stat-number">${totalFiles}</div>
                        <div class="stat-label">File ƒë√£ ph√¢n t√≠ch</div>
                    </div>
                    <div class="stat-card">
                        <div class="stat-number">${totalWords.toLocaleString()}</div>
                        <div class="stat-label">T·ªïng t·ª´ v·ª±ng</div>
                    </div>
                    <div class="stat-card">
                        <div class="stat-number">${avgWordsPerFile}</div>
                        <div class="stat-label">Trung b√¨nh t·ª´/file</div>
                    </div>
                    <div class="stat-card">
                        <div class="stat-number">${Math.round(totalWords / 250)}</div>
                        <div class="stat-label">Ph√∫t ƒë·ªçc ∆∞·ªõc t√≠nh</div>
                    </div>
                </div>
            `;
            
            return summary;
        }

        function createAnalysisCard(analysis, index) {
            const card = document.createElement('div');
            card.className = 'file-card';
            
            card.innerHTML = `
                <div class="file-header">
                    <span class="file-name">üìÑ ${analysis.fileName}</span>
                    <small>üìÅ ${analysis.folderPath} | ‚è∞ ${analysis.timestamp}</small>
                </div>
                
                <button class="collapsible" onclick="toggleCollapsible(this)">
                    üìä Th·ªëng k√™ c∆° b·∫£n
                </button>
                <div class="collapsible-content">
                    ${createBasicStatsSection(analysis.basicStats)}
                </div>
                
                <button class="collapsible" onclick="toggleCollapsible(this)">
                    üî§ Ph√¢n t√≠ch ng√¥n ng·ªØ h·ªçc
                </button>
                <div class="collapsible-content">
                    ${createLinguisticSection(analysis.linguisticAnalysis)}
                </div>
                
                <button class="collapsible" onclick="toggleCollapsible(this)">
                    üë• Ph√¢n t√≠ch nh√¢n v·∫≠t
                </button>
                <div class="collapsible-content">
                    ${createCharacterSection(analysis.characterAnalysis)}
                </div>
                
                <button class="collapsible" onclick="toggleCollapsible(this)">
                    üòä Ph√¢n t√≠ch c·∫£m x√∫c
                </button>
                <div class="collapsible-content">
                    ${createEmotionalSection(analysis.emotionalAnalysis)}
                </div>
                
                <button class="collapsible" onclick="toggleCollapsible(this)">
                    üé≠ Ch·ªß ƒë·ªÅ v√† √Ω nghƒ©a
                </button>
                <div class="collapsible-content">
                    ${createThematicSection(analysis.thematicAnalysis)}
                </div>
                
                <button class="collapsible" onclick="toggleCollapsible(this)">
                    ‚úçÔ∏è Phong c√°ch vi·∫øt
                </button>
                <div class="collapsible-content">
                    ${createStyleSection(analysis.styleAnalysis)}
                </div>
                
                <button class="collapsible" onclick="toggleCollapsible(this)">
                    üìñ C·∫•u tr√∫c c·ªët truy·ªán
                </button>
                <div class="collapsible-content">
                    ${createNarrativeSection(analysis.narrativeAnalysis)}
                </div>
                
                <button class="collapsible" onclick="toggleCollapsible(this)">
                    üåç B·ªëi c·∫£nh
                </button>
                <div class="collapsible-content">
                    ${createContextSection(analysis.contextAnalysis)}
                </div>
                
                <button class="collapsible" onclick="toggleCollapsible(this)">
                    üé® Bi·ªán ph√°p tu t·ª´
                </button>
                <div class="collapsible-content">
                    ${createRhetoricSection(analysis.rhetoricAnalysis)}
                </div>
                
                <button class="collapsible" onclick="toggleCollapsible(this)">
                    üìö Ph√¢n t√≠ch t·ª´ v·ª±ng
                </button>
                <div class="collapsible-content">
                    ${createVocabularySection(analysis.vocabularyAnalysis)}
                </div>
                
                <button class="collapsible" onclick="toggleCollapsible(this)">
                    üìù ƒêo·∫°n tr√≠ch g·ªëc
                </button>
                <div class="collapsible-content">
                    <div class="story-output">${analysis.contentSample}</div>
                </div>
            `;
            
            return card;
        }

        // Section creators for different analysis types
        function createBasicStatsSection(stats) {
            if (!stats) return '<p>Kh√¥ng c√≥ d·ªØ li·ªáu th·ªëng k√™ c∆° b·∫£n</p>';
            
            return `
                <div class="analysis-grid">
                    <div class="analysis-item">
                        <h5>üìù S·ªë t·ª´</h5>
                        <p>${stats.wordCount} t·ª´</p>
                    </div>
                    <div class="analysis-item">
                        <h5>üìÑ S·ªë c√¢u</h5>
                        <p>${stats.sentenceCount} c√¢u</p>
                    </div>
                    <div class="analysis-item">
                        <h5>üìë S·ªë ƒëo·∫°n vƒÉn</h5>
                        <p>${stats.paragraphCount} ƒëo·∫°n</p>
                    </div>
                    <div class="analysis-item">
                        <h5>üî§ S·ªë k√Ω t·ª±</h5>
                        <p>${stats.characterCount} k√Ω t·ª±</p>
                    </div>
                    <div class="analysis-item">
                        <h5>üìè Trung b√¨nh t·ª´/c√¢u</h5>
                        <p>${stats.avgWordsPerSentence} t·ª´</p>
                    </div>
                    <div class="analysis-item">
                        <h5>üìä Trung b√¨nh c√¢u/ƒëo·∫°n</h5>
                        <p>${stats.avgSentencesPerParagraph} c√¢u</p>
                    </div>
                </div>
            `;
        }

        function createLinguisticSection(linguistic) {
            if (!linguistic) return '<p>Kh√¥ng c√≥ d·ªØ li·ªáu ph√¢n t√≠ch ng√¥n ng·ªØ</p>';
            
            let html = '<div class="linguistic-chart"><h5>Ph√¢n lo·∫°i t·ª´ lo·∫°i</h5>';
            linguistic.wordTypes.forEach(type => {
                html += `
                    <div class="chart-bar">
                        <div class="chart-label">${type.type}</div>
                        <div class="chart-progress">
                            <div class="chart-fill" style="width: ${type.percentage}"></div>
                        </div>
                        <div class="chart-value">${type.count}</div>
                    </div>
                `;
            });
            html += '</div>';
            
            // Top words
            html += '<div class="linguistic-chart"><h5>T·ª´ xu·∫•t hi·ªán nhi·ªÅu nh·∫•t</h5>';
            html += '<div class="word-cloud">';
            linguistic.topWords.slice(0, 15).forEach(wordData => {
                html += `<span class="word-item">${wordData.word} (${wordData.count})</span>`;
            });
            html += '</div></div>';
            
            // Vocabulary complexity
            html += `
                <div class="analysis-grid">
                    <div class="analysis-item">
                        <h5>ƒê·ªô phong ph√∫ t·ª´ v·ª±ng</h5>
                        <p>${linguistic.uniqueWordRatio}</p>
                    </div>
                    <div class="analysis-item">
                        <h5>ƒê·ªô ph·ª©c t·∫°p t·ª´ v·ª±ng</h5>
                        <p>${linguistic.vocabularyComplexity.lexicalDiversity}</p>
                    </div>
                </div>
            `;
            
            return html;
        }

        function createCharacterSection(characterAnalysis) {
            if (!characterAnalysis || !characterAnalysis.characters) return '<p>Kh√¥ng t√¨m th·∫•y nh√¢n v·∫≠t r√µ r√†ng</p>';
            
            let html = `<p><strong>S·ªë nh√¢n v·∫≠t:</strong> ${characterAnalysis.characterCount}</p>`;
            html += `<p><strong>S·ª± ph√°t tri·ªÉn:</strong> ${characterAnalysis.characterDevelopment}</p>`;
            
            if (characterAnalysis.characters.length > 0) {
                html += '<div class="analysis-grid">';
                characterAnalysis.characters.forEach(char => {
                    html += `
                        <div class="analysis-item">
                            <h5>${char.name}</h5>
                            <p><strong>Xu·∫•t hi·ªán:</strong> ${char.appearances} l·∫ßn</p>
                            <p><strong>Vai tr√≤:</strong> ${char.importance}</p>
                            ${char.traits.length > 0 ? `<p><strong>T√≠nh c√°ch:</strong> ${char.traits.map(t => t.trait).join(', ')}</p>` : ''}
                            ${char.emotions.length > 0 ? `<p><strong>C·∫£m x√∫c:</strong> ${char.emotions.map(e => e.emotion).join(', ')}</p>` : ''}
                        </div>
                    `;
                });
                html += '</div>';
            }
            
            return html;
        }

        function createEmotionalSection(emotional) {
            if (!emotional) return '<p>Kh√¥ng c√≥ d·ªØ li·ªáu c·∫£m x√∫c</p>';
            
            let html = `
                <div class="analysis-grid">
                    <div class="analysis-item">
                        <h5>T√¥ng ƒëi·ªáu t·ªïng th·ªÉ</h5>
                        <p><span class="sentiment-indicator sentiment-${emotional.overallTone === 'T√≠ch c·ª±c' ? 'positive' : emotional.overallTone === 'Ti√™u c·ª±c' ? 'negative' : 'neutral'}"></span>${emotional.overallTone}</p>
                    </div>
                    <div class="analysis-item">
                        <h5>ƒêi·ªÉm c·∫£m x√∫c</h5>
                        <p>${emotional.sentimentScore}%</p>
                    </div>
                    <div class="analysis-item">
                        <h5>C∆∞·ªùng ƒë·ªô c·∫£m x√∫c</h5>
                        <p>${emotional.emotionalIntensity?.intensityLevel || 'Kh√¥ng x√°c ƒë·ªãnh'}</p>
                    </div>
                </div>
            `;
            
            // Emotion breakdown chart
            html += '<div class="linguistic-chart"><h5>Ph√¢n t√≠ch c·∫£m x√∫c chi ti·∫øt</h5>';
            Object.entries(emotional.emotionBreakdown).forEach(([emotion, data]) => {
                if (data.count > 0) {
                    html += `
                        <div class="chart-bar">
                            <div class="chart-label">${emotion}</div>
                            <div class="chart-progress">
                                <div class="chart-fill" style="width: ${data.percentage}"></div>
                            </div>
                            <div class="chart-value">${data.count}</div>
                        </div>
                    `;
                }
            });
            html += '</div>';
            
            // Emotional journey
            if (emotional.emotionalJourney && emotional.emotionalJourney.length > 0) {
                html += '<div class="analysis-item"><h5>H√†nh tr√¨nh c·∫£m x√∫c</h5>';
                emotional.emotionalJourney.forEach(journey => {
                    html += `<span class="tag">Ph·∫ßn ${journey.section}: ${journey.emotion} (${journey.intensity})</span>`;
                });
                html += '</div>';
            }
            
            return html;
        }

        function createThematicSection(thematic) {
            if (!thematic || !thematic.mainThemes) return '<p>Kh√¥ng c√≥ d·ªØ li·ªáu ch·ªß ƒë·ªÅ</p>';
            
            let html = `<p><strong>ƒê·ªô ph·ª©c t·∫°p ch·ªß ƒë·ªÅ:</strong> ${thematic.thematicComplexity}</p>`;
            
            if (thematic.mainThemes.length > 0) {
                html += '<div class="linguistic-chart"><h5>Ch·ªß ƒë·ªÅ ch√≠nh</h5>';
                thematic.mainThemes.forEach(theme => {
                    const percentage = (theme.mentions * 5).toString(); // Scale for visualization
                    html += `
                        <div class="chart-bar">
                            <div class="chart-label">${theme.theme}</div>
                            <div class="chart-progress">
                                <div class="chart-fill" style="width: ${Math.min(percentage, 100)}%"></div>
                            </div>
                            <div class="chart-value">${theme.mentions}</div>
                        </div>
                    `;
                });
                html += '</div>';
            }
            
            return html;
        }

        function createStyleSection(style) {
            if (!style) return '<p>Kh√¥ng c√≥ d·ªØ li·ªáu phong c√°ch</p>';
            
            return `
                <div class="analysis-grid">
                    <div class="analysis-item">
                        <h5>G√≥c nh√¨n</h5>
                        <p>${style.perspective}</p>
                    </div>
                    <div class="analysis-item">
                        <h5>Gi·ªçng ƒëi·ªáu</h5>
                        <p>${style.tone?.formality || 'Kh√¥ng x√°c ƒë·ªãnh'}</p>
                    </div>
                    <div class="analysis-item">
                        <h5>ƒê·ªô ph·ª©c t·∫°p</h5>
                        <p>${style.complexity?.overallComplexity || 'Kh√¥ng x√°c ƒë·ªãnh'}</p>
                    </div>
                    <div class="analysis-item">
                        <h5>ƒê·ªô d√†i c√¢u TB</h5>
                        <p>${style.averageSentenceLength} t·ª´</p>
                    </div>
                    <div class="analysis-item">
                        <h5>Phong c√°ch vi·∫øt</h5>
                        <p>${style.writingStyle}</p>
                    </div>
                    <div class="analysis-item">
                        <h5>T√≠nh bi·ªÉu c·∫£m</h5>
                        <p>${style.tone?.expressiveness || 'Kh√¥ng x√°c ƒë·ªãnh'}</p>
                    </div>
                </div>
            `;
        }

        function createNarrativeSection(narrative) {
            if (!narrative) return '<p>Kh√¥ng c√≥ d·ªØ li·ªáu c·ªët truy·ªán</p>';
            
            let html = '';
            
            // Plot structure
            if (narrative.structure) {
                html += '<div class="linguistic-chart"><h5>C·∫•u tr√∫c ba h·ªìi</h5>';
                Object.entries(narrative.structure).forEach(([act, info]) => {
                    html += `
                        <div class="chart-bar">
                            <div class="chart-label">${act.toUpperCase()}</div>
                            <div class="chart-progress">
                                <div class="chart-fill" style="width: ${info.percentage}"></div>
                            </div>
                            <div class="chart-value">${info.paragraphs}</div>
                        </div>
                    `;
                });
                html += '</div>';
            }
            
            // Plot elements and pacing
            html += `
                <div class="analysis-grid">
                    <div class="analysis-item">
                        <h5>Nh·ªãp ƒë·ªô</h5>
                        <p>${narrative.pacing?.pacing || 'Kh√¥ng x√°c ƒë·ªãnh'}</p>
                    </div>
                    <div class="analysis-item">
                        <h5>C·∫•u tr√∫c ƒëo·∫°n vƒÉn</h5>
                        <p>${narrative.pacing?.rhythm || 'Kh√¥ng x√°c ƒë·ªãnh'}</p>
                    </div>
                </div>
            `;
            
            // Conflicts
            if (narrative.conflict && narrative.conflict.length > 0) {
                html += '<div class="analysis-item"><h5>Lo·∫°i xung ƒë·ªôt</h5>';
                narrative.conflict.forEach(conflict => {
                    html += `<span class="tag">${conflict.type} (${conflict.mentions})</span>`;
                });
                html += '</div>';
            }
            
            // Climax
            if (narrative.climax?.identified) {
                html += `
                    <div class="analysis-item">
                        <h5>Cao tr√†o ƒë∆∞·ª£c x√°c ƒë·ªãnh</h5>
                        <p style="font-style: italic; background: #f8f9fa; padding: 10px; border-radius: 5px;">
                            "${narrative.climax.sentence}"
                        </p>
                    </div>
                `;
            }
            
            return html;
        }

        function createContextSection(context) {
            if (!context) return '<p>Kh√¥ng c√≥ d·ªØ li·ªáu b·ªëi c·∫£nh</p>';
            
            let html = `<p><strong>B·ªëi c·∫£nh t·ªïng th·ªÉ:</strong> ${context.overall}</p>`;
            
            // Time context
            if (context.time && Object.keys(context.time).length > 0) {
                html += '<div class="analysis-item"><h5>B·ªëi c·∫£nh th·ªùi gian</h5>';
                Object.entries(context.time).forEach(([category, count]) => {
                    html += `<span class="tag">${category}: ${count}</span>`;
                });
                html += '</div>';
            }
            
            // Space context
            if (context.space && Object.keys(context.space).length > 0) {
                html += '<div class="analysis-item"><h5>B·ªëi c·∫£nh kh√¥ng gian</h5>';
                Object.entries(context.space).forEach(([category, count]) => {
                    html += `<span class="tag">${category}: ${count}</span>`;
                });
                html += '</div>';
            }
            
            // Cultural context
            if (context.cultural && Object.keys(context.cultural).length > 0) {
                html += '<div class="analysis-item"><h5>B·ªëi c·∫£nh vƒÉn h√≥a</h5>';
                Object.entries(context.cultural).forEach(([category, count]) => {
                    html += `<span class="tag">${category}: ${count}</span>`;
                });
                html += '</div>';
            }
            
            return html;
        }

        function createRhetoricSection(rhetoric) {
            if (!rhetoric) return '<p>Kh√¥ng c√≥ d·ªØ li·ªáu tu t·ª´</p>';
            
            return `
                <div class="analysis-grid">
                    <div class="analysis-item">
                        <h5>·∫®n d·ª•</h5>
                        <p>${rhetoric.metaphor?.count || 0} l·∫ßn</p>
                        ${rhetoric.metaphor?.examples ? `<small>${rhetoric.metaphor.examples.slice(0, 1).join(', ')}</small>` : ''}
                    </div>
                    <div class="analysis-item">
                        <h5>Nh√¢n h√≥a</h5>
                        <p>${rhetoric.personification?.count || 0} l·∫ßn</p>
                        ${rhetoric.personification?.examples ? `<small>${rhetoric.personification.examples.slice(0, 1).join(', ')}</small>` : ''}
                    </div>
                    <div class="analysis-item">
                        <h5>So s√°nh</h5>
                        <p>${rhetoric.simile?.count || 0} l·∫ßn</p>
                    </div>
                    <div class="analysis-item">
                        <h5>L·∫∑p t·ª´</h5>
                        <p>${rhetoric.repetition?.count || 0} t·ª´</p>
                        ${rhetoric.repetition?.words ? `<small>${rhetoric.repetition.words.slice(0, 3).map(w => w.word).join(', ')}</small>` : ''}
                    </div>
                    <div class="analysis-item">
                        <h5>C√¢u h·ªèi tu t·ª´</h5>
                        <p>${rhetoric.rhetorical_question?.rhetoricalCount || 0}/${rhetoric.rhetorical_question?.totalQuestions || 0}</p>
                    </div>
                    <div class="analysis-item">
                        <h5>T∆∞∆°ng ph·∫£n</h5>
                        <p>${rhetoric.contrast?.count || 0} (${rhetoric.contrast?.density || '0%'})</p>
                    </div>
                </div>
            `;
        }

        function createVocabularySection(vocab) {
            if (!vocab) return '<p>Kh√¥ng c√≥ d·ªØ li·ªáu t·ª´ v·ª±ng</p>';
            
            let html = `
                <div class="analysis-grid">
                    <div class="analysis-item">
                        <h5>T·ªïng t·ª´ v·ª±ng</h5>
                        <p>${vocab.totalWords}</p>
                    </div>
                    <div class="analysis-item">
                        <h5>T·ª´ duy nh·∫•t</h5>
                        <p>${vocab.uniqueWords}</p>
                    </div>
                    <div class="analysis-item">
                        <h5>ƒê·ªô phong ph√∫</h5>
                        <p>${vocab.vocabularyRichness}</p>
                    </div>
                    <div class="analysis-item">
                        <h5>ƒê·ªô d√†i t·ª´ TB</h5>
                        <p>${vocab.averageWordLength}</p>
                    </div>
                    <div class="analysis-item">
                        <h5>ƒê·ªô kh√≥ ƒë·ªçc</h5>
                        <p>${vocab.readabilityLevel}</p>
                    </div>
                </div>
            `;
            
            // Specialized vocabulary
            if (vocab.specializedVocabulary && Object.keys(vocab.specializedVocabulary).length > 0) {
                html += '<div class="analysis-item"><h5>T·ª´ v·ª±ng chuy√™n ng√†nh</h5>';
                Object.entries(vocab.specializedVocabulary).forEach(([category, count]) => {
                    html += `<span class="tag">${category}: ${count}</span>`;
                });
                html += '</div>';
            }
            
            return html;
        }

        // Utility functions
        function toggleCollapsible(element) {
            element.classList.toggle('active');
            const content = element.nextElementSibling;
            content.classList.toggle('active');
        }

        function updateStatus(message) {
            document.getElementById('statusInfo').innerHTML = `<p>${message}</p>`;
        }

        function updateProgress(percent) {
            document.getElementById('progressBar').style.width = percent + '%';
        }

        function createMultipartBody(metadata, data) {
            const delimiter = 'boundary';
            let body = '';
            
            body += `--${delimiter}\r\n`;
            body += 'Content-Type: application/json\r\n\r\n';
            body += JSON.stringify(metadata) + '\r\n';
            body += `--${delimiter}\r\n`;
            body += 'Content-Type: text/plain\r\n\r\n';
            body += data + '\r\n';
            body += `--${delimiter}--`;
            
            return body;
        }

        // Existing functions from the original code (scan, cache, etc.)
        async function clearCache() {
            const confirmClear = confirm('B·∫°n c√≥ ch·∫Øc ch·∫Øn mu·ªën x√≥a cache v√† qu√©t l·∫°i kh√¥ng?');
            if (!confirmClear) return;
            
            updateStatus('üóëÔ∏è ƒêang x√≥a cache...');
            updateProgress(20);
            
            try {
                const response = await gapi.client.drive.files.list({
                    q: `name='${CACHE_FILE_NAME}' and trashed=false`,
                    fields: 'files(id)'
                });
                
                if (response.result.files.length > 0) {
                    await gapi.client.drive.files.delete({
                        fileId: response.result.files[0].id
                    });
                }
                
                updateProgress(50);
                updateStatus('‚úÖ ƒê√£ x√≥a cache, b·∫Øt ƒë·∫ßu qu√©t m·ªõi...');
                
                scanCache = {};
                window.txtFiles = [];
                
                updateProgress(70);
                setTimeout(() => scanFolder(), 1000);
                
            } catch (error) {
                console.error('Error clearing cache:', error);
                updateStatus(`‚ùå L·ªói x√≥a cache: ${error.message}`);
                updateProgress(0);
            }
        }

        async function scanFolder() {
            updateProgress(5);
            updateStatus('üîç Ki·ªÉm tra cache qu√©t tr∆∞·ªõc ƒë√≥...');
            
            try {
                const cacheExists = await checkCacheExists();
                if (cacheExists) {
                    const useCache = confirm('ƒê√£ t√¨m th·∫•y k·∫øt qu·∫£ qu√©t tr∆∞·ªõc ƒë√≥. B·∫°n c√≥ mu·ªën s·ª≠ d·ª•ng cache kh√¥ng?\n(Ch·ªçn "Cancel" ƒë·ªÉ qu√©t l·∫°i to√†n b·ªô)');
                    if (useCache) {
                        await loadFromCache();
                        return;
                    }
                }
                
                updateProgress(10);
                updateStatus('üîç ƒêang qu√©t th∆∞ m·ª•c QuanLyTruyen v√† t·∫•t c·∫£ th∆∞ m·ª•c con...');
                
                const folderResponse = await gapi.client.drive.files.list({
                    q: "name='QuanLyTruyen' and mimeType='application/vnd.google-apps.folder'",
                    fields: 'files(id, name)'
                });
                
                if (folderResponse.result.files.length === 0) {
                    throw new Error('Kh√¥ng t√¨m th·∫•y th∆∞ m·ª•c QuanLyTruyen');
                }
                
                const folderId = folderResponse.result.files[0].id;
                updateProgress(20);
                
                updateStatus('üîç Qu√©t ƒë·ªá quy t·∫•t c·∫£ th∆∞ m·ª•c con...');
                const allTxtFiles = await scanFolderRecursive(folderId);
                
                updateProgress(80);
                updateStatus(`‚úÖ T√¨m th·∫•y ${allTxtFiles.length} file txt trong t·∫•t c·∫£ th∆∞ m·ª•c con`);
                
                window.txtFiles = allTxtFiles;
                scanCache = {
                    timestamp: new Date().toISOString(),
                    totalFiles: allTxtFiles.length,
                    files: allTxtFiles,
                    folderStructure: await buildFolderStructure(folderId)
                };
                
                await saveCacheToGoogleDrive();
                
                document.getElementById('analyzeBtn').disabled = false;
                updateProgress(100);
                
                displayScanResults(allTxtFiles);
                setTimeout(() => updateProgress(0), 2000);
                
            } catch (error) {
                console.error('Error scanning folder:', error);
                updateStatus(`‚ùå L·ªói: ${error.message}`);
                updateProgress(0);
            }
        }

        async function scanFolderRecursive(folderId, depth = 0, maxDepth = 10) {
            if (depth > maxDepth) {
                console.warn(`ƒê·∫°t ƒë·ªô s√¢u t·ªëi ƒëa ${maxDepth}, d·ª´ng qu√©t`);
                return [];
            }
            
            let allFiles = [];
            let nextPageToken = null;
            
            do {
                const response = await gapi.client.drive.files.list({
                    q: `'${folderId}' in parents and trashed=false`,
                    fields: 'nextPageToken, files(id, name, parents, mimeType, size, modifiedTime)',
                    pageSize: 200,
                    pageToken: nextPageToken
                });
                
                const items = response.result.files;
                nextPageToken = response.result.nextPageToken;
                
                for (const item of items) {
                    if (item.mimeType === 'text/plain' && item.name.endsWith('.txt')) {
                        const folderPath = await getFolderPath(item.parents[0]);
                        allFiles.push({
                            ...item,
                            folderPath: folderPath
                        });
                    } else if (item.mimeType === 'application/vnd.google-apps.folder') {
                        updateStatus(`üîç ƒêang qu√©t th∆∞ m·ª•c: ${item.name} (ƒë·ªô s√¢u ${depth + 1})`);
                        const subFiles = await scanFolderRecursive(item.id, depth + 1, maxDepth);
                        allFiles = allFiles.concat(subFiles);
                    }
                }
                
            } while (nextPageToken && allFiles.length < 200);
            
            return allFiles;
        }

        async function getFolderPath(folderId) {
            try {
                const response = await gapi.client.drive.files.get({
                    fileId: folderId,
                    fields: 'name, parents'
                });
                
                const folder = response.result;
                if (!folder.parents || folder.name === 'QuanLyTruyen') {
                    return folder.name;
                }
                
                const parentPath = await getFolderPath(folder.parents[0]);
                return `${parentPath}/${folder.name}`;
            } catch (error) {
                console.error('Error getting folder path:', error);
                return 'Unknown';
            }
        }

        async function buildFolderStructure(folderId, depth = 0) {
            if (depth > 5) return {};
            
            const structure = {};
            
            try {
                const response = await gapi.client.drive.files.list({
                    q: `'${folderId}' in parents and mimeType='application/vnd.google-apps.folder' and trashed=false`,
                    fields: 'files(id, name)',
                    pageSize: 100
                });
                
                for (const folder of response.result.files) {
                    structure[folder.name] = {
                        id: folder.id,
                        subfolders: await buildFolderStructure(folder.id, depth + 1)
                    };
                }
            } catch (error) {
                console.error('Error building folder structure:', error);
            }
            
            return structure;
        }

        function displayScanResults(files) {
            const container = document.getElementById('analysisResults');
            
            const filesByFolder = {};
            files.forEach(file => {
                const folder = file.folderPath || 'Unknown';
                if (!filesByFolder[folder]) {
                    filesByFolder[folder] = [];
                }
                filesByFolder[folder].push(file);
            });
            
            let html = `
                <div class="file-card">
                    <div class="file-header">
                        <span class="file-name">üìä K·∫øt qu·∫£ qu√©t th∆∞ m·ª•c</span>
                        <small>T·ªïng c·ªông: ${files.length} file txt</small>
                    </div>
                    <div class="analysis-content">
                        <h4>üìÅ Ph√¢n b·ªë file theo th∆∞ m·ª•c:</h4>
            `;
            
            Object.entries(filesByFolder).forEach(([folder, folderFiles]) => {
                html += `
                    <div style="margin: 10px 0; padding: 10px; background: #f8f9fa; border-radius: 5px;">
                        <strong>üìÇ ${folder}</strong> (${folderFiles.length} file)
                        <ul style="margin: 5px 0 0 20px;">
                `;
                
                folderFiles.slice(0, 10).forEach(file => {
                    const size = file.size ? Math.round(file.size / 1024) + 'KB' : 'N/A';
                    const date = file.modifiedTime ? new Date(file.modifiedTime).toLocaleDateString('vi-VN') : 'N/A';
                    html += `<li>${file.name} (${size}, ${date})</li>`;
                });
                
                if (folderFiles.length > 10) {
                    html += `<li><em>... v√† ${folderFiles.length - 10} file kh√°c</em></li>`;
                }
                
                html += `</ul></div>`;
            });
            
            html += `</div></div>`;
            container.innerHTML = html;
        }

        async function checkCacheExists() {
            try {
                const response = await gapi.client.drive.files.list({
                    q: `name='${CACHE_FILE_NAME}' and trashed=false`,
                    fields: 'files(id, name, modifiedTime)'
                });
                
                return response.result.files.length > 0;
            } catch (error) {
                console.error('Error checking cache:', error);
                return false;
            }
        }

        async function loadFromCache() {
            updateProgress(20);
            updateStatus('üìÇ ƒêang t·∫£i cache t·ª´ Google Drive...');
            
            try {
                const response = await gapi.client.drive.files.list({
                    q: `name='${CACHE_FILE_NAME}' and trashed=false`,
                    fields: 'files(id, name, modifiedTime)'
                });
                
                if (response.result.files.length === 0) {
                    throw new Error('Kh√¥ng t√¨m th·∫•y file cache');
                }
                
                const cacheFile = response.result.files[0];
                updateProgress(50);
                
                const cacheResponse = await gapi.client.drive.files.get({
                    fileId: cacheFile.id,
                    alt: 'media'
                });
                
                updateProgress(70);
                
                const cacheData = JSON.parse(cacheResponse.body);
                scanCache = cacheData;
                window.txtFiles = cacheData.files;
                
                updateProgress(90);
                updateStatus(`‚úÖ ƒê√£ t·∫£i cache th√†nh c√¥ng: ${cacheData.totalFiles} file (c·∫≠p nh·∫≠t: ${new Date(cacheFile.modifiedTime).toLocaleString('vi-VN')})`);
                
                document.getElementById('analyzeBtn').disabled = false;
                displayScanResults(cacheData.files);
                updateProgress(100);
                
                setTimeout(() => updateProgress(0), 2000);
                
            } catch (error) {
                console.error('Error loading cache:', error);
                updateStatus(`‚ùå L·ªói t·∫£i cache: ${error.message}`);
                await scanFolder();
            }
        }

        async function saveCacheToGoogleDrive() {
            updateProgress(85);
            updateStatus('üíæ ƒêang l∆∞u cache qu√©t...');
            
            try {
                const existingResponse = await gapi.client.drive.files.list({
                    q: `name='${CACHE_FILE_NAME}' and trashed=false`,
                    fields: 'files(id)'
                });
                
                const cacheContent = JSON.stringify(scanCache, null, 2);
                
                if (existingResponse.result.files.length > 0) {
                    const fileId = existingResponse.result.files[0].id;
                    await gapi.client.request({
                        path: `https://www.googleapis.com/upload/drive/v3/files/${fileId}`,
                        method: 'PATCH',
                        params: { uploadType: 'media' },
                        headers: { 'Content-Type': 'application/json' },
                        body: cacheContent
                    });
                } else {
                    await gapi.client.request({
                        path: 'https://www.googleapis.com/upload/drive/v3/files',
                        method: 'POST',
                        params: { uploadType: 'multipart' },
                        headers: { 'Content-Type': 'multipart/related; boundary="boundary"' },
                        body: createMultipartBody({
                            name: CACHE_FILE_NAME,
                            description: 'Cache file for QuanLyTruyen scanner'
                        }, cacheContent)
                    });
                }
                
                updateProgress(95);
                updateStatus('‚úÖ ƒê√£ l∆∞u cache th√†nh c√¥ng');
                
            } catch (error) {
                console.error('Error saving cache:', error);
                updateStatus('‚ö†Ô∏è Kh√¥ng th·ªÉ l∆∞u cache, nh∆∞ng qu√©t v·∫´n th√†nh c√¥ng');
            }
        }

        // Story generation and saving functions (simplified versions of original)
        async function generateStories() {
            alert('T√≠nh nƒÉng t·∫°o truy·ªán s·∫Ω ƒë∆∞·ª£c tri·ªÉn khai sau khi ho√†n th√†nh ph√¢n t√≠ch chi ti·∫øt.');
        }

        async function saveToGoogleDrive() {
            alert('T√≠nh nƒÉng l∆∞u truy·ªán s·∫Ω ƒë∆∞·ª£c tri·ªÉn khai sau khi ho√†n th√†nh t·∫°o truy·ªán.');
        }

        // Initialize when page loads
        window.onload = function() {
            if (typeof gapi !== 'undefined') {
                gapiLoaded();
            }
            if (typeof google !== 'undefined') {
                gisLoaded();
            }
            
            updateStatus('üî¥ Ch∆∞a k·∫øt n·ªëi Google Drive');
        };

        // Make toggleCollapsible globally accessible
        window.toggleCollapsible = toggleCollapsible;
    </script>
</body>
</html>
