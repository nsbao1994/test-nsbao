<!doctype html>
<html lang="vi">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover" />
  <title>Qu·∫£n L√Ω Truy·ªán ‚Äî Drive + ml5 + 50 ch∆∞∆°ng (GIS)</title>

  <!-- Google Identity Services (m·ªõi) + Google API Client -->
  <script src="https://accounts.google.com/gsi/client" async defer></script>
  <script async defer src="https://apis.google.com/js/api.js"></script>
  <!-- ml5.js sentiment -->
  <script src="https://unpkg.com/ml5@0.12.2/dist/ml5.min.js"></script>

  <style>
    :root{ --bg:#0a0f14; --card:#0f1620; --text:#e6eef7; --muted:#9ab0c8; --accent:#4ea1ff; --line:#203047; --good:#25c059; --warn:#f0b429; --bad:#ff6b6b; }
    *{box-sizing:border-box}
    html,body{height:100%}
    body{ margin:0; font-family:system-ui,-apple-system,Segoe UI,Roboto,Helvetica,Arial; background:linear-gradient(180deg,#0a0f14,#101827); color:var(--text); padding-bottom:76px; }
    header{position:sticky;top:0;z-index:50; backdrop-filter:saturate(1.2) blur(6px); background:rgba(10,15,20,.7); border-bottom:1px solid var(--line); display:flex; align-items:center; justify-content:space-between; gap:12px; padding:16px 16px 12px;}
    h1{margin:0; font-size:16px; font-weight:600}
    .btn{border:1px solid var(--line); background:#0d1420; color:var(--text); padding:10px 14px; border-radius:12px; cursor:pointer; transition:.15s ease; font-weight:600}
    .btn:hover{border-color:var(--accent); transform:translateY(-1px)}
    .btn.primary{background:linear-gradient(180deg,#16263b,#0f1a2a); border-color:#2f4d78}
    .wrap{max-width:980px; margin:0 auto; padding:14px 14px 24px}
    .card{background:var(--card); border:1px solid var(--line); border-radius:16px; padding:16px; margin-top:14px}
    .row{display:grid; grid-template-columns:1fr; gap:14px}
    @media(min-width:960px){ .row{grid-template-columns:1.1fr .9fr} }
    label{display:block; font-size:12px; color:var(--muted); margin-bottom:6px}
    input[type="number"], input[type="text"], textarea, select{ width:100%; padding:12px 12px; border-radius:12px; border:1px solid #1b283c; background:#0c1420; color:var(--text); -webkit-appearance:none; appearance:none; }
    textarea{min-height:160px; resize:vertical; line-height:1.55}
    .muted{color:var(--muted)}
    .pill{display:inline-flex; align-items:center; gap:6px; padding:6px 10px; border-radius:999px; background:#0e2034; border:1px solid #183654; color:#b9d7ff; font-size:12px; margin:2px 6px 2px 0}
    .progress{height:10px; background:#0b1420; border-radius:8px; overflow:hidden; border:1px solid #1c2b42}
    .bar{height:100%; width:0%; background:linear-gradient(90deg,#4ea1ff,#7bd4ff)}
    .status{font-size:13px}
    .list{font-family:ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas; font-size:13px; white-space:pre-wrap}
    .grid2{display:grid; grid-template-columns:1fr 1fr; gap:10px}
    .grid3{display:grid; grid-template-columns:1fr 1fr 1fr; gap:10px}
    .kbd{font-family:ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas; background:#0d1520; border:1px solid #21324a; padding:3px 6px; border-radius:6px}
    .bottom-nav{position:fixed; bottom:0; left:0; right:0; z-index:60; background:rgba(9,14,20,.8); backdrop-filter:saturate(1.2) blur(8px); border-top:1px solid var(--line); display:flex; height:64px; padding-bottom:env(safe-area-inset-bottom);} .tab{flex:1; display:flex; flex-direction:column; align-items:center; justify-content:center; gap:4px; color:var(--muted); font-size:11px; cursor:pointer; user-select:none} .tab.active{color:#d6e7ff}
    .page{display:none} .page.active{display:block}
  </style>
</head>
<body>
<header>
  <h1>üìö Qu·∫£n L√Ω Truy·ªán ‚Äî Google Drive + ml5 (GIS)</h1>
  <div style="display:flex; gap:8px; align-items:center">
    <button id="signin" class="btn">ƒêƒÉng nh·∫≠p Google</button>
    <button id="signout" class="btn" style="display:none">ƒêƒÉng xu·∫•t</button>
  </div>
</header>

<div class="wrap">
  <div class="card">
    <div style="display:flex; gap:10px; align-items:center; flex-wrap:wrap">
      <div class="pill">Th∆∞ m·ª•c g·ªëc: <b>QuanLyTruyen</b></div>
      <div class="pill" id="authState">Ch∆∞a ƒëƒÉng nh·∫≠p</div>
      <div class="pill" id="qltState">Ch∆∞a t·∫£i d·ªØ li·ªáu</div>
      <div class="status" id="status"></div>
    </div>
    <div class="progress" style="margin-top:10px"><div class="bar" id="bar"></div></div>
  </div>

  <!-- PAGE: D·ªÆ LI·ªÜU -->
  <section id="page-data" class="page active">
    <div class="row">
      <div class="card">
        <h3 style="margin:0 0 8px">1) N·∫°p d·ªØ li·ªáu t·ª´ Drive</h3>
        <div class="grid3">
          <div>
            <label>Gi·ªõi h·∫°n s·ªë file</label>
            <input id="maxFiles" type="number" value="200" min="1" />
          </div>
          <div>
            <label>K√≠ch th∆∞·ªõc t·ªëi ƒëa t·∫£i (MB)</label>
            <input id="maxMB" type="number" value="50" min="1" />
          </div>
          <div>
            <label>Ch·ªâ l·∫•y trong th∆∞ m·ª•c con</label>
            <input id="subFolder" type="text" placeholder="(tu·ª≥ ch·ªçn) V√≠ d·ª•: TruyenNguon" />
          </div>
        </div>
        <div style="margin-top:10px; display:flex; gap:10px; flex-wrap:wrap">
          <button id="loadTexts" class="btn primary">T·∫£i .txt trong ‚ÄúQuanLyTruyen‚Äù</button>
          <button id="clearAll" class="btn">Xo√° d·ªØ li·ªáu trong RAM</button>
          <button id="saveCache" class="btn">L∆∞u cache ph√¢n t√≠ch l√™n Drive</button>
          <button id="loadCache" class="btn">T·∫£i cache ph√¢n t√≠ch</button>
        </div>
        <div class="footer muted" style="margin-top:8px">C·∫ßn quy·ªÅn: <span class="kbd">drive.readonly</span> + <span class="kbd">drive.file</span> ƒë·ªÉ l∆∞u cache/ch∆∞∆°ng.</div>
        <div id="filesInfo" class="muted" style="margin-top:10px"></div>
        <textarea id="corpusPreview" placeholder="Xem tr∆∞·ªõc v√†i ƒëo·∫°n ƒë√£ n·∫°p..."></textarea>
      </div>

      <div class="card">
        <h3 style="margin:0 0 8px">2) Ph√¢n t√≠ch n√¢ng cao (ti·∫øng Vi·ªát + sentiment)</h3>
        <div style="display:flex; gap:10px; flex-wrap:wrap">
          <button id="analyze" class="btn">Ph√¢n t√≠ch</button>
          <button id="exportStats" class="btn">Xu·∫•t JSON th·ªëng k√™</button>
        </div>
        <div id="analysis" class="list" style="margin-top:10px"></div>
      </div>
    </div>
  </section>

  <!-- PAGE: VI·∫æT TRUY·ªÜN -->
  <section id="page-write" class="page">
    <div class="card">
      <h3 style="margin:0 0 8px">3) Vi·∫øt truy·ªán 50 ch∆∞∆°ng (ng√¥i th·ª© nh·∫•t)</h3>
      <div class="grid3">
        <div>
          <label>M·ª•c ti√™u t·ª´ m·ªói ch∆∞∆°ng</label>
          <input id="wordsPerChapter" type="number" value="2300" min="1200" max="4000" />
        </div>
        <div>
          <label>B·∫≠c Markov (n-gram theo t·ª´)</label>
          <input id="order" type="number" value="3" min="1" max="5" />
        </div>
        <div>
          <label>C·∫£m x√∫c m·ª•c ti√™u (‚àí1‚Ä¶+1)</label>
          <input id="targetSentiment" type="number" step="0.1" min="-1" max="1" value="0.1" />
        </div>
      </div>
      <div class="grid2" style="margin-top:10px">
        <div>
          <label>H·∫°t gi·ªëng m·ªü truy·ªán (t√πy ch·ªçn)</label>
          <input id="seed" type="text" placeholder="V√≠ d·ª•: 'T√¥i t·ªânh d·∫≠y gi·ªØa ƒë√™m m∆∞a...'" />
        </div>
        <div>
          <label>T√™n truy·ªán (ƒë·ªÉ tr·ªëng ƒë·ªÉ AI t·ª± ƒë·∫∑t)</label>
          <input id="titleInput" type="text" placeholder="AI s·∫Ω t·ª± ƒë·ªÅ xu·∫•t" />
        </div>
      </div>
      <div style="margin-top:10px; display:flex; gap:10px; flex-wrap:wrap">
        <button id="generateOutline" class="btn">T·∫°o d√†n √Ω 50 ch∆∞∆°ng</button>
        <button id="startBook" class="btn primary">B·∫Øt ƒë·∫ßu sinh & upload 50 ch∆∞∆°ng</button>
        <button id="cancelGen" class="btn">Hu·ª∑</button>
      </div>
      <div class="progress" style="margin-top:10px"><div class="bar" id="bookBar"></div></div>
      <div id="bookStatus" class="list" style="margin-top:10px"></div>
      <textarea id="outlineBox" placeholder="D√†n √Ω 50 ch∆∞∆°ng s·∫Ω hi·ªÉn th·ªã t·∫°i ƒë√¢y..."></textarea>
    </div>
  </section>

  <!-- PAGE: TH√äM TRUY·ªÜN -->
  <section id="page-add" class="page">
    <div class="card">
      <h3 style="margin:0 0 8px">4) Th√™m truy·ªán</h3>
      <div class="grid2">
        <div>
          <h4 style="margin:6px 0">T·∫°o th∆∞ m·ª•c truy·ªán m·ªõi</h4>
          <label>T√™n truy·ªán</label>
          <input id="newStoryTitle" type="text" placeholder="Nh·∫≠p t√™n truy·ªán..." />
          <div style="margin-top:8px; display:flex; gap:10px; flex-wrap:wrap">
            <button id="createStoryFolder" class="btn primary">T·∫°o th∆∞ m·ª•c trong QuanLyTruyen</button>
          </div>
          <div id="createStoryResult" class="muted" style="margin-top:8px"></div>
        </div>
        <div>
          <h4 style="margin:6px 0">Ch·ªçn th∆∞ m·ª•c truy·ªán ƒë√£ c√≥</h4>
          <label>Danh s√°ch th∆∞ m·ª•c con (t·∫£i)</label>
          <button id="listSubfolders" class="btn">Li·ªát k√™</button>
          <select id="subfolders" size="8" style="margin-top:8px"></select>
          <div class="muted" style="margin-top:8px">Ch·ªçn ƒë·ªÉ d√πng l√†m n∆°i upload ch∆∞∆°ng.</div>
        </div>
      </div>
    </div>
  </section>

  <!-- PAGE: TI·∫æN TR√åNH -->
  <section id="page-progress" class="page">
    <div class="card">
      <h3 style="margin:0 0 8px">Ti·∫øn tr√¨nh & nh·∫≠t k√Ω</h3>
      <div id="log" class="list"></div>
    </div>
  </section>
</div>

<!-- Bottom navigation -->
<nav class="bottom-nav">
  <div class="tab active" data-page="page-data">üìÇ<div>D·ªØ li·ªáu</div></div>
  <div class="tab" data-page="page-write">‚úçÔ∏è<div>Vi·∫øt truy·ªán</div></div>
  <div class="tab" data-page="page-add">‚ûï<div>Th√™m truy·ªán</div></div>
  <div class="tab" data-page="page-progress">‚è±Ô∏è<div>Ti·∫øn tr√¨nh</div></div>
</nav>

<script>
/** ================= C·∫§U H√åNH GOOGLE API ================= */
const GAPI_CONFIG = {
  apiKey: "AIzaSyAbcWr0UPvC4YpsunE6uAa7E5pan9iys2o",
  discoveryDocs: ["https://www.googleapis.com/discovery/v1/apis/drive/v3/rest"],
};

/** ================== TI·ªÜN √çCH UI ================== */
const $ = (id) => document.getElementById(id);
const setStatus = (msg) => { $("status").textContent = msg || ""; };
const setAuthState = (txt) => { $("authState").innerHTML = txt; };
const setQLTState = (txt) => { $("qltState").innerHTML = txt; };
const setBar = (p, el='bar') => { $(el).style.width = Math.max(0, Math.min(100, p)) + "%"; };
const log = (t) => { const el=$("log"); el.textContent += "\n" + new Date().toLocaleTimeString()+" ‚Ä¢ "+ t; el.scrollTop = el.scrollHeight; };

// bottom nav
for (const tab of document.querySelectorAll('.tab')){
  tab.addEventListener('click', () => {
    document.querySelectorAll('.tab').forEach(x=>x.classList.remove('active'));
    tab.classList.add('active');
    const page = tab.dataset.page;
    document.querySelectorAll('.page').forEach(p=>p.classList.remove('active'));
    document.getElementById(page).classList.add('active');
  });
}

/** ================== TR·∫†NG TH√ÅI B·ªò NH·ªö ================== */
let signedIn = false;
let accessToken = null; // GIS token
let tokenClient = null; // GIS token client
let corpusTexts = []; // m·∫£ng chu·ªói txt
let totalBytes = 0;
let sentiment;
let qltFolderId = null; // id th∆∞ m·ª•c QuanLyTruyen
let cancelFlag = false;
let activeStoryFolderId = null; // n∆°i upload ch∆∞∆°ng

/** ================= KH·ªûI T·∫†O GAPI + GIS (m·ªõi) ================= */
function gapiLoad() { return new Promise((resolve) => gapi.load("client", resolve)); }
async function initGapi(){
  await gapiLoad();
  await gapi.client.init({ apiKey: GAPI_CONFIG.apiKey, discoveryDocs: GAPI_CONFIG.discoveryDocs });
  if (accessToken) gapi.client.setToken({access_token: accessToken});
}

function initGIS(){
  tokenClient = google.accounts.oauth2.initTokenClient({
    client_id: "398509518475-7bjid324tkuuh9gv8b0g92lhsgv8nrl5.apps.googleusercontent.com",
    scope: "https://www.googleapis.com/auth/drive.readonly https://www.googleapis.com/auth/drive.file",
    callback: (tokenResponse) => {
      accessToken = tokenResponse.access_token;
      gapi.client.setToken({ access_token: accessToken });
      signedIn = true;
      setAuthState("‚úÖ ƒê√£ ƒëƒÉng nh·∫≠p");
      $("signin").style.display = "none";
      $("signout").style.display = "inline-block";
      ensureQLT();
    }
  });
}

window.addEventListener('load', async () => {
  await initGapi();
  const waitGIS = () => new Promise(r=>{ const iv=setInterval(()=>{ if (window.google && google.accounts && google.accounts.oauth2){ clearInterval(iv); r(); } }, 50); });
  await waitGIS();
  initGIS();
});

$("signin").onclick = () => { if (!tokenClient){ setStatus('GIS ch∆∞a s·∫µn s√†ng'); return; } tokenClient.requestAccessToken({ prompt: 'consent' }); };
$("signout").onclick = async () => {
  try{ if (accessToken && google.accounts && google.accounts.oauth2){ google.accounts.oauth2.revoke(accessToken, ()=>{}); } }catch(e){}
  accessToken = null; signedIn = false; gapi.client.setToken(null);
  setAuthState("Ch∆∞a ƒëƒÉng nh·∫≠p");
  $("signin").style.display = "inline-block"; $("signout").style.display = "none"; setStatus('ƒê√£ ƒëƒÉng xu·∫•t.');
};

/** ================== H√ÄM GOOGLE DRIVE ================== */
async function findFolderIdByName(name, parentId=null){
  let q = `name='${name.replace(/'/g, "\\'")}' and mimeType='application/vnd.google-apps.folder' and trashed=false`;
  if (parentId) q += ` and '${parentId}' in parents`;
  const res = await gapi.client.drive.files.list({ q, fields: "files(id,name,createdTime)", orderBy: "createdTime desc", pageSize: 50 });
  const files = res.result.files || [];
  return files.length ? files[0].id : null;
}
async function createFolder(name, parentId){
  const metadata = { name, mimeType: 'application/vnd.google-apps.folder', parents: parentId ? [parentId] : undefined };
  const res = await gapi.client.drive.files.create({ resource: metadata, fields: 'id,name' });
  return res.result.id;
}
async function ensureQLT(){
  setStatus("ƒêang ki·ªÉm tra th∆∞ m·ª•c QuanLyTruyen...");
  qltFolderId = await findFolderIdByName('QuanLyTruyen');
  if (!qltFolderId){ qltFolderId = await createFolder('QuanLyTruyen', null); }
  setQLTState("üìÅ ID: " + qltFolderId);
}

async function listTxtFilesInFolder(folderId, maxFiles = 200){
  let files=[]; let pageToken=null;
  do{
    const res = await gapi.client.drive.files.list({ q: `'${folderId}' in parents and mimeType='text/plain' and trashed=false`, fields: 'nextPageToken, files(id,name,size,modifiedTime)', pageSize: 100, pageToken });
    files = files.concat(res.result.files || []);
    pageToken = res.result.nextPageToken || null;
    if (files.length >= maxFiles) break;
  } while(pageToken);
  return files.slice(0, maxFiles);
}

async function listSubfolders(parentId){
  const res = await gapi.client.drive.files.list({ q: `'${parentId}' in parents and mimeType='application/vnd.google-apps.folder' and trashed=false`, fields: 'files(id,name,createdTime)', orderBy:'name' });
  return res.result.files || [];
}

function getAccessToken(){
  // ∆∞u ti√™n token GIS ƒë√£ nh·∫≠n
  if (accessToken) return accessToken;
  const tokenObj = gapi.client.getToken();
  return tokenObj && (tokenObj.access_token || tokenObj.accessToken);
}

async function uploadMultipart({name, mimeType, content, parents, fileId=null}){
  const boundary = '-------314159265358979323846';
  const delimiter = "\r\n--" + boundary + "\r\n";
  const closeDelim = "\r\n--" + boundary + "--";
  const metadata = { name, mimeType, parents };
  const base64Data = btoa(unescape(encodeURIComponent(content)));
  const body = 
    delimiter + 'Content-Type: application/json; charset=UTF-8\r\n\r\n' + JSON.stringify(metadata) +
    delimiter + 'Content-Type: ' + mimeType + '\r\n' + 'Content-Transfer-Encoding: base64\r\n\r\n' + base64Data + closeDelim;

  const token = getAccessToken();
  const method = fileId ? 'PATCH' : 'POST';
  const url = fileId
    ? `https://www.googleapis.com/upload/drive/v3/files/${fileId}?uploadType=multipart`
    : 'https://www.googleapis.com/upload/drive/v3/files?uploadType=multipart';

  const res = await fetch(url, { method, headers: { 'Authorization': 'Bearer ' + token, 'Content-Type': 'multipart/related; boundary=' + boundary }, body });
  if (!res.ok){ throw new Error('Upload th·∫•t b·∫°i ' + res.status + ' ' + await res.text()); }
  return await res.json();
}

async function findChildByName(parentId, name){
  const res = await gapi.client.drive.files.list({ q: `'${parentId}' in parents and name='${name.replace(/'/g, "\\'")}' and trashed=false`, fields: 'files(id,name,mimeType)' });
  const files = res.result.files || [];
  return files.length ? files[0] : null;
}

async function upsertTextFile(parentId, name, content){
  const existing = await findChildByName(parentId, name);
  const ret = await uploadMultipart({ name, mimeType:'text/plain', content, parents:[parentId], fileId: existing?.id || null });
  return ret.id;
}
async function upsertJsonFile(parentId, name, obj){
  const existing = await findChildByName(parentId, name);
  const ret = await uploadMultipart({ name, mimeType:'application/json', content: JSON.stringify(obj, null, 2), parents:[parentId], fileId: existing?.id || null });
  return ret.id;
}

/** ================== N·∫†P D·ªÆ LI·ªÜU ================== */
$("clearAll").onclick = ()=>{ corpusTexts=[]; totalBytes=0; $("corpusPreview").value=''; $("filesInfo").textContent=''; setBar(0); setStatus('ƒê√£ xo√° d·ªØ li·ªáu RAM.'); };
$("loadTexts").onclick = loadAllTextsFromDriveFolder;
$("saveCache").onclick = saveCacheToDrive;
$("loadCache").onclick = loadCacheFromDrive;

async function loadAllTextsFromDriveFolder(){
  if (!signedIn){ setStatus('Vui l√≤ng ƒëƒÉng nh·∫≠p.'); return; }
  await ensureQLT();
  setStatus("ƒêang li·ªát k√™ .txt..."); setBar(5);
  const maxFiles = parseInt($("maxFiles").value || '200', 10);
  const maxMB = parseInt($("maxMB").value || '50', 10);
  const byteLimit = maxMB * 1024 * 1024;
  const sub = $("subFolder").value.trim();
  let folderId = qltFolderId;
  if (sub){ folderId = await findFolderIdByName(sub, qltFolderId) || await createFolder(sub, qltFolderId); }

  const fileList = await listTxtFilesInFolder(folderId, maxFiles);
  if (!fileList.length){ setStatus('Kh√¥ng c√≥ .txt trong th∆∞ m·ª•c.'); setBar(0); return; }

  corpusTexts=[]; totalBytes=0; $("corpusPreview").value=''; $("filesInfo").innerHTML='';
  let loaded=0;
  for (const f of fileList){
    if (totalBytes >= byteLimit) break;
    try{
      const txt = await downloadTxtFile(f.id);
      const bytes = new Blob([txt]).size;
      if (totalBytes + bytes > byteLimit){ setStatus(`ƒê·∫°t gi·ªõi h·∫°n ~${maxMB}MB, d·ª´ng.`); break; }
      corpusTexts.push(txt); totalBytes += bytes; loaded++;
      const pct = Math.round((loaded / fileList.length) * 100);
      setBar(Math.min(97, 5 + pct * 0.9));
    }catch(e){ console.error(e); log('L·ªói t·∫£i: '+f.name); }
  }

  const preview = corpusTexts.slice(0,2).map(t=>t.substring(0,500)).join("\n---\n");
  $("corpusPreview").value = preview;
  $("filesInfo").innerHTML = `ƒê√£ n·∫°p <b>${loaded}</b> / ${fileList.length} file (~${(totalBytes/1024/1024).toFixed(2)} MB).`;
  setStatus('Ho√†n t·∫•t n·∫°p.'); setBar(100);
}

async function downloadTxtFile(fileId){
  const token = getAccessToken();
  const res = await fetch(`https://www.googleapis.com/drive/v3/files/${fileId}?alt=media`, { headers:{ Authorization:'Bearer '+token } });
  if (!res.ok) throw new Error('T·∫£i file th·∫•t b·∫°i '+res.status);
  return await res.text();
}

/** ================== TI·∫æNG VI·ªÜT: tokenize + stopwords ================== */
const VI_STOPWORDS = new Set(['v√†','l√†','c·ªßa','nh·ªØng','c√°c','m·ªôt','nh∆∞','ƒë√£','ƒëang','s·∫Ω','r·∫±ng','th√¨','l·∫°i','ƒë∆∞·ª£c','b·ªã','trong','tr√™n','d∆∞·ªõi','t·ª´','v·ªõi','cho','ƒë·∫øn','khi','n√†y','kia','ƒë√≥','·∫•y','nhi·ªÅu','√≠t','r·∫•t','h∆°n','c≈©ng','nh∆∞ng','n·∫øu','v·∫´n','ƒë·ªÅu','ƒëi','v·ªÅ','t·∫°i','qua','sau','tr∆∞·ªõc','gi·ªØa','hay','ho·∫∑c','v√¨','n√™n','do','m√†','n∆°i','ai','g√¨','ƒë√¢u','n√†o','ƒë√¢y','t√¥i','ta','m√¨nh','ch√∫ng','anh','em','ch·ªã','c√¥','ch√∫','b√°c','√¥ng','b√†','n√≥','h·ªç','c·∫≠u','v·∫≠y','th·∫ø','∆°i','√†','·ª´','·ªù','∆°','h·∫£','h·ª≠','nh·ªâ','nh√©','c·∫£','b·ªüi','ƒë·∫øn','kho·∫£ng','ngo√†i','c√πng','t·ª´ng','m·ªói','m·ªçi','r·ªìi','n·ªØa','th√™m','b·ªõt','g·∫ßn','xa','h·∫øt','ƒë·ªß']);
function tokenizeVI(text){ const tokens = (text||'').toLowerCase().match(/[\p{L}\p{M}\d']+/gu) || []; return tokens.filter(w=>w && !VI_STOPWORDS.has(w)); }
function splitSentencesVI(text){ return (text||'').split(/(?<=[\.!?‚Ä¶])\s+/).filter(s=>s.trim().length>0); }

/** ================== PH√ÇN T√çCH (N√ÇNG C·∫§P) ================== */
$("analyze").onclick = analyzeCorpus;
$("exportStats").onclick = ()=>{ if (!window._lastStats){ setStatus('Ch∆∞a c√≥ th·ªëng k√™.'); return; } const data = window._lastStats; const blob = new Blob([JSON.stringify(data,null,2)], {type:'application/json'}); const url = URL.createObjectURL(blob); const a = document.createElement('a'); a.href=url; a.download='stats.json'; a.click(); URL.revokeObjectURL(url); };

async function ensureSentiment(){ if (!sentiment){ sentiment = ml5.sentiment('movieReviews'); } }
function topWords(tokens, n=40){ const f=new Map(); for(const w of tokens) f.set(w,(f.get(w)||0)+1); return [...f.entries()].sort((a,b)=>b[1]-a[1]).slice(0,n); }
function ngrams(tokens, n){ const m=new Map(); for(let i=0;i<=tokens.length-n;i++){ const key=tokens.slice(i,i+n).join(' '); const next=tokens[i+n]; if (!next) continue; if(!m.has(key)) m.set(key,[]); m.get(key).push(next);} return m; }

async function analyzeCorpus(){
  if (!corpusTexts.length){ setStatus('Ch∆∞a c√≥ d·ªØ li·ªáu.'); return; }
  await ensureSentiment();
  const joined = corpusTexts.join('\n');
  const sentences = splitSentencesVI(joined);
  const tokens = tokenizeVI(joined);
  const uniq = new Set(tokens).size;
  const sampleSize = Math.min(200, sentences.length);
  let sum=0; for(let i=0;i<sampleSize;i++){ const s = sentences[Math.floor(Math.random()*sentences.length)]; try{ sum += sentiment.predict(s).score||0; }catch{} }
  const avgSent = sampleSize? (sum/sampleSize) : 0;
  const order = 3; const model = ngrams(tokens, order);
  const vocabSize = new Set(tokens).size;
  const tops = topWords(tokens, 40).map(([w,c])=>`${w.padEnd(16,' ')} : ${c}`).join('\n');
  const stats = { chars: joined.length, words: tokens.length, uniqueWords: uniq, vocabSize, avgSentiment: +avgSent.toFixed(4), topWords: [...topWords(tokens, 100)], order, modelKeys: model.size };
  window._lastStats = stats; window._lastTokens = tokens; window._lastModel = model;
  $("analysis").textContent =
`T·ªïng k√Ω t·ª±      : ${joined.length.toLocaleString()}
T·ªïng t·ª´          : ${tokens.length.toLocaleString()}
S·ªë t·ª´ kh√°c nhau  : ${uniq.toLocaleString()}
K√≠ch th∆∞·ªõc vocab : ${vocabSize.toLocaleString()}
ƒêi·ªÉm c·∫£m x√∫c TB  : ${avgSent.toFixed(3)} (ml5: movieReviews)
S·ªë kh√≥a n-gram   : ${model.size.toLocaleString()}
Top 40 t·ª´ ph·ªï bi·∫øn:\n${tops}`;
  setStatus('ƒê√£ ph√¢n t√≠ch.'); log('Ph√¢n t√≠ch xong.');
}

/** ================== CACHE PH√ÇN T√çCH (Drive) ================== */
async function saveCacheToDrive(){ if (!qltFolderId){ await ensureQLT(); } if (!window._lastTokens || !window._lastStats){ setStatus('Ch∆∞a ph√¢n t√≠ch ƒë·ªÉ l∆∞u.'); return; } const cache = { when: new Date().toISOString(), stats: window._lastStats }; const vocab = { tokens: window._lastTokens.slice(0, 500000) }; await upsertJsonFile(qltFolderId, 'QLT_analysis.json', cache); await upsertJsonFile(qltFolderId, 'QLT_vocab.json', vocab); setStatus('ƒê√£ l∆∞u cache ph√¢n t√≠ch l√™n Drive.'); log('L∆∞u cache th√†nh c√¥ng.'); }
async function loadCacheFromDrive(){ if (!qltFolderId){ await ensureQLT(); } async function downloadJsonIfExists(name){ const f = await findChildByName(qltFolderId, name); if (!f){ return null; } const token = getAccessToken(); const res = await fetch(`https://www.googleapis.com/drive/v3/files/${f.id}?alt=media`, { headers:{ Authorization:'Bearer '+token } }); if (!res.ok) return null; return await res.json(); } const cache = await downloadJsonIfExists('QLT_analysis.json'); const vocab = await downloadJsonIfExists('QLT_vocab.json'); if (cache && vocab){ window._lastStats = cache.stats; window._lastTokens = vocab.tokens; $("analysis").textContent = JSON.stringify(cache, null, 2); window._lastModel = ngrams(window._lastTokens, cache.stats.order || 3); setStatus('ƒê√£ t·∫£i cache ph√¢n t√≠ch.'); log('T·∫£i cache th√†nh c√¥ng.'); } else { setStatus('Kh√¥ng t√¨m th·∫•y cache.'); } }

/** ================== VI·∫æT TRUY·ªÜN 50 CH∆Ø∆†NG ================== */
$("generateOutline").onclick = suggestOutline;
$("startBook").onclick = startGeneratingBook;
$("cancelGen").onclick = ()=>{ cancelFlag = true; setStatus('ƒê√£ g·ª≠i y√™u c·∫ßu hu·ª∑.'); };

function pick(arr){ return arr[Math.floor(Math.random()*arr.length)]; }
function buildWordModel(tokens, order){ const m = new Map(); for(let i=0;i<=tokens.length - order; i++){ const key = tokens.slice(i,i+order).join(' '); const next = tokens[i+order]; if (!next) continue; if (!m.has(key)) m.set(key, []); m.get(key).push(next);} return m; }
async function ensureModel(){ if (!window._lastTokens){ if (!corpusTexts.length){ setStatus('Ch∆∞a c√≥ d·ªØ li·ªáu ƒë·ªÉ h·ªçc.'); throw new Error('no data'); } const tokens = tokenizeVI(corpusTexts.join('\n')); window._lastTokens = tokens; } if (!window._lastModel){ const order = parseInt($("order").value || '3', 10); window._lastModel = buildWordModel(window._lastTokens, order); } await ensureSentiment(); }

function proposeTitleFromTokens(tokens){ const freq = new Map(); for(const w of tokens) freq.set(w,(freq.get(w)||0)+1); const weighted = [...freq.entries()].filter(([w])=>w.length>2 && !VI_STOPWORDS.has(w)); weighted.sort((a,b)=>b[1]-a[1]); const pool = weighted.slice(0,120).map(([w,c])=>({w,score:c})); const pickN = (n)=>{ const arr=[]; for(let i=0;i<n;i++){ const r = pool[Math.floor(Math.random()*pool.length)]; if(!r) break; arr.push(r.w); } return arr; }; const form1 = ["h√†nh tr√¨nh", "b√≠ ·∫©n", "k√Ω ·ª©c", "b√≥ng ƒë√™m", "m√πa gi√≥", "d·∫•u ch√¢n", "l·∫±n ranh", "m·∫∑t tr·ªùi", "ƒë√°m m√¢y", "c∆°n m∆∞a"]; let cand = pick(form1) + ' ' + pickN(2).join(' '); cand = cand.replace(/\b\w/g, m=>m.toUpperCase()); return cand; }

async function suggestOutline(){ await ensureModel(); const title = ($("titleInput").value.trim() || proposeTitleFromTokens(window._lastTokens)).replace(/\s+/g,' ').trim(); const chapters = []; const arcs = ['Kh·ªüi ƒë·∫ßu & g·ªçi m·ªùi cu·ªôc phi√™u l∆∞u','B∆∞·ªõc ch√¢n ƒë·∫ßu ti√™n & m√¢u thu·∫´n nhen nh√≥m','L·ªùi h·ª©a v√† b√≠ m·∫≠t','G·∫∑p g·ª° ƒë·ªìng minh','Th·ª≠ th√°ch nh·ªè, h·∫≠u qu·∫£ l·ªõn','D·∫•u v·∫øt qu√° kh·ª©','ƒê·ªëi ƒë·∫ßu l·∫ßn ƒë·∫ßu','V√πng t·ªëi c·ªßa t√¥i','L·ª±a ch·ªçn kh√≥ khƒÉn','M·∫•t m√°t th·ª© nh·∫•t','Manh m·ªëi l·ªô di·ªán','N√¢ng t·∫ßm xung ƒë·ªôt','C√°nh c·ª≠a kh√©p h·ªù','B∆∞·ªõc ngo·∫∑t','L·ªùi n√≥i d·ªëi','Ch·∫°y tr·ªën','T√°i ng·ªô','H·ªçc c√°ch tin','ƒê·ªïi vai','B∆∞·ªõc v√†o t√¢m b√£o','ƒê√™m tr∆∞·ªõc b√£o','S·ª± th·∫≠t th·ª© nh·∫•t','V·ª° v·ª•n','Nh·∫∑t t·ª´ng m·∫£nh','Th·∫Øp l·ª≠a','√Çm m∆∞u l·ªô m·∫∑t','C√°i b·∫´y','Hi sinh','S·ª•p ƒë·ªï','V·ª±c d·∫≠y','ƒê·ªëi m·∫∑t cu·ªëi','C√°i gi√° ph·∫£i tr·∫£','M·ªü kho√° b√≠ ·∫©n','√Ånh s√°ng r·∫°ng ƒë√¥ng','V·∫øt s·∫πo c√≤n l·∫°i','Tha th·ª©','Tr·ªü v·ªÅ','C√°nh c·ª≠a m·ªõi','Ch·ªçn con ƒë∆∞·ªùng','L·ªùi h·ª©a gi·ªØ l·∫•y','Vi·∫øt ti·∫øp','M√πa m∆∞a n·ªØa','B√¨nh y√™n mong manh','D·∫•u ch·∫•m h·∫øt','Ngo·∫°i truy·ªán 1','Ngo·∫°i truy·ªán 2','Ngo·∫°i truy·ªán 3','Ngo·∫°i truy·ªán 4','Ngo·∫°i truy·ªán 5','Kh√©p l·∫°i & m·ªü ra']; for(let i=1;i<=50;i++){ const arc = arcs[i-1] || `Ch∆∞∆°ng ${i}`; chapters.push({ index:i, name: arc }); } const outline = { title, chapters }; $("outlineBox").value = JSON.stringify(outline, null, 2); setStatus('ƒê√£ t·∫°o d√†n √Ω 50 ch∆∞∆°ng.'); }

function sampleWords(model, order, targetWords, seedWords){ const ENDERS=['.','!','?','‚Ä¶']; const ensureFirstPerson=(s)=>{ if (!/\bt√¥i\b/i.test(s)) return 'T√¥i ' + s.charAt(0).toLowerCase()+s.slice(1); return s; }; let keyTokens; if (seedWords && seedWords.length >= order) keyTokens = seedWords.slice(0, order); else { const keys = [...model.keys()]; keyTokens = keys[Math.floor(Math.random()*keys.length)].split(' '); } let out = keyTokens.slice(); while (out.length < targetWords){ const key = out.slice(out.length - order, out.length).join(' '); const choices = model.get(key) || []; if (!choices.length){ const keys = [...model.keys()]; const pickKey = keys[Math.floor(Math.random()*keys.length)]; const parts = pickKey.split(' '); out.push(...parts); continue; } let cand = choices[Math.floor(Math.random()*choices.length)]; out.push(cand); if (Math.random() < 0.08) out.push(pick([',', ',', ',', '.', '.'])); } let text = out.join(' ').replace(/\s+([,\.\!\?‚Ä¶])/g,'$1').replace(/\n\s+/g,'\n'); const sents = splitSentencesVI(text).map(s=>s.trim()).filter(Boolean); const paras=[]; let cur=[]; let count=0; for (const s of sents){ cur.push(s); count++; if (count>=5+Math.floor(Math.random()*4)){ paras.push(ensureFirstPerson(cur.join(' '))); cur=[]; count=0; } } if (cur.length) paras.push(ensureFirstPerson(cur.join(' '))); return paras.join('\n\n'); }

async function generateChapter({model, order, wordsTarget, seed, targetSent=0.1}){ await ensureSentiment(); const seedWords = seed ? tokenizeVI(seed) : null; const candidates = []; for (let i=0;i<3;i++){ const text = sampleWords(model, order, wordsTarget, seedWords); const sents = splitSentencesVI(text); let sum=0, n=0; for (const s of sents.slice(0,50)){ try{ sum += sentiment.predict(s).score||0; n++; }catch{} } const score = n? sum/n : 0; candidates.push({text, dist: Math.abs(score - targetSent)}); } candidates.sort((a,b)=>a.dist-b.dist); return candidates[0].text; }

async function startGeneratingBook(){ cancelFlag = false; try{ await ensureModel(); await ensureQLT(); let outline; try{ outline = JSON.parse($("outlineBox").value || '{}'); }catch{ outline=null; } if (!outline || !outline.title){ await suggestOutline(); outline = JSON.parse($("outlineBox").value); } const title = outline.title; const storyFolderId = await findFolderIdByName(title, qltFolderId) || await createFolder(title, qltFolderId); activeStoryFolderId = storyFolderId; const meta = { title, chapters: outline.chapters, createdAt: new Date().toISOString(), generator:'Markov-W3 + ml5 sentiment', wordsPerChapter:+$("wordsPerChapter").value }; await upsertJsonFile(storyFolderId, 'metadata.json', meta); const order = parseInt($("order").value || '3', 10); const wordsTarget = parseInt($("wordsPerChapter").value || '2300', 10); const targetSent = parseFloat($("targetSentiment").value || '0.1'); const chapters = outline.chapters || Array.from({length:50}, (_,i)=>({index:i+1, name:`Ch∆∞∆°ng ${i+1}`})); for (let i=0; i<chapters.length; i++){ if (cancelFlag){ setStatus('ƒê√£ hu·ª∑.'); break; } const ch = chapters[i]; $("bookStatus").textContent = `ƒêang sinh: Ch∆∞∆°ng ${ch.index} ‚Äì ${ch.name}`; log(`Sinh ch∆∞∆°ng ${ch.index}`); const seed = (i===0? ($("seed").value.trim()||'T√¥i') : `T√¥i ${ch.name.toLowerCase()}`); const text = await generateChapter({ model: window._lastModel, order, wordsTarget, seed, targetSent }); const titleName = ch.name || `Ch∆∞∆°ng ${i+1}`; const fileName = `${String(ch.index).padStart(2,'0')} - ${titleName}.txt`; await upsertTextFile(storyFolderId, fileName, titleName.toUpperCase()+"\n\n"+ text + "\n"); const p = Math.round(((i+1)/chapters.length)*100); setBar(p,'bookBar'); $("bookStatus").textContent = `ƒê√£ upload: ${fileName}`; await new Promise(r=>setTimeout(r, 350)); } await upsertJsonFile(storyFolderId, 'generation_summary.json', { finishedAt: new Date().toISOString(), wordsPerChapter: wordsTarget, order, targetSent }); setStatus('Ho√†n t·∫•t sinh & upload.'); log('Ho√†n t·∫•t to√†n b·ªô.'); }catch(e){ console.error(e); setStatus('L·ªói: '+e.message); log('L·ªói: '+e.message); }}

/** ============ TH√äM TRUY·ªÜN (UI) ============ */
$("createStoryFolder").onclick = async ()=>{ try{ await ensureQLT(); const name = $("newStoryTitle").value.trim(); if (!name){ setStatus('Nh·∫≠p t√™n truy·ªán.'); return; } const id = await findFolderIdByName(name, qltFolderId) || await createFolder(name, qltFolderId); $("createStoryResult").textContent = `ƒê√£ s·∫µn s√†ng th∆∞ m·ª•c: ${name} (ID: ${id})`; activeStoryFolderId = id; }catch(e){ setStatus('L·ªói t·∫°o th∆∞ m·ª•c: '+e.message); } };
$("listSubfolders").onclick = async ()=>{ await ensureQLT(); const subs = await listSubfolders(qltFolderId); const sel = $("subfolders"); sel.innerHTML=''; for (const f of subs){ const opt = document.createElement('option'); opt.value=f.id; opt.textContent=f.name; sel.appendChild(opt); } sel.onchange = ()=>{ activeStoryFolderId = sel.value; setStatus('Ch·ªçn th∆∞ m·ª•c: '+ sel.options[sel.selectedIndex].text); }; };
</script>
</body>
</html>
