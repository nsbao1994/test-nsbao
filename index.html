<!DOCTYPE html>
<html lang="vi">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Qu·∫£n l√Ω Truy·ªán - Google Drive Database</title>
    <script src="https://apis.google.com/js/api.js"></script>
    <script src="https://accounts.google.com/gsi/client"></script>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: linear-gradient(135deg, #1a1a2e 0%, #16213e 50%, #0f3460 100%);
            min-height: 100vh; 
            color: #ffffff;
            overflow-x: hidden;
        }
        .container {
            max-width: 100%;
            background: rgba(255, 255, 255, 0.05);
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.1);
            min-height: 100vh;
        }
        .header { 
            background: linear-gradient(45deg, #667eea, #764ba2); 
            color: white; 
            padding: 20px 15px;
            text-align: center; 
            position: sticky;
            top: 0;
            z-index: 100;
            backdrop-filter: blur(10px);
        }
        .header h1 { 
            font-size: 1.8em; 
            margin-bottom: 5px;
            font-weight: 700;
        }
        .header p {
            font-size: 0.9em;
            opacity: 0.9;
        }
        .main-content { 
            padding: 15px;
            padding-bottom: 80px;
        }
        .auth-section { 
            text-align: center; 
            margin-bottom: 20px;
            background: rgba(255, 255, 255, 0.05);
            padding: 20px;
            border-radius: 15px;
            border: 1px solid rgba(255, 255, 255, 0.1);
        }
        .btn {
            background: linear-gradient(45deg, #667eea, #764ba2);
            color: white; 
            border: none; 
            padding: 12px 20px;
            border-radius: 25px; 
            font-size: 14px; 
            cursor: pointer;
            transition: all 0.3s ease; 
            margin: 5px;
            min-height: 44px;
            display: inline-flex;
            align-items: center;
            justify-content: center;
            font-weight: 600;
            box-shadow: 0 4px 15px rgba(102, 126, 234, 0.3);
        }
        .btn:hover, .btn:active { 
            transform: translateY(-2px); 
            box-shadow: 0 6px 20px rgba(102, 126, 234, 0.4);
        }
        .btn:disabled { 
            opacity: 0.5; 
            cursor: not-allowed; 
            transform: none;
        }
        .btn.danger {
            background: linear-gradient(45deg, #ff6b6b, #ff5252);
            box-shadow: 0 4px 15px rgba(255, 107, 107, 0.3);
        }
        .btn.success {
            background: linear-gradient(45deg, #4ecdc4, #44a08d);
            box-shadow: 0 4px 15px rgba(78, 205, 196, 0.3);
        }
        .form-section {
            background: rgba(255, 255, 255, 0.05);
            padding: 20px; 
            border-radius: 15px; 
            margin-bottom: 20px;
            border: 1px solid rgba(255, 255, 255, 0.1);
            backdrop-filter: blur(10px);
        }
        .form-section h2 {
            margin-bottom: 20px;
            color: #ffffff;
            font-size: 1.3em;
        }
        .form-group { 
            margin-bottom: 20px; 
        }
        .form-group label { 
            display: block; 
            margin-bottom: 8px; 
            font-weight: 600; 
            color: #ffffff;
            font-size: 14px;
        }
        .form-group input, .form-group textarea, .form-group select {
            width: 100%; 
            padding: 15px; 
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 12px; 
            font-size: 16px; 
            transition: all 0.3s ease;
            background: rgba(255, 255, 255, 0.1);
            color: #ffffff;
            backdrop-filter: blur(5px);
        }
        .form-group input::placeholder,
        .form-group textarea::placeholder {
            color: rgba(255, 255, 255, 0.6);
        }
        .form-group input:focus,
        .form-group textarea:focus,
        .form-group select:focus {
            outline: none;
            border-color: #667eea;
            box-shadow: 0 0 0 3px rgba(102, 126, 234, 0.2);
            background: rgba(255, 255, 255, 0.15);
        }
        .form-group textarea { 
            min-height: 120px; 
            resize: vertical; 
        }
        .history-section {
            background: rgba(255, 255, 255, 0.05);
            border-radius: 15px; 
            overflow: hidden;
            margin-bottom: 20px;
            border: 1px solid rgba(255, 255, 255, 0.1);
        }
        .history-header { 
            background: linear-gradient(45deg, #667eea, #764ba2); 
            color: white; 
            padding: 15px; 
            text-align: center;
        }
        .history-header h2 {
            font-size: 1.2em;
        }
        .history-list { 
            max-height: 300px; 
            overflow-y: auto; 
        }
        .history-item { 
            padding: 15px; 
            border-bottom: 1px solid rgba(255, 255, 255, 0.1); 
            transition: background-color 0.3s ease;
        }
        .history-item:hover, .history-item:active { 
            background-color: rgba(255, 255, 255, 0.1); 
        }
        .story-title { 
            font-weight: 600; 
            color: #ffffff; 
            margin-bottom: 5px;
            font-size: 16px;
        }
        .story-chapter { 
            color: rgba(255, 255, 255, 0.7); 
            font-size: 14px; 
            margin-bottom: 5px; 
        }
        .story-date { 
            color: rgba(255, 255, 255, 0.5); 
            font-size: 12px; 
        }
        .status { 
            padding: 15px; 
            border-radius: 12px; 
            margin: 15px 0; 
            display: none;
            font-weight: 600;
        }
        .status.success { 
            background: rgba(78, 205, 196, 0.2); 
            color: #4ecdc4; 
            border: 1px solid rgba(78, 205, 196, 0.3);
        }
        .status.error { 
            background: rgba(255, 107, 107, 0.2); 
            color: #ff6b6b; 
            border: 1px solid rgba(255, 107, 107, 0.3);
        }
        .loading { 
            display: none; 
            text-align: center; 
            padding: 30px;
            background: rgba(255, 255, 255, 0.05);
            border-radius: 15px;
            margin: 20px 0;
        }
        .spinner {
            border: 3px solid rgba(255, 255, 255, 0.1); 
            border-top: 3px solid #667eea;
            border-radius: 50%; 
            width: 40px; 
            height: 40px;
            animation: spin 1s linear infinite; 
            margin: 0 auto 15px;
        }
        @keyframes spin { 
            0% { transform: rotate(0deg); } 
            100% { transform: rotate(360deg); } 
        }
        .grid { 
            display: flex;
            flex-direction: column;
            gap: 20px; 
            margin-top: 20px; 
        }
        
        /* AI Training Section */
        .ai-section {
            background: linear-gradient(135deg, rgba(102, 126, 234, 0.1), rgba(118, 75, 162, 0.1));
            border: 1px solid rgba(102, 126, 234, 0.3);
            padding: 20px;
            border-radius: 15px;
            margin-bottom: 20px;
        }
        .ai-section h2 {
            color: #667eea;
            margin-bottom: 15px;
            font-size: 1.3em;
        }
        .ai-stats {
            background: rgba(255, 255, 255, 0.05);
            padding: 15px;
            border-radius: 10px;
            margin: 15px 0;
        }
        .stat-item {
            display: flex;
            justify-content: space-between;
            margin: 10px 0;
            padding: 8px 0;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
        }
        .stat-item:last-child {
            border-bottom: none;
        }
        
        /* Chat Interface */
        .chat-container {
            background: rgba(255, 255, 255, 0.05);
            border-radius: 15px;
            padding: 20px;
            margin-bottom: 20px;
            border: 1px solid rgba(255, 255, 255, 0.1);
            max-height: 400px;
            overflow-y: auto;
        }
        .chat-message {
            margin: 10px 0;
            padding: 10px 15px;
            border-radius: 10px;
            max-width: 85%;
        }
        .chat-message.user {
            background: linear-gradient(45deg, #667eea, #764ba2);
            color: white;
            margin-left: auto;
            text-align: right;
        }
        .chat-message.ai {
            background: rgba(255, 255, 255, 0.1);
            color: #ffffff;
            margin-right: auto;
        }
        .chat-input {
            display: flex;
            gap: 10px;
            margin-top: 15px;
        }
        .chat-input input {
            flex: 1;
            padding: 12px 15px;
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 25px;
            background: rgba(255, 255, 255, 0.1);
            color: #ffffff;
        }
        
        /* Progress Bar */
        .progress-bar {
            width: 100%;
            height: 6px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 3px;
            overflow: hidden;
            margin: 10px 0;
        }
        .progress-fill {
            height: 100%;
            background: linear-gradient(45deg, #667eea, #764ba2);
            transition: width 0.3s ease;
            width: 0%;
        }
        
        /* AI Generated Stories Section */
        .ai-generated-section {
            background: linear-gradient(135deg, rgba(78, 205, 196, 0.1), rgba(44, 160, 141, 0.1));
            border: 1px solid rgba(78, 205, 196, 0.3);
            padding: 20px;
            border-radius: 15px;
            margin-bottom: 20px;
        }
        .ai-generated-section h2 {
            color: #4ecdc4;
            margin-bottom: 15px;
            font-size: 1.3em;
        }
        .ai-story-controls {
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
            margin-bottom: 15px;
        }
        .ai-story-controls input {
            flex: 1;
            min-width: 150px;
            padding: 12px 15px;
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 25px;
            background: rgba(255, 255, 255, 0.1);
            color: #ffffff;
        }
        .ai-story-list {
            max-height: 300px;
            overflow-y: auto;
            background: rgba(255, 255, 255, 0.05);
            border-radius: 10px;
            padding: 10px;
        }
        .ai-story-item {
            padding: 12px;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
            cursor: pointer;
            transition: background-color 0.3s;
        }
        .ai-story-item:hover {
            background-color: rgba(255, 255, 255, 0.1);
        }
        .ai-story-title {
            font-weight: 600;
            margin-bottom: 5px;
        }
        .ai-story-info {
            font-size: 0.85em;
            color: rgba(255, 255, 255, 0.7);
        }
        
        /* Modal for viewing chapters */
        .modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.7);
            z-index: 1000;
            overflow-y: auto;
            padding: 20px;
        }
        .modal-content {
            background: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%);
            margin: 40px auto;
            padding: 20px;
            border-radius: 15px;
            max-width: 800px;
            box-shadow: 0 5px 25px rgba(0, 0, 0, 0.5);
            position: relative;
        }
        .close-modal {
            position: absolute;
            top: 15px;
            right: 20px;
            font-size: 28px;
            font-weight: bold;
            cursor: pointer;
            color: #fff;
        }
        .chapter-list {
            max-height: 400px;
            overflow-y: auto;
            margin: 15px 0;
        }
        .chapter-item {
            padding: 12px;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
            cursor: pointer;
        }
        .chapter-item:hover {
            background-color: rgba(255, 255, 255, 0.1);
        }
        .chapter-content {
            margin-top: 20px;
            padding: 15px;
            background: rgba(255, 255, 255, 0.05);
            border-radius: 10px;
            max-height: 500px;
            overflow-y: auto;
            white-space: pre-wrap;
        }
        .chapter-actions {
            display: flex;
            gap: 10px;
            margin-top: 15px;
        }
        
        /* Mobile optimizations */
        @media (max-width: 768px) {
            .header h1 { font-size: 1.6em; }
            .main-content { padding: 10px; }
            .form-section, .history-section { margin-bottom: 15px; }
            .btn { font-size: 14px; padding: 10px 16px; }
            .modal-content { margin: 20px 10px; padding: 15px; }
        }
        
        /* Safe area for iPhone */
        @supports (padding: max(0px)) {
            .container {
                padding-top: max(20px, env(safe-area-inset-top));
                padding-bottom: max(20px, env(safe-area-inset-bottom));
                padding-left: max(10px, env(safe-area-inset-left));
                padding-right: max(10px, env(safe-area-inset-right));
            }
        }
        
        /* Scrollbar styling */
        ::-webkit-scrollbar { width: 6px; }
        ::-webkit-scrollbar-track { background: rgba(255, 255, 255, 0.1); }
        ::-webkit-scrollbar-thumb { background: rgba(102, 126, 234, 0.5); border-radius: 3px; }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>ü§ñ AI Truy·ªán Manager</h1>
            <p>Qu·∫£n l√Ω & Hu·∫•n luy·ªán AI v·ªõi Google Drive</p>
        </div>
        <div class="main-content">
            <div class="auth-section">
                <button id="authorizeButton" class="btn">üîê ƒêƒÉng nh·∫≠p Google Drive</button>
                <button id="signoutButton" class="btn danger" style="display: none;">üö™ ƒêƒÉng xu·∫•t</button>
                <div id="authStatus"></div>
            </div>
            
            <div class="loading" id="loading">
                <div class="spinner"></div>
                <p>ƒêang x·ª≠ l√Ω...</p>
            </div>
            
            <div class="status" id="status"></div>
            
            <div id="mainApp" style="display: none;">
                <!-- AI Training Section -->
                <div class="ai-section">
                    <h2>üß† Hu·∫•n luy·ªán AI</h2>
                    <div class="ai-stats" id="aiStats">
                        <div class="stat-item">
                            <span>T·ªïng s·ªë file:</span>
                            <span id="totalFiles">0</span>
                        </div>
                        <div class="stat-item">
                            <span>ƒê√£ hu·∫•n luy·ªán:</span>
                            <span id="trainedFiles">0</span>
                        </div>
                        <div class="stat-item">
                            <span>T·ª´ v·ª±ng h·ªçc ƒë∆∞·ª£c:</span>
                            <span id="vocabularyCount">0</span>
                        </div>
                    </div>
                    <div class="progress-bar">
                        <div class="progress-fill" id="progressFill"></div>
                    </div>
                    <button id="trainAiButton" class="btn success">üéØ B·∫Øt ƒë·∫ßu hu·∫•n luy·ªán AI</button>
                    <button id="resetAiButton" class="btn danger">üîÑ Reset AI</button>
                </div>

                <!-- AI Story Generation Section -->
                <div class="ai-generated-section">
                    <h2>üìñ AI T·∫°o Truy·ªán T·ª± ƒê·ªông</h2>
                    <div class="ai-story-controls">
                        <input type="number" id="chapterCount" placeholder="S·ªë ch∆∞∆°ng (100-150)" min="100" max="150" value="100">
                        <button id="generateStoryButton" class="btn success">üöÄ AI T·∫°o Truy·ªán M·ªõi</button>
                        <button id="viewAiStoriesButton" class="btn">üìö Xem Truy·ªán AI ƒê√£ T·∫°o</button>
                    </div>
                    <div class="progress-bar">
                        <div class="progress-fill" id="generationProgressFill"></div>
                    </div>
                    <div id="generationStatus"></div>
                </div>

                <!-- Chat with AI -->
                <div class="form-section">
                    <h2>üí¨ Tr√≤ chuy·ªán v·ªõi AI</h2>
                    <div class="chat-container" id="chatContainer">
                        <div class="chat-message ai">Xin ch√†o! T√¥i ƒë√£ s·∫µn s√†ng tr√≤ chuy·ªán. H√£y hu·∫•n luy·ªán t√¥i v·ªõi c√°c file truy·ªán ƒë·ªÉ t√¥i c√≥ th·ªÉ h·ªó tr·ª£ b·∫°n t·ªët h∆°n!</div>
                    </div>
                    <div class="chat-input">
                        <input type="text" id="chatInput" placeholder="Nh·∫≠p tin nh·∫Øn...">
                        <button id="sendChatButton" class="btn">üì§</button>
                    </div>
                </div>
                
                <!-- Story Management -->
                <div class="form-section">
                    <h2>‚úçÔ∏è Th√™m Truy·ªán / Ch∆∞∆°ng M·ªõi</h2>
                    <form id="storyForm">
                        <div class="form-group">
                            <label for="storyMode">Ch·∫ø ƒë·ªô:</label>
                            <select id="storyMode" onchange="toggleStoryMode()">
                                <option value="new">T·∫°o truy·ªán m·ªõi</option>
                                <option value="existing">Th√™m ch∆∞∆°ng v√†o truy·ªán c√≥ s·∫µn</option>
                            </select>
                        </div>
                        <div class="form-group" id="newStoryGroup">
                            <label for="storyTitle">T√™n Truy·ªán M·ªõi:</label>
                            <input type="text" id="storyTitle" placeholder="Nh·∫≠p t√™n truy·ªán m·ªõi...">
                        </div>
                        <div class="form-group" id="existingStoryGroup" style="display: none;">
                            <label for="existingStory">Ch·ªçn Truy·ªán C√≥ S·∫µn:</label>
                            <select id="existingStory"><option value="">-- Ch·ªçn truy·ªán --</option></select>
                        </div>
                        <div class="form-group">
                            <label for="chapterTitle">T√™n Ch∆∞∆°ng:</label>
                            <input type="text" id="chapterTitle" required placeholder="Nh·∫≠p t√™n ch∆∞∆°ng...">
                        </div>
                        <div class="form-group">
                            <label for="storyContent">N·ªôi dung:</label>
                            <textarea id="storyContent" required placeholder="Nh·∫≠p n·ªôi dung truy·ªán..."></textarea>
                        </div>
                        <button type="submit" class="btn">üíæ <span id="submitButtonText">L∆∞u Truy·ªán M·ªõi</span></button>
                    </form>
                </div>
                
                <div class="grid">
                    <div class="history-section">
                        <div class="history-header"><h2>üìñ L·ªãch s·ª≠ Truy·ªán</h2></div>
                        <div class="history-list" id="historyList"></div>
                    </div>
                    <div class="history-section">
                        <div class="history-header"><h2>üìÅ Th∆∞ m·ª•c Google Drive</h2></div>
                        <div class="history-list" id="folderList"></div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- Modal for AI Generated Stories -->
    <div id="aiStoriesModal" class="modal">
        <div class="modal-content">
            <span class="close-modal" onclick="closeModal('aiStoriesModal')">&times;</span>
            <h2>üìö Truy·ªán ƒê∆∞·ª£c T·∫°o B·ªüi AI</h2>
            <div class="ai-story-list" id="aiStoryList">
                <!-- AI stories will be listed here -->
            </div>
        </div>
    </div>

    <!-- Modal for Viewing Chapters -->
    <div id="chaptersModal" class="modal">
        <div class="modal-content">
            <span class="close-modal" onclick="closeModal('chaptersModal')">&times;</span>
            <h2 id="chaptersModalTitle">Ch∆∞∆°ng Truy·ªán</h2>
            <div class="chapter-list" id="chapterList">
                <!-- Chapters will be listed here -->
            </div>
            <div class="chapter-content" id="chapterContent" style="display: none;">
                <!-- Chapter content will be displayed here -->
            </div>
            <div class="chapter-actions" id="chapterActions" style="display: none;">
                <button class="btn" onclick="editChapter()">‚úèÔ∏è S·ª≠a Ch∆∞∆°ng</button>
                <button class="btn danger" onclick="deleteChapter()">üóëÔ∏è X√≥a Ch∆∞∆°ng</button>
                <button class="btn" onclick="saveChapterChanges()">üíæ L∆∞u Thay ƒê·ªïi</button>
                <button class="btn" onclick="cancelEdit()">‚ùå H·ªßy</button>
            </div>
        </div>
    </div>

<script>
const CLIENT_ID = '199144324956-rsc4tttep6uq67poepa2nclieqi82avj.apps.googleusercontent.com';
const API_KEY = 'AIzaSyBGHB5FnrtMXliWtk3X6FZAl0CE2neNgZM';
const DISCOVERY_DOC = 'https://www.googleapis.com/discovery/v1/apis/drive/v3/rest';
const SCOPES = 'https://www.googleapis.com/auth/drive.file';

let tokenClient, gapi_inited = false, gis_inited = false, mainFolderId = null, storyHistory = [];
let aiKnowledge = { vocabulary: new Set(), stories: [], trainedFiles: 0 };
let aiGeneratedStories = [];
let currentEditingChapter = null;

// Initialize Google API
async function initializeGapi() {
    await gapi.load('client', async () => {
        await gapi.client.init({ apiKey: API_KEY, discoveryDocs: [DISCOVERY_DOC] });
        gapi_inited = true; maybeEnableButtons();
    });
}

function initializeGis() {
    tokenClient = google.accounts.oauth2.initTokenClient({
        client_id: CLIENT_ID, scope: SCOPES, callback: ''
    });
    gis_inited = true; maybeEnableButtons();
}

function maybeEnableButtons() { 
    if (gapi_inited && gis_inited) {
        document.getElementById('authorizeButton').style.display = 'inline-block'; 
    }
}

function handleAuthClick() {
    tokenClient.callback = async (resp) => {
        if (resp.error !== undefined) { 
            showStatus('L·ªói ƒëƒÉng nh·∫≠p: ' + resp.error, 'error'); 
            return; 
        }
        document.getElementById('signoutButton').style.display = 'inline-block';
        document.getElementById('authorizeButton').style.display = 'none';
        document.getElementById('authStatus').innerHTML = '‚úÖ ƒê√£ ƒëƒÉng nh·∫≠p th√†nh c√¥ng!';
        await initializeApp();
    };
    if (gapi.client.getToken() === null) {
        tokenClient.requestAccessToken({prompt: 'consent'});
    } else {
        tokenClient.requestAccessToken({prompt: ''});
    }
}

function handleSignoutClick() {
    const token = gapi.client.getToken();
    if (token !== null) { 
        google.accounts.oauth2.revoke(token.access_token); 
        gapi.client.setToken(''); 
    }
    document.getElementById('authorizeButton').style.display = 'inline-block';
    document.getElementById('signoutButton').style.display = 'none';
    document.getElementById('authStatus').innerHTML = '';
    document.getElementById('mainApp').style.display = 'none';
}

async function initializeApp() {
    showLoading(true);
    await createMainFolder(); 
    await loadStoryHistory();
    await loadAiKnowledge();
    await loadAiGeneratedStories();
    updateAiStats();
    document.getElementById('mainApp').style.display = 'block';
    showStatus('Kh·ªüi t·∫°o ·ª©ng d·ª•ng th√†nh c√¥ng!', 'success');
    showLoading(false);
}

async function createMainFolder() {
    const folderName = 'QuanLyTruyen';
    const response = await gapi.client.drive.files.list({
        q: `name='${folderName}' and mimeType='application/vnd.google-apps.folder' and trashed=false`,
        fields: 'files(id, name)'
    });
    if (response.result.files.length > 0) {
        mainFolderId = response.result.files[0].id;
    } else {
        const folder = await gapi.client.drive.files.create({ 
            resource: {name: folderName, mimeType: 'application/vnd.google-apps.folder'}, 
            fields: 'id' 
        });
        mainFolderId = folder.result.id;
    }
    
    // Create AI Stories folder if it doesn't exist
    const aiFolderName = 'AI_Generated_Stories';
    const aiResponse = await gapi.client.drive.files.list({
        q: `name='${aiFolderName}' and mimeType='application/vnd.google-apps.folder' and '${mainFolderId}' in parents and trashed=false`,
        fields: 'files(id, name)'
    });
    if (aiResponse.result.files.length === 0) {
        const aiFolder = await gapi.client.drive.files.create({ 
            resource: {
                name: aiFolderName, 
                mimeType: 'application/vnd.google-apps.folder', 
                parents: [mainFolderId]
            }, 
            fields: 'id' 
        });
    }
}

async function createStoryFolder(storyTitle, isAiGenerated = false) {
    let parentId = mainFolderId;
    
    if (isAiGenerated) {
        // Find AI Stories folder
        const aiFolderName = 'AI_Generated_Stories';
        const response = await gapi.client.drive.files.list({
            q: `name='${aiFolderName}' and mimeType='application/vnd.google-apps.folder' and '${mainFolderId}' in parents and trashed=false`,
            fields: 'files(id, name)'
        });
        if (response.result.files.length > 0) {
            parentId = response.result.files[0].id;
        }
    }
    
    const folder = await gapi.client.drive.files.create({
        resource: { 
            name: storyTitle, 
            mimeType: 'application/vnd.google-apps.folder', 
            parents: [parentId] 
        }, 
        fields: 'id'
    });
    return folder.result.id;
}

async function saveStoryContent(storyTitle, chapterTitle, content, storyFolderId, isAiGenerated = false) {
    const fileMetadata = { 
        name: `${chapterTitle}.txt`, 
        parents: [storyFolderId],
        description: isAiGenerated ? "AI-Generated" : "User-Created"
    };
    
    await gapi.client.request({
        path: 'https://www.googleapis.com/upload/drive/v3/files', 
        method: 'POST',
        params: { uploadType: 'multipart' },
        headers: { 'Content-Type': 'multipart/related; boundary="foo_bar_baz"' },
        body: '--foo_bar_baz\r\nContent-Type: application/json; charset=UTF-8\r\n\r\n' +
              JSON.stringify(fileMetadata) + '\r\n--foo_bar_baz\r\nContent-Type: text/plain\r\n\r\n' +
              content + '\r\n--foo_bar_baz--'
    });
}

async function loadStoryHistory() {
    const response = await gapi.client.drive.files.list({
        q: `'${mainFolderId}' in parents and mimeType='application/vnd.google-apps.folder' and trashed=false`,
        fields: 'files(id, name, createdTime)', 
        orderBy: 'createdTime desc'
    });
    const folders = response.result.files; 
    storyHistory = [];
    
    for (let folder of folders) {
        // Skip AI Generated Stories folder
        if (folder.name === 'AI_Generated_Stories') continue;
        
        const filesResponse = await gapi.client.drive.files.list({
            q: `'${folder.id}' in parents and trashed=false`,
            fields: 'files(id, name, createdTime, description)'
        });
        storyHistory.push({ 
            storyTitle: folder.name, 
            folderId: folder.id, 
            createdTime: folder.createdTime, 
            chapters: filesResponse.result.files,
            isAiGenerated: false
        });
    }
    displayHistory(); 
    displayFolders();
}

async function loadAiGeneratedStories() {
    // Find AI Stories folder
    const aiFolderName = 'AI_Generated_Stories';
    const response = await gapi.client.drive.files.list({
        q: `name='${aiFolderName}' and mimeType='application/vnd.google-apps.folder' and '${mainFolderId}' in parents and trashed=false`,
        fields: 'files(id, name)'
    });
    
    if (response.result.files.length === 0) {
        aiGeneratedStories = [];
        return;
    }
    
    const aiFolderId = response.result.files[0].id;
    const aiFoldersResponse = await gapi.client.drive.files.list({
        q: `'${aiFolderId}' in parents and mimeType='application/vnd.google-apps.folder' and trashed=false`,
        fields: 'files(id, name, createdTime)', 
        orderBy: 'createdTime desc'
    });
    
    const aiFolders = aiFoldersResponse.result.files;
    aiGeneratedStories = [];
    
    for (let folder of aiFolders) {
        const filesResponse = await gapi.client.drive.files.list({
            q: `'${folder.id}' in parents and trashed=false`,
            fields: 'files(id, name, createdTime, description)'
        });
        aiGeneratedStories.push({ 
            storyTitle: folder.name, 
            folderId: folder.id, 
            createdTime: folder.createdTime, 
            chapters: filesResponse.result.files,
            isAiGenerated: true
        });
    }
}

// AI Training Functions
async function trainAI() {
    showLoading(true);
    showStatus('ƒêang b·∫Øt ƒë·∫ßu hu·∫•n luy·ªán AI...', 'success');
    
    const allFiles = [];
    for (let story of storyHistory) {
        for (let chapter of story.chapters) {
            if (chapter.name.endsWith('.txt')) {
                allFiles.push({...chapter, storyTitle: story.storyTitle});
            }
        }
    }
    
    document.getElementById('totalFiles').textContent = allFiles.length;
    let processedFiles = 0;
    
    for (let file of allFiles) {
        try {
            const response = await gapi.client.drive.files.get({
                fileId: file.id,
                alt: 'media'
            });
            
            const content = response.body;
            processContent(content, file.storyTitle, file.name);
            processedFiles++;
            
            // Update progress
            const progress = (processedFiles / allFiles.length) * 100;
            document.getElementById('progressFill').style.width = progress + '%';
            document.getElementById('trainedFiles').textContent = processedFiles;
            
            await new Promise(resolve => setTimeout(resolve, 100)); // Small delay
        } catch (error) {
            console.error('Error processing file:', file.name, error);
        }
    }
    
    aiKnowledge.trainedFiles = processedFiles;
    updateAiStats();
    saveAiKnowledge();
    showLoading(false);
    showStatus(`Hu·∫•n luy·ªán ho√†n th√†nh! ƒê√£ x·ª≠ l√Ω ${processedFiles} file.`, 'success');
}

function processContent(content, storyTitle, fileName) {
    // Simple text processing for AI learning
    const words = content.toLowerCase()
        .replace(/[^\w\s√†√°·∫°·∫£√£√¢·∫ß·∫•·∫≠·∫©·∫´ƒÉ·∫±·∫Ø·∫∑·∫≥·∫µ√®√©·∫π·∫ª·∫Ω√™·ªÅ·∫ø·ªá·ªÉ·ªÖ√¨√≠·ªã·ªâƒ©√≤√≥·ªç·ªè√µ√¥·ªì·ªë·ªô·ªï·ªó∆°·ªù·ªõ·ª£·ªü·ª°√π√∫·ª•·ªß≈©∆∞·ª´·ª©·ª±·ª≠·ªØ·ª≥√Ω·ªµ·ª∑·ªπƒë]/g, '')
        .split(/\s+/);
    
    words.forEach(word => {
        if (word.length > 2) { // Only add words with more than 2 characters
            aiKnowledge.vocabulary.add(word);
        }
    });
    
    // Store story information
    if (!aiKnowledge.stories.includes(storyTitle)) {
        aiKnowledge.stories.push(storyTitle);
    }
}

function updateAiStats() {
    document.getElementById('vocabularyCount').textContent = aiKnowledge.vocabulary.size;
}

async function saveAiKnowledge() {
    const knowledgeStr = JSON.stringify({
        vocabulary: Array.from(aiKnowledge.vocabulary),
        stories: aiKnowledge.stories,
        trainedFiles: aiKnowledge.trainedFiles
    });
    
    // Save to a file in the main folder
    const fileName = 'ai_knowledge.json';
    const response = await gapi.client.drive.files.list({
        q: `name='${fileName}' and '${mainFolderId}' in parents and trashed=false`,
        fields: 'files(id)'
    });
    
    if (response.result.files.length > 0) {
        // Update existing file
        const fileId = response.result.files[0].id;
        await gapi.client.request({
            path: `https://www.googleapis.com/upload/drive/v3/files/${fileId}`,
            method: 'PATCH',
            params: { uploadType: 'media' },
            body: knowledgeStr
        });
    } else {
        // Create new file
        const fileMetadata = { 
            name: fileName, 
            parents: [mainFolderId] 
        };
        
        await gapi.client.request({
            path: 'https://www.googleapis.com/upload/drive/v3/files', 
            method: 'POST',
            params: { uploadType: 'multipart' },
            headers: { 'Content-Type': 'multipart/related; boundary="foo_bar_baz"' },
            body: '--foo_bar_baz\r\nContent-Type: application/json; charset=UTF-8\r\n\r\n' +
                  JSON.stringify(fileMetadata) + '\r\n--foo_bar_baz\r\nContent-Type: application/json\r\n\r\n' +
                  knowledgeStr + '\r\n--foo_bar_baz--'
        });
    }
}

async function loadAiKnowledge() {
    const fileName = 'ai_knowledge.json';
    try {
        const response = await gapi.client.drive.files.list({
            q: `name='${fileName}' and '${mainFolderId}' in parents and trashed=false`,
            fields: 'files(id)'
        });
        
        if (response.result.files.length > 0) {
            const fileId = response.result.files[0].id;
            const fileResponse = await gapi.client.drive.files.get({
                fileId: fileId,
                alt: 'media'
            });
            
            const knowledge = JSON.parse(fileResponse.body);
            aiKnowledge.vocabulary = new Set(knowledge.vocabulary);
            aiKnowledge.stories = knowledge.stories;
            aiKnowledge.trainedFiles = knowledge.trainedFiles;
        }
    } catch (error) {
        console.error('Error loading AI knowledge:', error);
    }
}

function resetAI() {
    if (confirm('B·∫°n c√≥ ch·∫Øc ch·∫Øn mu·ªën reset to√†n b·ªô ki·∫øn th·ª©c c·ªßa AI?')) {
        aiKnowledge = { vocabulary: new Set(), stories: [], trainedFiles: 0 };
        updateAiStats();
        saveAiKnowledge();
        showStatus('ƒê√£ reset ki·∫øn th·ª©c c·ªßa AI!', 'success');
    }
}

// AI Story Generation
async function generateStory() {
    const chapterCount = parseInt(document.getElementById('chapterCount').value) || 100;
    if (chapterCount < 100 || chapterCount > 150) {
        showStatus('S·ªë ch∆∞∆°ng ph·∫£i t·ª´ 100 ƒë·∫øn 150!', 'error');
        return;
    }
    
    if (aiKnowledge.vocabulary.size < 100) {
        showStatus('AI ch∆∞a ƒë∆∞·ª£c hu·∫•n luy·ªán ƒë·ªß! H√£y hu·∫•n luy·ªán AI v·ªõi √≠t nh·∫•t 100 t·ª´ v·ª±ng.', 'error');
        return;
    }
    
    showLoading(true);
    showStatus('AI ƒëang t·∫°o truy·ªán m·ªõi...', 'success');
    
    // Generate a story title
    const titleWords = Array.from(aiKnowledge.vocabulary).filter(word => word.length > 3);
    const title = generateTitle(titleWords);
    
    // Create folder for the new story
    const storyFolderId = await createStoryFolder(title, true);
    
    // Generate chapters
    let generatedChapters = 0;
    const totalChapters = chapterCount;
    
    for (let i = 1; i <= totalChapters; i++) {
        const chapterTitle = `Ch∆∞∆°ng ${i}: ${generateChapterTitle(titleWords)}`;
        const chapterContent = generateChapterContent(titleWords);
        
        // Save chapter to Google Drive
        await saveStoryContent(title, chapterTitle, chapterContent, storyFolderId, true);
        
        generatedChapters++;
        
        // Update progress
        const progress = (generatedChapters / totalChapters) * 100;
        document.getElementById('generationProgressFill').style.width = progress + '%';
        document.getElementById('generationStatus').innerHTML = 
            `<div class="status success">ƒêang t·∫°o ch∆∞∆°ng ${generatedChapters}/${totalChapters}: ${chapterTitle}</div>`;
        
        // Small delay to avoid rate limiting
        await new Promise(resolve => setTimeout(resolve, 100));
    }
    
    // Reload AI generated stories
    await loadAiGeneratedStories();
    showLoading(false);
    showStatus(`ƒê√£ t·∫°o th√†nh c√¥ng truy·ªán "${title}" v·ªõi ${totalChapters} ch∆∞∆°ng!`, 'success');
    document.getElementById('generationStatus').innerHTML = '';
}

function generateTitle(words) {
    // Simple title generation based on learned vocabulary
    const titleLength = 2 + Math.floor(Math.random() * 3);
    let title = '';
    
    for (let i = 0; i < titleLength; i++) {
        const randomIndex = Math.floor(Math.random() * words.length);
        const word = words[randomIndex];
        title += word.charAt(0).toUpperCase() + word.slice(1) + ' ';
    }
    
    return title.trim();
}

function generateChapterTitle(words) {
    // Generate a chapter title
    const titleLength = 3 + Math.floor(Math.random() * 4);
    let title = '';
    
    for (let i = 0; i < titleLength; i++) {
        const randomIndex = Math.floor(Math.random() * words.length);
        const word = words[randomIndex];
        title += word.charAt(0).toUpperCase() + word.slice(1) + ' ';
    }
    
    return title.trim();
}

function generateChapterContent(words) {
    // Generate chapter content with 1500-2000 words
    const minWords = 1500;
    const maxWords = 2000;
    const targetWords = minWords + Math.floor(Math.random() * (maxWords - minWords + 1));
    
    let content = '';
    let wordCount = 0;
    
    while (wordCount < targetWords) {
        const sentenceLength = 5 + Math.floor(Math.random() * 10);
        let sentence = '';
        
        for (let i = 0; i < sentenceLength; i++) {
            const randomIndex = Math.floor(Math.random() * words.length);
            const word = words[randomIndex];
            
            if (i === 0) {
                sentence += word.charAt(0).toUpperCase() + word.slice(1);
            } else {
                sentence += ' ' + word;
            }
            
            wordCount++;
            if (wordCount >= targetWords) break;
        }
        
        sentence += '. ';
        content += sentence;
        
        // Add paragraph breaks occasionally
        if (Math.random() < 0.1) {
            content += '\n\n';
        }
    }
    
    return content;
}

// Chat with AI
async function sendChatMessage() {
    const input = document.getElementById('chatInput');
    const message = input.value.trim();
    
    if (!message) return;
    
    // Add user message to chat
    addChatMessage(message, 'user');
    input.value = '';
    
    // Generate AI response
    const response = generateAiResponse(message);
    
    // Add AI response to chat with a small delay to simulate thinking
    setTimeout(() => {
        addChatMessage(response, 'ai');
    }, 1000);
}

function addChatMessage(message, sender) {
    const chatContainer = document.getElementById('chatContainer');
    const messageDiv = document.createElement('div');
    messageDiv.className = `chat-message ${sender}`;
    messageDiv.textContent = message;
    chatContainer.appendChild(messageDiv);
    chatContainer.scrollTop = chatContainer.scrollHeight;
}

function generateAiResponse(message) {
    // Simple AI response based on learned vocabulary
    const responses = [
        "T√¥i ƒë√£ h·ªçc ƒë∆∞·ª£c nhi·ªÅu t·ª´ c√°c truy·ªán c·ªßa b·∫°n v√† c√≥ th·ªÉ t·∫°o ra nh·ªØng c√¢u chuy·ªán m·ªõi.",
        "D·ª±a tr√™n nh·ªØng g√¨ t√¥i ƒë√£ h·ªçc, t√¥i c√≥ th·ªÉ gi√∫p b·∫°n vi·∫øt truy·ªán ho·∫∑c t·∫°o truy·ªán t·ª± ƒë·ªông.",
        "H√£y cho t√¥i bi·∫øt th√™m v·ªÅ c√¢u chuy·ªán b·∫°n mu·ªën vi·∫øt, t√¥i s·∫Ω c·ªë g·∫Øng h·ªó tr·ª£ b·∫°n.",
        "T√¥i ƒë√£ ph√¢n t√≠ch nhi·ªÅu truy·ªán v√† hi·ªÉu ƒë∆∞·ª£c c·∫•u tr√∫c c√¢u chuy·ªán, nh√¢n v·∫≠t v√† t√¨nh ti·∫øt.",
        "B·∫°n mu·ªën t√¥i t·∫°o m·ªôt c√¢u chuy·ªán m·ªõi d·ª±a tr√™n phong c√°ch vi·∫øt c·ªßa nh·ªØng truy·ªán ƒë√£ c√≥?"
    ];
    
    // Check if message contains specific keywords
    if (message.toLowerCase().includes('truy·ªán') || message.toLowerCase().includes('story')) {
        return responses[Math.floor(Math.random() * responses.length)];
    }
    
    if (message.toLowerCase().includes('t·∫°o') || message.toLowerCase().includes('generate')) {
        return "T√¥i c√≥ th·ªÉ t·∫°o m·ªôt c√¢u chuy·ªán m·ªõi v·ªõi 100-150 ch∆∞∆°ng. H√£y nh·∫•n n√∫t 'AI T·∫°o Truy·ªán M·ªõi' ƒë·ªÉ b·∫Øt ƒë·∫ßu!";
    }
    
    if (message.toLowerCase().includes('hu·∫•n luy·ªán') || message.toLowerCase().includes('train')) {
        return `T√¥i ƒë√£ ƒë∆∞·ª£c hu·∫•n luy·ªán v·ªõi ${aiKnowledge.trainedFiles} file v√† h·ªçc ƒë∆∞·ª£c ${aiKnowledge.vocabulary.size} t·ª´ v·ª±ng.`;
    }
    
    // Default response
    return "T√¥i l√† AI h·ªó tr·ª£ vi·∫øt truy·ªán. T√¥i c√≥ th·ªÉ gi√∫p b·∫°n t·∫°o truy·ªán m·ªõi d·ª±a tr√™n c√°c truy·ªán ƒë√£ c√≥ trong th∆∞ vi·ªán.";
}

// UI Functions
function displayHistory() {
    const historyList = document.getElementById('historyList');
    historyList.innerHTML = '';
    
    if (storyHistory.length === 0) {
        historyList.innerHTML = '<div class="history-item">Ch∆∞a c√≥ truy·ªán n√†o.</div>';
        return;
    }
    
    storyHistory.forEach(story => {
        const item = document.createElement('div');
        item.className = 'history-item';
        item.onclick = () => viewStoryChapters(story);
        item.innerHTML = `
            <div class="story-title">${story.storyTitle}</div>
            <div class="story-chapter">${story.chapters.length} ch∆∞∆°ng</div>
            <div class="story-date">${new Date(story.createdTime).toLocaleDateString('vi-VN')}</div>
        `;
        historyList.appendChild(item);
    });
}

function displayFolders() {
    const folderList = document.getElementById('folderList');
    const existingStory = document.getElementById('existingStory');
    folderList.innerHTML = '';
    existingStory.innerHTML = '<option value="">-- Ch·ªçn truy·ªán --</option>';
    
    if (storyHistory.length === 0) {
        folderList.innerHTML = '<div class="history-item">Ch∆∞a c√≥ th∆∞ m·ª•c n√†o.</div>';
        return;
    }
    
    storyHistory.forEach(story => {
        // Add to folder list
        const item = document.createElement('div');
        item.className = 'history-item';
        item.innerHTML = `
            <div class="story-title">${story.storyTitle}</div>
            <div class="story-chapter">${story.chapters.length} ch∆∞∆°ng</div>
        `;
        folderList.appendChild(item);
        
        // Add to existing story dropdown
        const option = document.createElement('option');
        option.value = story.folderId;
        option.textContent = story.storyTitle;
        existingStory.appendChild(option);
    });
}

function toggleStoryMode() {
    const mode = document.getElementById('storyMode').value;
    if (mode === 'new') {
        document.getElementById('newStoryGroup').style.display = 'block';
        document.getElementById('existingStoryGroup').style.display = 'none';
        document.getElementById('submitButtonText').textContent = 'L∆∞u Truy·ªán M·ªõi';
    } else {
        document.getElementById('newStoryGroup').style.display = 'none';
        document.getElementById('existingStoryGroup').style.display = 'block';
        document.getElementById('submitButtonText').textContent = 'Th√™m Ch∆∞∆°ng M·ªõi';
    }
}

async function handleStoryFormSubmit(e) {
    e.preventDefault();
    showLoading(true);
    
    const mode = document.getElementById('storyMode').value;
    const storyTitle = document.getElementById('storyTitle').value;
    const chapterTitle = document.getElementById('chapterTitle').value;
    const storyContent = document.getElementById('storyContent').value;
    
    try {
        let storyFolderId;
        if (mode === 'new') {
            storyFolderId = await createStoryFolder(storyTitle);
        } else {
            storyFolderId = document.getElementById('existingStory').value;
            if (!storyFolderId) {
                showStatus('Vui l√≤ng ch·ªçn m·ªôt truy·ªán c√≥ s·∫µn!', 'error');
                showLoading(false);
                return;
            }
        }
        
        await saveStoryContent(storyTitle, chapterTitle, storyContent, storyFolderId);
        await loadStoryHistory();
        
        document.getElementById('storyForm').reset();
        showStatus('ƒê√£ l∆∞u truy·ªán th√†nh c√¥ng!', 'success');
    } catch (error) {
        console.error('Error saving story:', error);
        showStatus('C√≥ l·ªói x·∫£y ra khi l∆∞u truy·ªán!', 'error');
    }
    showLoading(false);
}

function showStatus(message, type) {
    const statusEl = document.getElementById('status');
    statusEl.textContent = message;
    statusEl.className = `status ${type}`;
    statusEl.style.display = 'block';
    setTimeout(() => { statusEl.style.display = 'none'; }, 5000);
}

function showLoading(show) {
    document.getElementById('loading').style.display = show ? 'block' : 'none';
}

// Modal Functions
function viewStoryChapters(story) {
    const modal = document.getElementById('chaptersModal');
    const title = document.getElementById('chaptersModalTitle');
    const chapterList = document.getElementById('chapterList');
    const chapterContent = document.getElementById('chapterContent');
    const chapterActions = document.getElementById('chapterActions');
    
    title.textContent = story.storyTitle;
    chapterList.innerHTML = '';
    chapterContent.style.display = 'none';
    chapterActions.style.display = 'none';
    
    story.chapters.forEach(chapter => {
        const item = document.createElement('div');
        item.className = 'chapter-item';
        item.onclick = () => viewChapterContent(chapter, story.folderId);
        item.textContent = chapter.name.replace('.txt', '');
        chapterList.appendChild(item);
    });
    
    modal.style.display = 'block';
}

async function viewChapterContent(chapter, folderId) {
    const chapterContent = document.getElementById('chapterContent');
    const chapterActions = document.getElementById('chapterActions');
    
    try {
        const response = await gapi.client.drive.files.get({
            fileId: chapter.id,
            alt: 'media'
        });
        
        chapterContent.textContent = response.body;
        chapterContent.style.display = 'block';
        chapterActions.style.display = 'block';
        currentEditingChapter = { id: chapter.id, content: response.body, name: chapter.name };
    } catch (error) {
        console.error('Error loading chapter content:', error);
        showStatus('C√≥ l·ªói khi t·∫£i n·ªôi dung ch∆∞∆°ng!', 'error');
    }
}

function editChapter() {
    const chapterContent = document.getElementById('chapterContent');
    chapterContent.contentEditable = true;
    chapterContent.focus();
    chapterContent.style.background = 'rgba(255, 255, 255, 0.1)';
    chapterContent.style.border = '1px solid rgba(102, 126, 234, 0.5)';
}

async function saveChapterChanges() {
    if (!currentEditingChapter) return;
    
    const chapterContent = document.getElementById('chapterContent');
    const newContent = chapterContent.textContent;
    
    try {
        await gapi.client.request({
            path: `https://www.googleapis.com/upload/drive/v3/files/${currentEditingChapter.id}`,
            method: 'PATCH',
            params: { uploadType: 'media' },
            body: newContent
        });
        
        chapterContent.contentEditable = false;
        chapterContent.style.background = 'rgba(255, 255, 255, 0.05)';
        chapterContent.style.border = 'none';
        currentEditingChapter.content = newContent;
        
        showStatus('ƒê√£ l∆∞u thay ƒë·ªïi th√†nh c√¥ng!', 'success');
    } catch (error) {
        console.error('Error saving chapter changes:', error);
        showStatus('C√≥ l·ªói khi l∆∞u thay ƒë·ªïi!', 'error');
    }
}

function cancelEdit() {
    const chapterContent = document.getElementById('chapterContent');
    chapterContent.textContent = currentEditingChapter.content;
    chapterContent.contentEditable = false;
    chapterContent.style.background = 'rgba(255, 255, 255, 0.05)';
    chapterContent.style.border = 'none';
}

async function deleteChapter() {
    if (!currentEditingChapter || !confirm('B·∫°n c√≥ ch·∫Øc ch·∫Øn mu·ªën x√≥a ch∆∞∆°ng n√†y?')) return;
    
    try {
        await gapi.client.drive.files.delete({ fileId: currentEditingChapter.id });
        closeModal('chaptersModal');
        await loadStoryHistory();
        showStatus('ƒê√£ x√≥a ch∆∞∆°ng th√†nh c√¥ng!', 'success');
    } catch (error) {
        console.error('Error deleting chapter:', error);
        showStatus('C√≥ l·ªói khi x√≥a ch∆∞∆°ng!', 'error');
    }
}

function closeModal(modalId) {
    document.getElementById(modalId).style.display = 'none';
    currentEditingChapter = null;
}

function viewAiStories() {
    const modal = document.getElementById('aiStoriesModal');
    const aiStoryList = document.getElementById('aiStoryList');
    
    aiStoryList.innerHTML = '';
    
    if (aiGeneratedStories.length === 0) {
        aiStoryList.innerHTML = '<div class="history-item">Ch∆∞a c√≥ truy·ªán n√†o ƒë∆∞·ª£c AI t·∫°o.</div>';
    } else {
        aiGeneratedStories.forEach(story => {
            const item = document.createElement('div');
            item.className = 'ai-story-item';
            item.onclick = () => {
                closeModal('aiStoriesModal');
                viewStoryChapters(story);
            };
            item.innerHTML = `
                <div class="ai-story-title">${story.storyTitle}</div>
                <div class="ai-story-info">${story.chapters.length} ch∆∞∆°ng - ${new Date(story.createdTime).toLocaleDateString('vi-VN')}</div>
            `;
            aiStoryList.appendChild(item);
        });
    }
    
    modal.style.display = 'block';
}

// Event Listeners
document.getElementById('authorizeButton').addEventListener('click', handleAuthClick);
document.getElementById('signoutButton').addEventListener('click', handleSignoutClick);
document.getElementById('storyForm').addEventListener('submit', handleStoryFormSubmit);
document.getElementById('trainAiButton').addEventListener('click', trainAI);
document.getElementById('resetAiButton').addEventListener('click', resetAI);
document.getElementById('generateStoryButton').addEventListener('click', generateStory);
document.getElementById('viewAiStoriesButton').addEventListener('click', viewAiStories);
document.getElementById('sendChatButton').addEventListener('click', sendChatMessage);
document.getElementById('chatInput').addEventListener('keypress', (e) => {
    if (e.key === 'Enter') sendChatMessage();
});

// Initialize the app
window.onload = () => {
    initializeGapi();
    initializeGis();
};
</script>
</body>
</html>
