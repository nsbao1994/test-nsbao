<!DOCTYPE html>
<html lang="vi">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Qu·∫£n l√Ω Truy·ªán - Google Drive Database</title>
    <script src="https://apis.google.com/js/api.js"></script>
    <script src="https://accounts.google.com/gsi/client"></script>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: linear-gradient(135deg, #1a1a2e 0%, #16213e 50%, #0f3460 100%);
            min-height: 100vh; 
            color: #ffffff;
            overflow-x: hidden;
        }
        .container {
            max-width: 100%;
            background: rgba(255, 255, 255, 0.05);
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.1);
            min-height: 100vh;
        }
        .header { 
            background: linear-gradient(45deg, #667eea, #764ba2); 
            color: white; 
            padding: 20px 15px;
            text-align: center; 
            position: sticky;
            top: 0;
            z-index: 100;
            backdrop-filter: blur(10px);
        }
        .header h1 { 
            font-size: 1.8em; 
            margin-bottom: 5px;
            font-weight: 700;
        }
        .header p {
            font-size: 0.9em;
            opacity: 0.9;
        }
        .main-content { 
            padding: 15px;
            padding-bottom: 80px;
        }
        .auth-section { 
            text-align: center; 
            margin-bottom: 20px;
            background: rgba(255, 255, 255, 0.05);
            padding: 20px;
            border-radius: 15px;
            border: 1px solid rgba(255, 255, 255, 0.1);
        }
        .btn {
            background: linear-gradient(45deg, #667eea, #764ba2);
            color: white; 
            border: none; 
            padding: 12px 20px;
            border-radius: 25px; 
            font-size: 14px; 
            cursor: pointer;
            transition: all 0.3s ease; 
            margin: 5px;
            min-height: 44px;
            display: inline-flex;
            align-items: center;
            justify-content: center;
            font-weight: 600;
            box-shadow: 0 4px 15px rgba(102, 126, 234, 0.3);
        }
        .btn:hover, .btn:active { 
            transform: translateY(-2px); 
            box-shadow: 0 6px 20px rgba(102, 126, 234, 0.4);
        }
        .btn:disabled { 
            opacity: 0.5; 
            cursor: not-allowed; 
            transform: none;
        }
        .btn.danger {
            background: linear-gradient(45deg, #ff6b6b, #ff5252);
            box-shadow: 0 4px 15px rgba(255, 107, 107, 0.3);
        }
        .btn.success {
            background: linear-gradient(45deg, #4ecdc4, #44a08d);
            box-shadow: 0 4px 15px rgba(78, 205, 196, 0.3);
        }
        .btn.info {
            background: linear-gradient(45deg, #45aaf2, #2d98da);
            box-shadow: 0 4px 15px rgba(69, 170, 242, 0.3);
        }
        .form-section {
            background: rgba(255, 255, 255, 0.05);
            padding: 20px; 
            border-radius: 15px; 
            margin-bottom: 20px;
            border: 1px solid rgba(255, 255, 255, 0.1);
            backdrop-filter: blur(10px);
        }
        .form-section h2 {
            margin-bottom: 20px;
            color: #ffffff;
            font-size: 1.3em;
        }
        .form-group { 
            margin-bottom: 20px; 
        }
        .form-group label { 
            display: block; 
            margin-bottom: 8px; 
            font-weight: 600; 
            color: #ffffff;
            font-size: 14px;
        }
        .form-group input, .form-group textarea, .form-group select {
            width: 100%; 
            padding: 15px; 
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 12px; 
            font-size: 16px; 
            transition: all 0.3s ease;
            background: rgba(255, 255, 255, 0.1);
            color: #ffffff;
            backdrop-filter: blur(5px);
        }
        .form-group input::placeholder,
        .form-group textarea::placeholder {
            color: rgba(255, 255, 255, 0.6);
        }
        .form-group input:focus,
        .form-group textarea:focus,
        .form-group select:focus {
            outline: none;
            border-color: #667eea;
            box-shadow: 0 0 0 3px rgba(102, 126, 234, 0.2);
            background: rgba(255, 255, 255, 0.15);
        }
        .form-group textarea { 
            min-height: 120px; 
            resize: vertical; 
        }
        .history-section {
            background: rgba(255, 255, 255, 0.05);
            border-radius: 15px; 
            overflow: hidden;
            margin-bottom: 20px;
            border: 1px solid rgba(255, 255, 255, 0.1);
        }
        .history-header { 
            background: linear-gradient(45deg, #667eea, #764ba2); 
            color: white; 
            padding: 15px; 
            text-align: center;
        }
        .history-header h2 {
            font-size: 1.2em;
        }
        .history-list { 
            max-height: 300px; 
            overflow-y: auto; 
        }
        .history-item { 
            padding: 15px; 
            border-bottom: 1px solid rgba(255, 255, 255, 0.1); 
            transition: background-color 0.3s ease;
            cursor: pointer;
        }
        .history-item:hover, .history-item:active { 
            background-color: rgba(255, 255, 255, 0.1); 
        }
        .story-title { 
            font-weight: 600; 
            color: #ffffff; 
            margin-bottom: 5px;
            font-size: 16px;
        }
        .story-chapter { 
            color: rgba(255, 255, 255, 0.7); 
            font-size: 14px; 
            margin-bottom: 5px; 
        }
        .story-date { 
            color: rgba(255, 255, 255, 0.5); 
            font-size: 12px; 
        }
        .status { 
            padding: 15px; 
            border-radius: 12px; 
            margin: 15px 0; 
            display: none;
            font-weight: 600;
        }
        .status.success { 
            background: rgba(78, 205, 196, 0.2); 
            color: #4ecdc4; 
            border: 1px solid rgba(78, 205, 196, 0.3);
            display: block;
        }
        .status.error { 
            background: rgba(255, 107, 107, 0.2); 
            color: #ff6b6b; 
            border: 1px solid rgba(255, 107, 107, 0.3);
            display: block;
        }
        .loading { 
            display: none; 
            text-align: center; 
            padding: 30px;
            background: rgba(255, 255, 255, 0.05);
            border-radius: 15px;
            margin: 20px 0;
        }
        .loading.show {
            display: block;
        }
        .spinner {
            border: 3px solid rgba(255, 255, 255, 0.1); 
            border-top: 3px solid #667eea;
            border-radius: 50%; 
            width: 40px; 
            height: 40px;
            animation: spin 1s linear infinite; 
            margin: 0 auto 15px;
        }
        @keyframes spin { 
            0% { transform: rotate(0deg); } 
           100% { transform: rotate(360deg); } 
        }
        .grid { 
            display: flex;
            flex-direction: column;
            gap: 20px; 
            margin-top: 20px; 
        }
        
        /* AI Training Section */
        .ai-section {
            background: linear-gradient(135deg, rgba(102, 126, 234, 0.1), rgba(118, 75, 162, 0.1));
            border: 1px solid rgba(102, 126, 234, 0.3);
            padding: 20px;
            border-radius: 15px;
            margin-bottom: 20px;
        }
        .ai-section h2 {
            color: #667eea;
            margin-bottom: 15px;
            font-size: 1.3em;
        }
        
        /* Progress Bar */
        .progress-bar {
            width: 100%;
            height: 6px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 3px;
            overflow: hidden;
            margin: 10px 0;
        }
        .progress-fill {
            height: 100%;
            background: linear-gradient(45deg, #667eea, #764ba2);
            transition: width 0.3s ease;
            width: 0%;
        }
        
        /* AI Generated Stories Section */
        .ai-generated-section {
            background: linear-gradient(135deg, rgba(78, 205, 196, 0.1), rgba(44, 160, 141, 0.1));
            border: 1px solid rgba(78, 205, 196, 0.3);
            padding: 20px;
            border-radius: 15px;
            margin-bottom: 20px;
        }
        .ai-generated-section h2 {
            color: #4ecdc4;
            margin-bottom: 15px;
            font-size: 1.3em;
        }
        .ai-story-controls {
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
            margin-bottom: 15px;
        }
        .ai-story-controls input {
            flex: 1;
            min-width: 150px;
            padding: 12px 15px;
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 25px;
            background: rgba(255, 255, 255, 0.1);
            color: #ffffff;
        }
        
        /* Navigation Menu */
        .nav-menu {
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
            margin-bottom: 20px;
            background: rgba(255, 255, 255, 0.05);
            padding: 15px;
            border-radius: 15px;
            border: 1px solid rgba(255, 255, 255, 0.1);
        }
        .nav-menu button {
            flex: 1;
            min-width: 120px;
        }
        .nav-menu button.active {
            background: linear-gradient(45deg, #ff9500, #ff7300);
            box-shadow: 0 4px 15px rgba(255, 149, 0, 0.4);
        }
        
        /* Content Sections */
        .content-section {
            display: none;
        }
        .content-section.active {
            display: block;
        }
        
        /* Modal */
        .modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.7);
            z-index: 1000;
            overflow-y: auto;
            padding: 20px;
        }
        .modal.show {
            display: block;
        }
        .modal-content {
            background: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%);
            margin: 40px auto;
            padding: 20px;
            border-radius: 15px;
            max-width: 800px;
            box-shadow: 0 5px 25px rgba(0, 0, 0, 0.5);
            position: relative;
        }
        .close-modal {
            position: absolute;
            top: 15px;
            right: 20px;
            font-size: 28px;
            font-weight: bold;
            cursor: pointer;
            color: #fff;
        }
        .chapter-list {
            max-height: 400px;
            overflow-y: auto;
            margin: 15px 0;
        }
        .chapter-item {
            padding: 12px;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
            cursor: pointer;
        }
        .chapter-item:hover {
            background-color: rgba(255, 255, 255, 0.1);
        }
        .chapter-content {
            margin-top: 20px;
            padding: 15px;
            background: rgba(255, 255, 255, 0.05);
            border-radius: 10px;
            max-height: 500px;
            overflow-y: auto;
            white-space: pre-wrap;
        }
        .chapter-actions {
            display: flex;
            gap: 10px;
            margin-top: 15px;
        }
        
        /* C·∫£nh b√°o n·ªôi dung 18+ */
        .adult-warning {
            background: rgba(255, 107, 107, 0.2);
            border: 1px solid rgba(255, 107, 107, 0.5);
            color: #ff6b6b;
            padding: 15px;
            border-radius: 10px;
            margin: 15px 0;
            text-align: center;
            font-weight: bold;
        }
        
        .training-details {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 15px;
            margin: 20px 0;
        }
        
        .training-item {
            background: rgba(255, 255, 255, 0.05);
            padding: 15px;
            border-radius: 10px;
            border: 1px solid rgba(255, 255, 255, 0.1);
        }
        
        .training-item h4 {
            color: #667eea;
            margin-bottom: 10px;
            font-size: 0.9em;
        }
        
        .training-item .count {
            font-size: 1.5em;
            font-weight: bold;
            color: #4ecdc4;
        }
        
        /* Mobile optimizations */
        @media (max-width: 768px) {
            .header h1 { font-size: 1.6em; }
            .main-content { padding: 10px; }
            .form-section, .history-section { margin-bottom: 15px; }
            .btn { font-size: 14px; padding: 10px 16px; }
            .modal-content { margin: 20px 10px; padding: 15px; }
            .nav-menu { flex-direction: column; }
            .training-details { grid-template-columns: 1fr; }
        }
        
        /* Scrollbar styling */
        ::-webkit-scrollbar { width: 6px; }
        ::-webkit-scrollbar-track { background: rgba(255, 255, 255, 0.1); }
        ::-webkit-scrollbar-thumb { background: rgba(102, 126, 234, 0.5); border-radius: 3px; }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>ü§ñ AI Truy·ªán Manager Pro</h1>
            <p>Qu·∫£n l√Ω & Hu·∫•n luy·ªán AI v·ªõi Google Drive - Ch·ªß ƒë·ªÅ chuy√™n bi·ªát n√¢ng c·∫•p</p>
        </div>
        <div class="main-content">
            <div class="auth-section">
                <button id="authorizeButton" class="btn">üîê ƒêƒÉng nh·∫≠p Google Drive</button>
                <button id="signoutButton" class="btn danger" style="display: none;">üö™ ƒêƒÉng xu·∫•t</button>
                <div id="authStatus"></div>
            </div>
            
            <div class="loading" id="loading">
                <div class="spinner"></div>
                <p>ƒêang x·ª≠ l√Ω...</p>
            </div>
            
            <div class="status" id="status"></div>
            
            <div id="mainApp" style="display: none;">
                <!-- Navigation Menu -->
                <div class="nav-menu">
                    <button id="menuTraining" class="btn info active" data-section="trainingSection">üß† Hu·∫•n luy·ªán AI</button>
                    <button id="menuGeneration" class="btn success" data-section="generationSection">üìñ AI T·∫°o Truy·ªán</button>
                    <button id="menuManagement" class="btn" data-section="managementSection">‚úèÔ∏è Qu·∫£n l√Ω Truy·ªán</button>
                    <button id="menuHistory" class="btn" data-section="historySection">üìö L·ªãch s·ª≠ Truy·ªán</button>
                </div>
                
                <!-- AI Training Section -->
                <div id="trainingSection" class="content-section active">
                    <div class="ai-section">
                        <h2>üß† Hu·∫•n luy·ªán AI N√¢ng Cao</h2>
                        <div class="training-details">
                            <div class="training-item">
                                <h4>üìù T·ªïng s·ªë file</h4>
                                <div class="count" id="totalFiles">0</div>
                            </div>
                            <div class="training-item">
                                <h4>‚úÖ ƒê√£ hu·∫•n luy·ªán</h4>
                                <div class="count" id="trainedFiles">0</div>
                            </div>
                            <div class="training-item">
                                <h4>üìñ T·ª´ v·ª±ng h·ªçc ƒë∆∞·ª£c</h4>
                                <div class="count" id="vocabularyCount">0</div>
                            </div>
                            <div class="training-item">
                                <h4>üí¨ H·ªôi tho·∫°i</h4>
                                <div class="count" id="dialogueCount">0</div>
                            </div>
                            <div class="training-item">
                                <h4>üè† B·ªëi c·∫£nh</h4>
                                <div class="count" id="contextCount">0</div>
                            </div>
                            <div class="training-item">
                                <h4>üë§ Chi ti·∫øt nh√¢n v·∫≠t</h4>
                                <div class="count" id="characterCount">0</div>
                            </div>
                            <div class="training-item">
                                <h4>‚ù§Ô∏è C·∫£m x√∫c</h4>
                                <div class="count" id="emotionCount">0</div>
                            </div>
                            <div class="training-item">
                                <h4>üî• N·ªôi dung 18+</h4>
                                <div class="count" id="adultCount">0</div>
                            </div>
                            <div class="training-item">
                                <h4>‚è∞ Th·ªùi gian</h4>
                                <div class="count" id="timeCount">0</div>
                            </div>
                            <div class="training-item">
                                <h4>üìç ƒê·ªãa ƒëi·ªÉm</h4>
                                <div class="count" id="locationCount">0</div>
                            </div>
                            <div class="training-item">
                                <h4>üìú C·∫•u tr√∫c c√¢u</h4>
                                <div class="count" id="sentenceCount">0</div>
                            </div>
                            <div class="training-item">
                                <h4>üé≠ T√¨nh ti·∫øt</h4>
                                <div class="count" id="plotCount">0</div>
                            </div>
                        </div>
                        <div class="progress-bar">
                            <div class="progress-fill" id="progressFill"></div>
                        </div>
                        <button id="trainAiButton" class="btn success">üéØ B·∫Øt ƒë·∫ßu hu·∫•n luy·ªán AI</button>
                        <button id="resetAiButton" class="btn danger">üîÑ Reset AI</button>
                    </div>
                </div>
                
                <!-- AI Story Generation Section -->
                <div id="generationSection" class="content-section">
                    <div class="ai-generated-section">
                        <h2>üìñ AI T·∫°o Truy·ªán T·ª± ƒê·ªông</h2>
                        
                        <div class="adult-warning">
                            ‚ö†Ô∏è C·∫£nh b√°o: AI s·∫Ω t·∫°o n·ªôi dung theo ng√¥i th·ª© nh·∫•t v√† c√≥ th·ªÉ ch·ª©a n·ªôi dung 18+.
                        </div>
                        
                        <div class="ai-story-controls">
                            <input type="number" id="chapterCount" placeholder="S·ªë ch∆∞∆°ng (50-200)" min="50" max="200" value="50">
                            <button id="generateStoryButton" class="btn success">üöÄ AI T·∫°o Truy·ªán M·ªõi</button>
                            <button id="viewAiStoriesButton" class="btn">üìö Xem Truy·ªán AI ƒê√£ T·∫°o</button>
                        </div>
                        <div class="progress-bar">
                            <div class="progress-fill" id="generationProgressFill"></div>
                        </div>
                        <div id="generationStatus"></div>
                    </div>
                </div>
                
                <!-- Story Management Section -->
                <div id="managementSection" class="content-section">
                    <div class="form-section">
                        <h2>‚úèÔ∏è Th√™m Truy·ªán / Ch∆∞∆°ng M·ªõi</h2>
                        <form id="storyForm">
                            <div class="form-group">
                                <label for="storyMode">Ch·∫ø ƒë·ªô:</label>
                                <select id="storyMode">
                                    <option value="new">T·∫°o truy·ªán m·ªõi</option>
                                    <option value="existing">Th√™m ch∆∞∆°ng v√†o truy·ªán c√≥ s·∫µn</option>
                                </select>
                            </div>
                            <div class="form-group" id="newStoryGroup">
                                <label for="storyTitle">T√™n Truy·ªán M·ªõi:</label>
                                <input type="text" id="storyTitle" placeholder="Nh·∫≠p t√™n truy·ªán m·ªõi...">
                            </div>
                            <div class="form-group" id="existingStoryGroup" style="display: none;">
                                <label for="existingStory">Ch·ªçn Truy·ªán C√≥ S·∫µn:</label>
                                <select id="existingStory"><option value="">-- Ch·ªçn truy·ªán --</option></select>
                            </div>
                            <div class="form-group">
                                <label for="chapterTitle">T√™n Ch∆∞∆°ng:</label>
                                <input type="text" id="chapterTitle" required placeholder="Nh·∫≠p t√™n ch∆∞∆°ng...">
                            </div>
                            <div class="form-group">
                                <label for="storyContent">N·ªôi dung:</label>
                                <textarea id="storyContent" required placeholder="Nh·∫≠p n·ªôi dung truy·ªán..."></textarea>
                            </div>
                            <button type="submit" class="btn">üíæ <span id="submitButtonText">L∆∞u Truy·ªán M·ªõi</span></button>
                        </form>
                    </div>
                </div>
                
                <!-- History Section -->
                <div id="historySection" class="content-section">
                    <div class="grid">
                        <div class="history-section">
                            <div class="history-header"><h2>üìñ L·ªãch s·ª≠ Truy·ªán</h2></div>
                            <div class="history-list" id="historyList"></div>
                        </div>
                        <div class="history-section">
                            <div class="history-header"><h2>üóÇ Th∆∞ m·ª•c Google Drive</h2></div>
                            <div class="history-list" id="folderList"></div>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- Modal for AI Generated Stories -->
    <div id="aiStoriesModal" class="modal">
        <div class="modal-content">
            <span class="close-modal" onclick="closeModal('aiStoriesModal')">&times;</span>
            <h2>üìö Truy·ªán ƒê∆∞·ª£c T·∫°o B·ªüi AI</h2>
            <div class="chapter-list" id="aiStoryList">
                <!-- AI stories will be listed here -->
            </div>
        </div>
    </div>

    <!-- Modal for Viewing Chapters -->
    <div id="chaptersModal" class="modal">
        <div class="modal-content">
            <span class="close-modal" onclick="closeModal('chaptersModal')">&times;</span>
            <h2 id="chaptersModalTitle">Ch∆∞∆°ng Truy·ªán</h2>
            <div class="chapter-list" id="chapterList">
                <!-- Chapters will be listed here -->
            </div>
            <div class="chapter-content" id="chapterContent" style="display: none;">
                <!-- Chapter content will be displayed here -->
            </div>
            <div class="chapter-actions" id="chapterActions" style="display: none;">
                <button class="btn" onclick="editChapter()">‚úèÔ∏è S·ª≠a Ch∆∞∆°ng</button>
                <button class="btn danger" onclick="deleteChapter()">üóëÔ∏è X√≥a Ch∆∞∆°ng</button>
                <button class="btn" onclick="saveChapterChanges()">üíæ L∆∞u Thay ƒê·ªïi</button>
                <button class="btn" onclick="cancelEdit()">‚ùå H·ªßy</button>
            </div>
        </div>
    </div>

<script>
const CLIENT_ID = '199144324956-rsc4tttep6uq67poepa2nclieqi82avj.apps.googleusercontent.com';
const API_KEY = 'AIzaSyBGHB5FnrtMXliWtk3X6FZAl0CE2neNgZM';
const DISCOVERY_DOC = 'https://www.googleapis.com/discovery/v1/apis/drive/v3/rest';
const SCOPES = 'https://www.googleapis.com/auth/drive.file';

let tokenClient, gapi_inited = false, gis_inited = false, mainFolderId = null, storyHistory = [];
let aiKnowledge = { 
    vocabulary: new Set(), 
    stories: [], 
    trainedFiles: 0,
    dialogues: new Set(),
    contexts: new Set(),
    characterDetails: new Set(),
    emotions: new Set(),
    adultContent: new Set(),
    timeReferences: new Set(),
    locations: new Set(),
    sentenceStructures: new Set(),
    plotPoints: new Set(),
    characterNames: new Set(),
    environmentDetails: new Set(),
    transitionWords: new Set(),
    generationHistory: []
};
let aiGeneratedStories = [];
let currentEditingChapter = null;

// Initialize Google API
async function initializeGapi() {
    await gapi.load('client', async () => {
        await gapi.client.init({ apiKey: API_KEY, discoveryDocs: [DISCOVERY_DOC] });
        gapi_inited = true; 
        maybeEnableButtons();
    });
}

function initializeGis() {
    tokenClient = google.accounts.oauth2.initTokenClient({
        client_id: CLIENT_ID, 
        scope: SCOPES, 
        callback: ''
    });
    gis_inited = true; 
    maybeEnableButtons();
}

function maybeEnableButtons() { 
    if (gapi_inited && gis_inited) {
        document.getElementById('authorizeButton').style.display = 'inline-block'; 
    }
}

function handleAuthClick() {
    tokenClient.callback = async (resp) => {
        if (resp.error !== undefined) { 
            showStatus('L·ªói ƒëƒÉng nh·∫≠p: ' + resp.error, 'error'); 
            return; 
        }
        document.getElementById('signoutButton').style.display = 'inline-block';
        document.getElementById('authorizeButton').style.display = 'none';
        document.getElementById('authStatus').innerHTML = '‚úÖ ƒê√£ ƒëƒÉng nh·∫≠p th√†nh c√¥ng!';
        await initializeApp();
    };
    
    if (gapi.client.getToken() === null) {
        tokenClient.requestAccessToken({prompt: 'consent'});
    } else {
        tokenClient.requestAccessToken({prompt: ''});
    }
}

function handleSignoutClick() {
    const token = gapi.client.getToken();
    if (token !== null) { 
        google.accounts.oauth2.revoke(token.access_token); 
        gapi.client.setToken(''); 
    }
    document.getElementById('authorizeButton').style.display = 'inline-block';
    document.getElementById('signoutButton').style.display = 'none';
    document.getElementById('authStatus').innerHTML = '';
    document.getElementById('mainApp').style.display = 'none';
}

async function initializeApp() {
    showLoading(true);
    await createMainFolder(); 
    await loadStoryHistory();
    await loadAiKnowledge();
    updateAiStats();
    document.getElementById('mainApp').style.display = 'block';
    showStatus('Kh·ªüi t·∫°o ·ª©ng d·ª•ng th√†nh c√¥ng!', 'success');
    showLoading(false);
}

async function createMainFolder() {
    const folderName = 'QuanLyTruyen';
    try {
        const response = await gapi.client.drive.files.list({
            q: `name='${folderName}' and mimeType='application/vnd.google-apps.folder' and trashed=false`,
            fields: 'files(id, name)'
        });
        
        if (response.result.files.length > 0) {
            mainFolderId = response.result.files[0].id;
        } else {
            const folder = await gapi.client.drive.files.create({ 
                resource: {name: folderName, mimeType: 'application/vnd.google-apps.folder'}, 
                fields: 'id' 
            });
            mainFolderId = folder.result.id;
        }
    } catch (error) {
        console.error('Error creating main folder:', error);
        showStatus('L·ªói t·∫°o th∆∞ m·ª•c ch√≠nh!', 'error');
    }
}

async function createStoryFolder(storyTitle) {
    try {
        const folder = await gapi.client.drive.files.create({
            resource: { 
                name: storyTitle, 
                mimeType: 'application/vnd.google-apps.folder', 
                parents: [mainFolderId] 
            }, 
            fields: 'id'
        });
        return folder.result.id;
    } catch (error) {
        console.error('Error creating story folder:', error);
        throw error;
    }
}

async function saveStoryContent(storyTitle, chapterTitle, content, storyFolderId) {
    const fileMetadata = { 
        name: `${chapterTitle}.txt`, 
        parents: [storyFolderId]
    };
    
    try {
        await gapi.client.request({
            path: 'https://www.googleapis.com/upload/drive/v3/files', 
            method: 'POST',
            params: { uploadType: 'multipart' },
            headers: { 'Content-Type': 'multipart/related; boundary="foo_bar_baz"' },
            body: '--foo_bar_baz\r\nContent-Type: application/json; charset=UTF-8\r\n\r\n' +
                  JSON.stringify(fileMetadata) + '\r\n--foo_bar_baz\r\nContent-Type: text/plain\r\n\r\n' +
                  content + '\r\n--foo_bar_baz--'
        });
    } catch (error) {
        console.error('Error saving story content:', error);
        throw error;
    }
}

async function loadStoryHistory() {
    try {
        const response = await gapi.client.drive.files.list({
            q: `'${mainFolderId}' in parents and mimeType='application/vnd.google-apps.folder' and trashed=false`,
            fields: 'files(id, name, createdTime)', 
            orderBy: 'createdTime desc'
        });
        
        const folders = response.result.files; 
        storyHistory = [];
        
        for (let folder of folders) {
            const filesResponse = await gapi.client.drive.files.list({
                q: `'${folder.id}' in parents and trashed=false`,
                fields: 'files(id, name, createdTime)'
            });
            storyHistory.push({ 
                storyTitle: folder.name, 
                folderId: folder.id, 
                createdTime: folder.createdTime, 
                chapters: filesResponse.result.files
            });
        }
        
        displayHistory(); 
        displayFolders();
        updateExistingStoryDropdown();
    } catch (error) {
        console.error('Error loading story history:', error);
        showStatus('L·ªói t·∫£i l·ªãch s·ª≠ truy·ªán!', 'error');
    }
}

// Utility functions
function showLoading(show) {
    const loading = document.getElementById('loading');
    if (show) {
        loading.classList.add('show');
    } else {
        loading.classList.remove('show');
    }
}

function showStatus(message, type = 'success') {
    const status = document.getElementById('status');
    status.textContent = message;
    status.className = `status ${type}`;
    
    setTimeout(() => {
        status.style.display = 'none';
    }, 5000);
}

function displayHistory() {
    const historyList = document.getElementById('historyList');
    if (!historyList) return;
    
    historyList.innerHTML = '';
    
    storyHistory.forEach(story => {
        const item = document.createElement('div');
        item.className = 'history-item';
        item.innerHTML = `
            <div class="story-title">${story.storyTitle}</div>
            <div class="story-chapter">${story.chapters.length} ch∆∞∆°ng</div>
            <div class="story-date">${new Date(story.createdTime).toLocaleDateString('vi-VN')}</div>
        `;
        
        item.onclick = () => viewChapters(story);
        historyList.appendChild(item);
    });
}

function displayFolders() {
    const folderList = document.getElementById('folderList');
    if (!folderList) return;
    
    folderList.innerHTML = '';
    
    storyHistory.forEach(story => {
        const item = document.createElement('div');
        item.className = 'history-item';
        item.innerHTML = `
            <div class="story-title">üìÅ ${story.storyTitle}</div>
            <div class="story-chapter">ID: ${story.folderId}</div>
            <div class="story-date">T·∫°o: ${new Date(story.createdTime).toLocaleDateString('vi-VN')}</div>
        `;
        
        folderList.appendChild(item);
    });
}

function updateExistingStoryDropdown() {
    const existingStorySelect = document.getElementById('existingStory');
    if (!existingStorySelect) return;
    
    existingStorySelect.innerHTML = '<option value="">-- Ch·ªçn truy·ªán --</option>';
    
    storyHistory.forEach(story => {
        const option = document.createElement('option');
        option.value = story.folderId;
        option.textContent = story.storyTitle;
        existingStorySelect.appendChild(option);
    });
}

// AI Training Functions
async function trainAI() {
    showLoading(true);
    showStatus('ƒêang b·∫Øt ƒë·∫ßu hu·∫•n luy·ªán AI v·ªõi ph√¢n t√≠ch chuy√™n s√¢u...', 'success');
    
    const allFiles = [];
    for (let story of storyHistory) {
        for (let chapter of story.chapters) {
            if (chapter.name.endsWith('.txt')) {
                allFiles.push({...chapter, storyTitle: story.storyTitle});
            }
        }
    }
    
    document.getElementById('totalFiles').textContent = allFiles.length;
    let processedFiles = 0;
    
    for (let file of allFiles) {
        try {
            const response = await gapi.client.drive.files.get({
                fileId: file.id,
                alt: 'media'
            });
            
            const content = response.body;
            await advancedContentAnalysis(content, file.storyTitle, file.name);
            processedFiles++;
            
            // Update progress
            const progress = (processedFiles / allFiles.length) * 100;
            document.getElementById('progressFill').style.width = progress + '%';
            document.getElementById('trainedFiles').textContent = processedFiles;
            
            await new Promise(resolve => setTimeout(resolve, 100));
        } catch (error) {
            console.error('Error processing file:', file.name, error);
        }
    }
    
    aiKnowledge.trainedFiles = processedFiles;
    updateAiStats();
    await saveAiKnowledge();
    showLoading(false);
    showStatus(`Hu·∫•n luy·ªán ho√†n th√†nh! ƒê√£ ph√¢n t√≠ch ${processedFiles} file v·ªõi AI h·ªçc s√¢u.`, 'success');
}

async function advancedContentAnalysis(content, storyTitle, fileName) {
    const sentences = content.split(/[.!?]+/).filter(s => s.trim().length > 5);
    const words = content.toLowerCase().split(/\s+/).filter(w => w.length > 2);
    
    // 1. H·ªçc t·ª´ v·ª±ng c∆° b·∫£n
    words.forEach(word => {
        const cleanWord = word.replace(/[^\w√†√°·∫°·∫£√£√¢·∫ß·∫•·∫≠·∫©·∫´ƒÉ·∫±·∫Ø·∫∑·∫≥·∫µ√®√©·∫π·∫ª·∫Ω√™·ªÅ·∫ø·ªá·ªÉ·ªÖ√¨√≠·ªã·ªâƒ©√≤√≥·ªç·ªè√µ√¥·ªì·ªë·ªô·ªï·ªó∆°·ªù·ªõ·ª£·ªü·ª°√π√∫·ª•·ªß≈©∆∞·ª´·ª©·ª±·ª≠·ªØ·ª≥√Ω·ªµ·ª∑·ªπƒë]/g, '');
        if (cleanWord.length > 2) {
            aiKnowledge.vocabulary.add(cleanWord);
        }
    });
    
    // 2. Ph√¢n t√≠ch v√† h·ªçc h·ªôi tho·∫°i
    analyzeDialogues(content);
    
    // 3. Ph√¢n t√≠ch b·ªëi c·∫£nh v√† ƒë·ªãa ƒëi·ªÉm
    analyzeContextsAndLocations(content);
    
    // 4. Ph√¢n t√≠ch chi ti·∫øt nh√¢n v·∫≠t
    analyzeCharacterDetails(content);
    
    // 5. Ph√¢n t√≠ch c·∫£m x√∫c
    analyzeEmotions(content);
    
    // 6. Ph√¢n t√≠ch n·ªôi dung 18+
    analyzeAdultContent(content);
    
    // 7. Ph√¢n t√≠ch th·ªùi gian
    analyzeTimeReferences(content);
    
    // 8. H·ªçc c·∫•u tr√∫c c√¢u
    sentences.forEach(sentence => {
        if (sentence.split(' ').length > 10) {
            aiKnowledge.sentenceStructures.add(sentence.trim());
        }
    });
    
    // 9. Ph√¢n t√≠ch t√¨nh ti·∫øt
    analyzePlotPoints(content);
    
    // 10. L∆∞u story ƒë·ªÉ h·ªçc
    aiKnowledge.stories.push({
        content: content,
        storyTitle: storyTitle,
        fileName: fileName,
        analysisTimestamp: new Date().toISOString()
    });
}

function analyzeDialogues(content) {
    const dialoguePatterns = [
        /"([^"]{10,})"/g,
        /"([^"]{10,})"/g,
        /- ([A-Z√Ä√Å·∫†·∫¢√É√Ç·∫¶·∫§·∫¨·∫®·∫™ƒÇ·∫∞·∫Æ·∫∂·∫≤·∫¥√à√â·∫∏·∫∫·∫º√ä·ªÄ·∫æ·ªÜ·ªÇ·ªÑ√å√ç·ªä·ªàƒ®√í√ì·ªå·ªé√ï√î·ªí·ªê·ªò·ªî·ªñ∆†·ªú·ªö·ª¢·ªû·ª†√ô√ö·ª§·ª¶≈®∆Ø·ª™·ª®·ª∞·ª¨·ªÆ·ª≤√ù·ª¥·ª∂·ª∏ƒê][^.!?]{10,}[.!?])/g
    ];
    
    dialoguePatterns.forEach(pattern => {
        let match;
        while ((match = pattern.exec(content)) !== null) {
            const dialogue = match[1].trim();
            if (dialogue.length > 10 && !dialogue.includes('{')) {
                aiKnowledge.dialogues.add(dialogue);
            }
        }
    });
}

function analyzeContextsAndLocations(content) {
    const contextKeywords = [
        'trong ph√≤ng', '·ªü nh√†', 't·∫°i', 'khi', 'l√∫c', 'v√†o l√∫c', 'bu·ªïi', 'ng√†y', 'ƒë√™m',
        'ph√≤ng kh√°ch', 'ph√≤ng ng·ªß', 'nh√† b·∫øp', 'ph√≤ng t·∫Øm', 'ban c√¥ng', 's√¢n v∆∞·ªùn',
        'tr√™n gi∆∞·ªùng', 'd∆∞·ªõi b√†n', 'b√™n c·∫°nh', 'g·∫ßn', 'xa', 'tr∆∞·ªõc', 'sau'
    ];
    
    const sentences = content.split(/[.!?]+/);
    sentences.forEach(sentence => {
        contextKeywords.forEach(keyword => {
            if (sentence.toLowerCase().includes(keyword)) {
                const context = sentence.trim();
                if (context.length > 20 && context.length < 200) {
                    aiKnowledge.contexts.add(context);
                }
            }
        });
        
        const locationMatch = sentence.match(/(trong|·ªü|t·∫°i|ƒë·∫øn|v·ªÅ) ([^,.\s]{2,})/gi);
        if (locationMatch) {
            locationMatch.forEach(loc => {
                aiKnowledge.locations.add(loc.trim());
            });
        }
    });
}

function analyzeCharacterDetails(content) {
    const characterKeywords = [
        'm·∫Øt', 't√≥c', 'da', 'm·∫∑t', 'd√°ng', 'cao', 'th·∫•p', 'g·∫ßy', 'b√©o', 'ƒë·∫πp', 'x·∫•u',
        'c√¥ ·∫•y', 'anh ·∫•y', 'ch·ªã', 'em', 'b√°c', 'ch√∫', 'c√¥', 'ng∆∞·ªùi', 'con',
        'b·ªë ch·ªìng', 'con d√¢u', 'v·ª£ t√¥i', 'ch·ªìng'
    ];
    
    const sentences = content.split(/[.!?]+/);
    sentences.forEach(sentence => {
        characterKeywords.forEach(keyword => {
            if (sentence.toLowerCase().includes(keyword)) {
                const detail = sentence.trim();
                if (detail.length > 15 && detail.length < 150) {
                    aiKnowledge.characterDetails.add(detail);
                }
            }
        });
        
        const nameMatch = sentence.match(/\b[A-Z√Ä√Å·∫†·∫¢√É√Ç·∫¶·∫§·∫¨·∫®·∫™ƒÇ·∫∞·∫Æ·∫∂·∫≤·∫¥√à√â·∫∏·∫∫·∫º√ä·ªÄ·∫æ·ªÜ·ªÇ·ªÑ√å√ç·ªä·ªàƒ®√í√ì·ªå·ªé√ï√î·ªí·ªê·ªò·ªî·ªñ∆†·ªú·ªö·ª¢·ªû·ª†√ô√ö·ª§·ª¶≈®∆Ø·ª™·ª®·ª∞·ª¨·ªÆ·ª≤√ù·ª¥·ª∂·ª∏ƒê][a-z√†√°·∫°·∫£√£√¢·∫ß·∫•·∫≠·∫©·∫´ƒÉ·∫±·∫Ø·∫∑·∫≥·∫µ√®√©·∫π·∫ª·∫Ω√™·ªÅ·∫ø·ªá·ªÉ·ªÖ√¨√≠·ªã·ªâƒ©√≤√≥·ªç·ªè√µ√¥·ªì·ªë·ªô·ªï·ªó∆°·ªù·ªõ·ª£·ªü·ª°√π√∫·ª•·ªß≈©∆∞·ª´·ª©·ª±·ª≠·ªØ·ª≥√Ω·ªµ·ª∑·ªπƒë]{2,}\b/g);
        if (nameMatch) {
            nameMatch.forEach(name => {
                if (!['T√¥i', 'Anh', 'Ch·ªã', 'Em', 'B√°c', 'Ch√∫', 'C√¥'].includes(name)) {
                    aiKnowledge.characterNames.add(name);
                }
            });
        }
    });
}

function analyzeEmotions(content) {
    const emotionKeywords = [
        'c·∫£m th·∫•y', 'c·∫£m gi√°c', 'c·∫£m x√∫c', 't√¢m tr√≠', 't√¢m l√Ω', 'l√≤ng',
        'vui', 'bu·ªìn', 'gi·∫≠n', 'lo', 's·ª£', 'h·∫°nh ph√∫c', 'ƒëau kh·ªï', 'th·∫•t v·ªçng',
        'y√™u', 'th√≠ch', 'gh√©t', 'cƒÉng th·∫≥ng', 'b·ªëi r·ªëi', 'x·∫•u h·ªï', 't·ªôi l·ªói',
        'khao kh√°t', 'th√®m mu·ªën', 'ham mu·ªën', 'k√≠ch th√≠ch', 'd·ª•c v·ªçng'
    ];
    
    const sentences = content.split(/[.!?]+/);
    sentences.forEach(sentence => {
        emotionKeywords.forEach(keyword => {
            if (sentence.toLowerCase().includes(keyword)) {
                const emotion = sentence.trim();
                if (emotion.length > 10 && emotion.length < 200) {
                    aiKnowledge.emotions.add(emotion);
                }
            }
        });
    });
}

function analyzeAdultContent(content) {
    const adultKeywords = [
        'c∆° th·ªÉ', 'th√¢n th·ªÉ', 'da th·ªãt', 'v√≤ng', 'ng·ª±c', 'm√¥ng', 'ƒë√πi',
        '√¥m', 'h√¥n', 'vu·ªët', 'ch·∫°m', 's·ªù', 'n·∫Øm',
        'khao kh√°t', 'th√®m mu·ªën', 'ham mu·ªën', 'd·ª•c v·ªçng', 'k√≠ch th√≠ch',
        'n√≥ng b·ªèng', '∆∞·ªõt √°t', 'cƒÉng c·ª©ng', 'm·ªÅm m·∫°i', 'quy·∫øn r≈©',
        'l√†m t√¨nh', 'quan h·ªá', 'y√™u ƒë∆∞∆°ng', '√¢n √°i'
    ];
    
    const sentences = content.split(/[.!?]+/);
    sentences.forEach(sentence => {
        adultKeywords.forEach(keyword => {
            if (sentence.toLowerCase().includes(keyword)) {
                const adultSentence = sentence.trim();
                if (adultSentence.length > 15 && adultSentence.length < 250) {
                    aiKnowledge.adultContent.add(adultSentence);
                }
            }
        });
    });
}

function analyzeTimeReferences(content) {
    const timeKeywords = [
        'h√¥m nay', 'h√¥m qua', 'mai', 'ng√†y', 'tu·∫ßn', 'th√°ng', 'nƒÉm',
        's√°ng', 'tr∆∞a', 'chi·ªÅu', 't·ªëi', 'ƒë√™m', 'khuya',
        'khi', 'l√∫c', 'sau khi', 'tr∆∞·ªõc khi', 'trong khi',
        'b·ªóng nhi√™n', 'ƒë·ªôt ng·ªôt', 't·ª´ t·ª´', 'nhanh ch√≥ng'
    ];
    
    const sentences = content.split(/[.!?]+/);
    sentences.forEach(sentence => {
        timeKeywords.forEach(keyword => {
            if (sentence.toLowerCase().includes(keyword)) {
                const timeRef = sentence.trim();
                if (timeRef.length > 10 && timeRef.length < 150) {
                    aiKnowledge.timeReferences.add(timeRef);
                }
            }
        });
    });
}

function analyzePlotPoints(content) {
    const plotKeywords = [
        'b·ªóng nhi√™n', 'ƒë·ªôt ng·ªôt', 'sau ƒë√≥', 'cu·ªëi c√πng', 'k·∫øt qu·∫£',
        'ph√°t hi·ªán', 'nh·∫≠n ra', 'hi·ªÉu ra', 'ch·ª£t', 'b·∫•t ng·ªù',
        'quy·∫øt ƒë·ªãnh', 'd·ª± ƒë·ªãnh', 'k·∫ø ho·∫°ch', '√Ω ƒë·ªãnh'
    ];
    
    const sentences = content.split(/[.!?]+/);
    sentences.forEach(sentence => {
        plotKeywords.forEach(keyword => {
            if (sentence.toLowerCase().includes(keyword)) {
                const plot = sentence.trim();
                if (plot.length > 15 && plot.length < 200) {
                    aiKnowledge.plotPoints.add(plot);
                }
            }
        });
    });
}

function updateAiStats() {
    document.getElementById('vocabularyCount').textContent = aiKnowledge.vocabulary.size;
    document.getElementById('dialogueCount').textContent = aiKnowledge.dialogues.size;
    document.getElementById('contextCount').textContent = aiKnowledge.contexts.size;
    document.getElementById('characterCount').textContent = aiKnowledge.characterDetails.size;
    document.getElementById('emotionCount').textContent = aiKnowledge.emotions.size;
    document.getElementById('adultCount').textContent = aiKnowledge.adultContent.size;
    document.getElementById('timeCount').textContent = aiKnowledge.timeReferences.size;
    document.getElementById('locationCount').textContent = aiKnowledge.locations.size;
    document.getElementById('sentenceCount').textContent = aiKnowledge.sentenceStructures.size;
    document.getElementById('plotCount').textContent = aiKnowledge.plotPoints.size;
    document.getElementById('trainedFiles').textContent = aiKnowledge.trainedFiles;
}

async function saveAiKnowledge() {
    const knowledgeData = {
        vocabulary: Array.from(aiKnowledge.vocabulary),
        stories: aiKnowledge.stories,
        trainedFiles: aiKnowledge.trainedFiles,
        dialogues: Array.from(aiKnowledge.dialogues),
        contexts: Array.from(aiKnowledge.contexts),
        characterDetails: Array.from(aiKnowledge.characterDetails),
        emotions: Array.from(aiKnowledge.emotions),
        adultContent: Array.from(aiKnowledge.adultContent),
        timeReferences: Array.from(aiKnowledge.timeReferences),
        locations: Array.from(aiKnowledge.locations),
        sentenceStructures: Array.from(aiKnowledge.sentenceStructures),
        plotPoints: Array.from(aiKnowledge.plotPoints),
        characterNames: Array.from(aiKnowledge.characterNames),
        environmentDetails: Array.from(aiKnowledge.environmentDetails),
        transitionWords: Array.from(aiKnowledge.transitionWords),
        generationHistory: aiKnowledge.generationHistory,
        lastUpdated: new Date().toISOString()
    };
    
    const knowledgeStr = JSON.stringify(knowledgeData);
    const fileName = 'ai_knowledge_advanced_v2.json';
    
    try {
        const response = await gapi.client.drive.files.list({
            q: `name='${fileName}' and '${mainFolderId}' in parents and trashed=false`,
            fields: 'files(id)'
        });
        
        if (response.result.files.length > 0) {
            const fileId = response.result.files[0].id;
            await gapi.client.request({
                path: `https://www.googleapis.com/upload/drive/v3/files/${fileId}`,
                method: 'PATCH',
                params: { uploadType: 'media' },
                body: knowledgeStr
            });
        } else {
            const fileMetadata = { 
                name: fileName, 
                parents: [mainFolderId] 
            };
            
            await gapi.client.request({
                path: 'https://www.googleapis.com/upload/drive/v3/files', 
                method: 'POST',
                params: { uploadType: 'multipart' },
                headers: { 'Content-Type': 'multipart/related; boundary="foo_bar_baz"' },
                body: '--foo_bar_baz\r\nContent-Type: application/json; charset=UTF-8\r\n\r\n' +
                      JSON.stringify(fileMetadata) + '\r\n--foo_bar_baz\r\nContent-Type: application/json\r\n\r\n' +
                      knowledgeStr + '\r\n--foo_bar_baz--'
            });
        }
    } catch (error) {
        console.error('Error saving AI knowledge:', error);
    }
}

async function loadAiKnowledge() {
    const fileName = 'ai_knowledge_advanced_v2.json';
    try {
        const response = await gapi.client.drive.files.list({
            q: `name='${fileName}' and '${mainFolderId}' in parents and trashed=false`,
            fields: 'files(id)'
        });
        
        if (response.result.files.length > 0) {
            const fileId = response.result.files[0].id;
            const fileResponse = await gapi.client.drive.files.get({
                fileId: fileId,
                alt: 'media'
            });
            
            const knowledge = JSON.parse(fileResponse.body);
            
            aiKnowledge.vocabulary = new Set(knowledge.vocabulary || []);
            aiKnowledge.stories = knowledge.stories || [];
            aiKnowledge.trainedFiles = knowledge.trainedFiles || 0;
            aiKnowledge.dialogues = new Set(knowledge.dialogues || []);
            aiKnowledge.contexts = new Set(knowledge.contexts || []);
            aiKnowledge.characterDetails = new Set(knowledge.characterDetails || []);
            aiKnowledge.emotions = new Set(knowledge.emotions || []);
            aiKnowledge.adultContent = new Set(knowledge.adultContent || []);
            aiKnowledge.timeReferences = new Set(knowledge.timeReferences || []);
            aiKnowledge.locations = new Set(knowledge.locations || []);
            aiKnowledge.sentenceStructures = new Set(knowledge.sentenceStructures || []);
            aiKnowledge.plotPoints = new Set(knowledge.plotPoints || []);
            aiKnowledge.characterNames = new Set(knowledge.characterNames || []);
            aiKnowledge.environmentDetails = new Set(knowledge.environmentDetails || []);
            aiKnowledge.transitionWords = new Set(knowledge.transitionWords || []);
            aiKnowledge.generationHistory = knowledge.generationHistory || [];
        }
    } catch (error) {
        console.error('Error loading AI knowledge:', error);
    }
}

// Story Generation Functions
async function generateStory() {
    const chapterCount = parseInt(document.getElementById('chapterCount').value) || 50;
    if (chapterCount < 50 || chapterCount > 200) {
        showStatus('S·ªë ch∆∞∆°ng ph·∫£i t·ª´ 50 ƒë·∫øn 200!', 'error');
        return;
    }
    
    if (aiKnowledge.vocabulary.size < 100) {
        showStatus('AI ch∆∞a ƒë∆∞·ª£c hu·∫•n luy·ªán ƒë·ªß! H√£y hu·∫•n luy·ªán AI v·ªõi √≠t nh·∫•t 100 t·ª´ v·ª±ng.', 'error');
        return;
    }
    
    showLoading(true);
    showStatus('AI ƒëang t·∫°o truy·ªán v·ªõi logic n√¢ng cao...', 'success');
    
    const storyContext = generateStoryContext();
    const title = generateIntelligentTitle();
    
    try {
        const storyFolderId = await createStoryFolder(title);
        
        let generatedChapters = 0;
        const totalChapters = chapterCount;
        
        for (let i = 1; i <= totalChapters; i++) {
            const chapterTitle = `Ch∆∞∆°ng ${i}: ${generateChapterTitle(i, totalChapters, storyContext)}`;
            const chapterContent = generateAdvancedChapterContent(i, totalChapters, storyContext);
            
            await saveStoryContent(title, chapterTitle, chapterContent, storyFolderId);
            
            generatedChapters++;
            
            const progress = (generatedChapters / totalChapters) * 100;
            document.getElementById('generationProgressFill').style.width = progress + '%';
            document.getElementById('generationStatus').innerHTML = 
                `<div class="status success">ƒêang t·∫°o ch∆∞∆°ng ${generatedChapters}/${totalChapters}: ${chapterTitle}</div>`;
            
            await new Promise(resolve => setTimeout(resolve, 100));
        }
        
        await loadStoryHistory();
        await learnFromGeneratedContent(title, totalChapters);
        
        showLoading(false);
        showStatus(`ƒê√£ t·∫°o th√†nh c√¥ng truy·ªán "${title}" v·ªõi ${totalChapters} ch∆∞∆°ng!`, 'success');
        document.getElementById('generationStatus').innerHTML = '';
    } catch (error) {
        console.error('Error generating story:', error);
        showLoading(false);
        showStatus('C√≥ l·ªói x·∫£y ra khi t·∫°o truy·ªán!', 'error');
    }
}

function generateStoryContext() {
    const mainCharacters = {
        protagonist: getRandomFromSet(aiKnowledge.characterNames) || 'Minh',
        spouse: getRandomFromSet(aiKnowledge.characterNames) || 'Linh', 
        parentInLaw: getRandomFromSet(aiKnowledge.characterNames) || 'H√πng'
    };
    
    const setting = {
        primaryLocation: getRandomFromSet(aiKnowledge.locations) || 'trong nh√†',
        timeOfDay: getRandomFromSet(aiKnowledge.timeReferences) || 'bu·ªïi t·ªëi',
        atmosphere: ['ri√™ng t∆∞', 'b√≠ m·∫≠t', 'th√¢n m·∫≠t', 'cƒÉng th·∫≥ng'][Math.floor(Math.random() * 4)]
    };
    
    const emotionalArc = {
        beginning: 't√≤ m√≤ v√† quan s√°t',
        middle: 'nh·∫≠n th·ª©c v√† xung ƒë·ªôt n·ªôi t√¢m', 
        climax: 'kh√°m ph√° v√† ch·∫•p nh·∫≠n',
        ending: 'th·∫•u hi·ªÉu v√† b√¨nh y√™n'
    };
    
    return { mainCharacters, setting, emotionalArc };
}

function generateIntelligentTitle() {
    const titleTemplates = [
        "Nh·ªØng ƒêi·ªÅu T√¥i Th·∫ßm Bi·∫øt",
        "B√≠ M·∫≠t Trong Gia ƒê√¨nh", 
        "G√≥c Nh√¨n C·ªßa Ng∆∞·ªùi Ch·ªìng",
        "Quan S√°t Trong Th·∫ßm L·∫∑ng",
        "Nh·ªØng G√¨ T√¥i Kh√¥ng N√≥i Ra",
        "Ranh Gi·ªõi M·ªù Nh·∫°t",
        "C√¢u Chuy·ªán Ch∆∞a K·ªÉ",
        "Trong S·ª± Im L·∫∑ng",
        "Kh√°m Ph√° B·∫£n Th√¢n",
        "H√†nh Tr√¨nh N·ªôi T√¢m"
    ];
    
    return titleTemplates[Math.floor(Math.random() * titleTemplates.length)];
}

function generateChapterTitle(chapterNum, totalChapters, context) {
    const progress = chapterNum / totalChapters;
    
    if (progress < 0.2) {
        const beginningTitles = ["Kh·ªüi ƒë·∫ßu quan s√°t", "Nh·ªØng d·∫•u hi·ªáu ƒë·∫ßu ti√™n", "S·ª± t√≤ m√≤ b·∫Øt ƒë·∫ßu", "C·∫£m gi√°c l·∫° l√πng"];
        return beginningTitles[Math.floor(Math.random() * beginningTitles.length)];
    } else if (progress < 0.5) {
        const developmentTitles = ["Nh·∫≠n ra ƒëi·ªÅu b·∫•t th∆∞·ªùng", "Quan s√°t k·ªπ h∆°n", "Nh·ªØng ph√°t hi·ªán m·ªõi", "S·ª± thay ƒë·ªïi"];
        return developmentTitles[Math.floor(Math.random() * developmentTitles.length)];
    } else if (progress < 0.8) {
        const climaxTitles = ["Xung ƒë·ªôt n·ªôi t√¢m", "Kh√°m ph√° s·ª± th·∫≠t", "Kh√¥ng th·ªÉ ph·ªß nh·∫≠n", "ƒê·ªëi m·∫∑t v·ªõi th·ª±c t·∫ø"];
        return climaxTitles[Math.floor(Math.random() * climaxTitles.length)];
    } else {
        const endingTitles = ["S·ª± th·∫•u hi·ªÉu", "Ch·∫•p nh·∫≠n th·ª±c t·∫ø", "K·∫øt lu·∫≠n cu·ªëi c√πng", "B√¨nh y√™n t√¨m l·∫°i"];
        return endingTitles[Math.floor(Math.random() * endingTitles.length)];
    }
}

function generateAdvancedChapterContent(chapterNum, totalChapters, context) {
    const progress = chapterNum / totalChapters;
    let content = "";
    
    let phase = 'beginning';
    if (progress > 0.25) phase = 'middle';
    if (progress > 0.65) phase = 'climax';
    if (progress > 0.85) phase = 'ending';
    
    content += generatePhaseIntroduction(phase, chapterNum, context) + "\n\n";
    
    const paragraphCount = 3 + Math.floor(Math.random() * 3);
    for (let i = 0; i < paragraphCount; i++) {
        content += generateIntelligentParagraph(phase, context, i, paragraphCount) + "\n\n";
    }
    
    content += generateChapterEnding(phase, context) + "\n";
    
    while (content.split(/\s+/).length < 2500) {
        const additionalContent = generateAdditionalSmartContent(phase, context);
        content += additionalContent + "\n\n";
    }
    
    const words = content.split(/\s+/);
    if (words.length > 4000) {
        content = words.slice(0, 4000).join(' ');
    }
    
    return content;
}

function generatePhaseIntroduction(phase, chapterNum, context) {
    const templates = {
        beginning: [
            `H√¥m nay l√† ng√†y th·ª© ${chapterNum} k·ªÉ t·ª´ khi t√¥i b·∫Øt ƒë·∫ßu ƒë·ªÉ √Ω ƒë·∫øn nh·ªØng ƒëi·ªÅu l·∫° l√πng trong nh√†.`,
            `T√¥i kh√¥ng th·ªÉ ng·ªù ƒë∆∞·ª£c r·∫±ng cu·ªôc s·ªëng gia ƒë√¨nh t√¥i l·∫°i c√≥ nh·ªØng b√≠ m·∫≠t nh∆∞ th·∫ø n√†y.`,
            `M·ªçi th·ª© b·∫Øt ƒë·∫ßu t·ª´ m·ªôt c·ª≠ ch·ªâ nh·ªè m√† t√¥i t√¨nh c·ªù nh·∫≠n ra.`
        ],
        middle: [
            `C√†ng quan s√°t, t√¥i c√†ng th·∫•y r√µ h∆°n v·ªÅ m·ªëi quan h·ªá ƒë·∫∑c bi·ªát n√†y.`,
            `Nh·ªØng nghi ng·ªù trong t√¥i ng√†y c√†ng l·ªõn d·∫ßn theo th·ªùi gian.`,
            `T√¥i b·∫Øt ƒë·∫ßu hi·ªÉu t·∫°i sao m·ªçi th·ª© trong nh√† l·∫°i c√≥ nh·ªØng thay ƒë·ªïi tinh t·∫ø.`
        ],
        climax: [
            `H√¥m nay, t√¥i kh√¥ng th·ªÉ ph·ªß nh·∫≠n nh·ªØng g√¨ ƒëang di·ªÖn ra tr∆∞·ªõc m·∫Øt m√¨nh.`,
            `S·ª± th·∫≠t ƒë√£ tr·ªü n√™n qu√° r√µ r√†ng ƒë·ªÉ t√¥i c√≥ th·ªÉ b·ªè qua.`,
            `Xung ƒë·ªôt trong t√¢m tr√≠ t√¥i ƒë·∫°t ƒë·∫øn ƒëi·ªÉm ƒë·ªânh.`
        ],
        ending: [
            `Cu·ªëi c√πng, t√¥i c≈©ng t√¨m ƒë∆∞·ª£c c√°ch ƒë·ªÉ hi·ªÉu v√† ch·∫•p nh·∫≠n th·ª±c t·∫ø.`,
            `Nh√¨n l·∫°i ch·∫∑ng ƒë∆∞·ªùng ƒë√£ qua, t√¥i nh·∫≠n ra nhi·ªÅu ƒëi·ªÅu v·ªÅ b·∫£n th√¢n m√¨nh.`,
            `Gi·ªù ƒë√¢y, t√¥i c√≥ th·ªÉ nh√¨n nh·∫≠n m·ªçi th·ª© m·ªôt c√°ch b√¨nh tƒ©nh h∆°n.`
        ]
    };
    
    const phaseTemplates = templates[phase] || templates.beginning;
    return phaseTemplates[Math.floor(Math.random() * phaseTemplates.length)];
}

function generateIntelligentParagraph(phase, context, paragraphIndex, totalParagraphs) {
    let paragraph = "";
    const sentenceCount = 4 + Math.floor(Math.random() * 3);
    
    for (let i = 0; i < sentenceCount; i++) {
        const sentenceType = determineSentenceType(phase, i, sentenceCount);
        paragraph += generateSmartSentence(sentenceType, context) + " ";
    }
    
    return paragraph.trim();
}

function determineSentenceType(phase, sentenceIndex, totalSentences) {
    const types = ['observation', 'innerThought', 'emotion', 'action'];
    
    if (phase === 'climax' && Math.random() < 0.3) {
        types.push('adult');
    }
    
    return types[Math.floor(Math.random() * types.length)];
}

function generateSmartSentence(type, context) {
    const templates = {
        observation: [
            `T√¥i ƒë·ªÉ √Ω th·∫•y ${context.mainCharacters.spouse} c√≥ nh·ªØng c·ª≠ ch·ªâ ƒë·∫∑c bi·ªát.`,
            `C√°ch ${context.mainCharacters.spouse} nh√¨n t√¥i khi·∫øn t√¥i c·∫£m th·∫•y b·ªëi r·ªëi.`,
            `Kh√¥ng th·ªÉ kh√¥ng ch√∫ √Ω ƒë·∫øn s·ª± thay ƒë·ªïi trong c√°ch c∆∞ x·ª≠ c·ªßa ${context.mainCharacters.spouse}.`
        ],
        innerThought: [
            `Trong t√¢m tr√≠ t√¥i, nh·ªØng suy nghƒ© ph·ª©c t·∫°p c·ª© l·ªün v·ªün.`,
            `T√¥i t·ª± h·ªèi li·ªáu m√¨nh c√≥ ƒëang suy nghƒ© qu√° nhi·ªÅu.`,
            `C·∫£m gi√°c b·ªìn ch·ªìn c·ª© √°m ·∫£nh t√¥i m·ªói khi nghƒ© v·ªÅ ƒëi·ªÅu n√†y.`
        ],
        emotion: [
            `Tim t√¥i ƒë·∫≠p nhanh h∆°n m·ªói khi nghƒ© v·ªÅ nh·ªØng g√¨ ƒëang di·ªÖn ra.`,
            `C·∫£m gi√°c t·ªôi l·ªói v√† t√≤ m√≤ c·ª© tranh ƒë·∫•u trong l√≤ng t√¥i.`,
            `T√¥i c·∫£m th·∫•y m√¨nh nh∆∞ ƒëang ƒë·ª©ng tr∆∞·ªõc m·ªôt b√≠ ·∫©n l·ªõn.`
        ],
        action: [
            `T√¥i quy·∫øt ƒë·ªãnh quan s√°t k·ªπ h∆°n ƒë·ªÉ hi·ªÉu r√µ t√¨nh h√¨nh.`,
            `M·ªói c·ª≠ ch·ªâ nh·ªè c·ªßa ${context.mainCharacters.spouse} ƒë·ªÅu kh√¥ng tho√°t kh·ªèi s·ª± ch√∫ √Ω c·ªßa t√¥i.`,
            `T√¥i c·ªë g·∫Øng h√†nh ƒë·ªông b√¨nh th∆∞·ªùng ƒë·ªÉ kh√¥ng ai ph√°t hi·ªán.`
        ],
        adult: [
            `Nh·ªØng suy nghƒ© t√°o b·∫°o b·∫Øt ƒë·∫ßu len l·ªèi v√†o t√¢m tr√≠ t√¥i.`,
            `C·∫£m gi√°c khao kh√°t b√≠ ·∫©n khi·∫øn t√¥i kh√¥ng th·ªÉ ng·ª´ng suy nghƒ©.`,
            `T√¥i c·∫£m nh·∫≠n ƒë∆∞·ª£c s·ª± cƒÉng th·∫≥ng trong kh√¥ng kh√≠.`
        ]
    };
    
    const typeTemplates = templates[type] || templates.observation;
    return typeTemplates[Math.floor(Math.random() * typeTemplates.length)];
}

function generateAdditionalSmartContent(phase, context) {
    const contentTypes = ['reflection', 'observation', 'emotion'];
    const selectedType = contentTypes[Math.floor(Math.random() * contentTypes.length)];
    return generateSmartSentence(selectedType, context);
}

function generateChapterEnding(phase, context) {
    const endings = {
        beginning: [
            "T√¥i quy·∫øt ƒë·ªãnh s·∫Ω quan s√°t k·ªπ h∆°n trong nh·ªØng ng√†y t·ªõi.",
            "C√≥ l·∫Ω t√¥i c·∫ßn th·ªùi gian ƒë·ªÉ hi·ªÉu r√µ h∆°n v·ªÅ t√¨nh h√¨nh n√†y.",
            "C√¢u h·ªèi trong ƒë·∫ßu t√¥i v·∫´n ch∆∞a c√≥ l·ªùi gi·∫£i ƒë√°p."
        ],
        middle: [
            "M·ªçi th·ª© ƒëang tr·ªü n√™n ph·ª©c t·∫°p h∆°n t√¥i nghƒ©.",
            "T√¥i c·∫£m th·∫•y m√¨nh ƒëang ƒë·ª©ng tr∆∞·ªõc m·ªôt b√≠ ·∫©n l·ªõn.",
            "Nh·ªØng m·∫£nh gh√©p b·∫Øt ƒë·∫ßu kh·ªõp v·ªõi nhau trong t√¢m tr√≠ t√¥i."
        ],
        climax: [
            "Gi·ªù ƒë√¢y t√¥i kh√¥ng th·ªÉ l√†m ng∆° tr∆∞·ªõc s·ª± th·∫≠t n√†y n·ªØa.",
            "Cu·ªôc s·ªëng c·ªßa t√¥i s·∫Ω kh√¥ng bao gi·ªù nh∆∞ tr∆∞·ªõc.",
            "T√¥i ph·∫£i ƒë·ªëi m·∫∑t v·ªõi th·ª±c t·∫ø d√π c√≥ ƒëau ƒë·ªõn ƒë·∫øn ƒë√¢u."
        ],
        ending: [
            "Cu·ªëi c√πng t√¥i c≈©ng t√¨m ƒë∆∞·ª£c s·ª± b√¨nh y√™n trong t√¢m h·ªìn.",
            "T√¥i h·ªçc ƒë∆∞·ª£c r·∫±ng cu·ªôc s·ªëng lu√¥n ph·ª©c t·∫°p h∆°n nh·ªØng g√¨ ta nghƒ©.",
            "Gi·ªù ƒë√¢y t√¥i c√≥ th·ªÉ nh√¨n m·ªçi th·ª© v·ªõi con m·∫Øt kh√°c."
        ]
    };
    
    const phaseEndings = endings[phase] || endings.beginning;
    return phaseEndings[Math.floor(Math.random() * phaseEndings.length)];
}

async function learnFromGeneratedContent(storyTitle, chapterCount) {
    try {
        const story = storyHistory.find(s => s.storyTitle === storyTitle);
        if (!story) return;
        
        for (let chapter of story.chapters) {
            try {
                const response = await gapi.client.drive.files.get({
                    fileId: chapter.id,
                    alt: 'media'
                });
                
                const content = response.body;
                await advancedContentAnalysis(content, storyTitle, chapter.name);
                
            } catch (error) {
                console.error('Error reading generated chapter:', error);
            }
        }
        
        await saveAiKnowledge();
        updateAiStats();
        
        showStatus('AI ƒë√£ h·ªçc th√™m t·ª´ truy·ªán v·ª´a t·∫°o ƒë·ªÉ c·∫£i thi·ªán l·∫ßn sau!', 'success');
        
    } catch (error) {
        console.error('Error learning from generated content:', error);
    }
}

function getRandomFromSet(set) {
    if (!set || set.size === 0) return null;
    const array = Array.from(set);
    return array[Math.floor(Math.random() * array.length)];
}

function resetAI() {
    if (confirm('B·∫°n c√≥ ch·∫Øc ch·∫Øn mu·ªën reset to√†n b·ªô ki·∫øn th·ª©c c·ªßa AI?')) {
        aiKnowledge = { 
            vocabulary: new Set(), 
            stories: [], 
            trainedFiles: 0,
            dialogues: new Set(),
            contexts: new Set(),
            characterDetails: new Set(),
            emotions: new Set(),
            adultContent: new Set(),
            timeReferences: new Set(),
            locations: new Set(),
            sentenceStructures: new Set(),
            plotPoints: new Set(),
            characterNames: new Set(),
            environmentDetails: new Set(),
            transitionWords: new Set(),
            generationHistory: []
        };
        updateAiStats();
        saveAiKnowledge();
        showStatus('ƒê√£ reset ki·∫øn th·ª©c c·ªßa AI!', 'success');
    }
}

// UI Navigation Functions
function switchSection(sectionId) {
    // Hide all sections
    document.querySelectorAll('.content-section').forEach(section => {
        section.classList.remove('active');
    });
    
    // Remove active class from all buttons
    document.querySelectorAll('.nav-menu button').forEach(btn => {
        btn.classList.remove('active');
    });
    
    // Show selected section
    document.getElementById(sectionId).classList.add('active');
    
    // Add active class to clicked button
    event.target.classList.add('active');
}

// Story Management Functions
function toggleStoryMode() {
    const mode = document.getElementById('storyMode').value;
    const newStoryGroup = document.getElementById('newStoryGroup');
    const existingStoryGroup = document.getElementById('existingStoryGroup');
    const submitButtonText = document.getElementById('submitButtonText');
    
    if (mode === 'new') {
        newStoryGroup.style.display = 'block';
        existingStoryGroup.style.display = 'none';
        submitButtonText.textContent = 'L∆∞u Truy·ªán M·ªõi';
    } else {
        newStoryGroup.style.display = 'none';
        existingStoryGroup.style.display = 'block';
        submitButtonText.textContent = 'Th√™m Ch∆∞∆°ng';
    }
}

async function handleStorySubmit(event) {
    event.preventDefault();
    
    const mode = document.getElementById('storyMode').value;
    const chapterTitle = document.getElementById('chapterTitle').value;
    const storyContent = document.getElementById('storyContent').value;
    
    if (!chapterTitle || !storyContent) {
        showStatus('Vui l√≤ng ƒëi·ªÅn ƒë·∫ßy ƒë·ªß th√¥ng tin!', 'error');
        return;
    }
    
    showLoading(true);
    
    try {
        let storyFolderId;
        let storyTitle;
        
        if (mode === 'new') {
            storyTitle = document.getElementById('storyTitle').value;
            if (!storyTitle) {
                showStatus('Vui l√≤ng nh·∫≠p t√™n truy·ªán!', 'error');
                showLoading(false);
                return;
            }
            storyFolderId = await createStoryFolder(storyTitle);
        } else {
            storyFolderId = document.getElementById('existingStory').value;
            if (!storyFolderId) {
                showStatus('Vui l√≤ng ch·ªçn truy·ªán!', 'error');
                showLoading(false);
                return;
            }
            const story = storyHistory.find(s => s.folderId === storyFolderId);
            storyTitle = story ? story.storyTitle : 'Unknown';
        }
        
        await saveStoryContent(storyTitle, chapterTitle, storyContent, storyFolderId);
        await loadStoryHistory();
        
        // Learn from new content
        await advancedContentAnalysis(storyContent, storyTitle, chapterTitle);
        await saveAiKnowledge();
        updateAiStats();
        
        // Reset form
        document.getElementById('storyForm').reset();
        
        showLoading(false);
        showStatus('ƒê√£ l∆∞u th√†nh c√¥ng!', 'success');
        
    } catch (error) {
        console.error('Error saving story:', error);
        showLoading(false);
        showStatus('C√≥ l·ªói x·∫£y ra khi l∆∞u truy·ªán!', 'error');
    }
}

// Modal Functions
function closeModal(modalId) {
    document.getElementById(modalId).classList.remove('show');
}

function viewChapters(story) {
    const modal = document.getElementById('chaptersModal');
    const title = document.getElementById('chaptersModalTitle');
    const chapterList = document.getElementById('chapterList');
    
    title.textContent = `Truy·ªán: ${story.storyTitle}`;
    chapterList.innerHTML = '';
    
    story.chapters.forEach(chapter => {
        if (chapter.name.endsWith('.txt')) {
            const item = document.createElement('div');
            item.className = 'chapter-item';
            item.innerHTML = `
                <div class="story-title">${chapter.name.replace('.txt', '')}</div>
                <div class="story-date">T·∫°o: ${new Date(chapter.createdTime).toLocaleDateString('vi-VN')}</div>
            `;
            item.onclick = () => viewChapterContent(chapter, story.folderId);
            chapterList.appendChild(item);
        }
    });
    
    modal.classList.add('show');
}

async function viewChapterContent(chapter, folderId) {
    const chapterContent = document.getElementById('chapterContent');
    const chapterActions = document.getElementById('chapterActions');
    
    try {
        const response = await gapi.client.drive.files.get({
            fileId: chapter.id,
            alt: 'media'
        });
        
        const content = response.body;
        chapterContent.textContent = content;
        chapterContent.style.display = 'block';
        chapterActions.style.display = 'block';
        currentEditingChapter = { id: chapter.id, content: content, name: chapter.name };
        
        // AI learns from viewed chapter
        const storyTitle = storyHistory.find(s => s.folderId === folderId)?.storyTitle || 'Unknown';
        await advancedContentAnalysis(content, storyTitle, chapter.name);
        await saveAiKnowledge();
        updateAiStats();
        
    } catch (error) {
        console.error('Error loading chapter content:', error);
        showStatus('C√≥ l·ªói khi t·∫£i n·ªôi dung ch∆∞∆°ng!', 'error');
    }
}

function editChapter() {
    if (!currentEditingChapter) return;
    
    const content = document.getElementById('chapterContent');
    const originalContent = content.textContent;
    
    content.innerHTML = `<textarea style="width: 100%; height: 400px; background: rgba(255,255,255,0.1); color: white; border: 1px solid rgba(255,255,255,0.3); border-radius: 8px; padding: 15px;">${originalContent}</textarea>`;
}

async function saveChapterChanges() {
    if (!currentEditingChapter) return;
    
    const textarea = document.querySelector('#chapterContent textarea');
    if (!textarea) return;
    
    const newContent = textarea.value;
    
    try {
        showLoading(true);
        
        await gapi.client.request({
            path: `https://www.googleapis.com/upload/drive/v3/files/${currentEditingChapter.id}`,
            method: 'PATCH',
            params: { uploadType: 'media' },
            body: newContent
        });
        
        document.getElementById('chapterContent').textContent = newContent;
        currentEditingChapter.content = newContent;
        
        showLoading(false);
        showStatus('ƒê√£ l∆∞u thay ƒë·ªïi th√†nh c√¥ng!', 'success');
        
    } catch (error) {
        console.error('Error saving chapter changes:', error);
        showLoading(false);
        showStatus('C√≥ l·ªói khi l∆∞u thay ƒë·ªïi!', 'error');
    }
}

function cancelEdit() {
    if (!currentEditingChapter) return;
    
    const content = document.getElementById('chapterContent');
    content.textContent = currentEditingChapter.content;
}

async function deleteChapter() {
    if (!currentEditingChapter) return;
    
    if (!confirm('B·∫°n c√≥ ch·∫Øc ch·∫Øn mu·ªën x√≥a ch∆∞∆°ng n√†y?')) return;
    
    try {
        showLoading(true);
        
        await gapi.client.drive.files.delete({
            fileId: currentEditingChapter.id
        });
        
        await loadStoryHistory();
        closeModal('chaptersModal');
        
        showLoading(false);
        showStatus('ƒê√£ x√≥a ch∆∞∆°ng th√†nh c√¥ng!', 'success');
        
    } catch (error) {
        console.error('Error deleting chapter:', error);
        showLoading(false);
        showStatus('C√≥ l·ªói khi x√≥a ch∆∞∆°ng!', 'error');
    }
}

// Event Listeners
document.addEventListener('DOMContentLoaded', function() {
    // Initialize Google APIs
    initializeGapi();
    initializeGis();
    
    // Auth buttons
    document.getElementById('authorizeButton').onclick = handleAuthClick;
    document.getElementById('signoutButton').onclick = handleSignoutClick;
    
    // Navigation buttons
    document.querySelectorAll('.nav-menu button').forEach(btn => {
        btn.onclick = function() {
            const sectionId = this.dataset.section;
            switchSection(sectionId);
        };
    });
    
    // AI Training buttons
    document.getElementById('trainAiButton').onclick = trainAI;
    document.getElementById('resetAiButton').onclick = resetAI;
    
    // Story generation buttons
    document.getElementById('generateStoryButton').onclick = generateStory;
    
    // Story management
    document.getElementById('storyMode').onchange = toggleStoryMode;
    document.getElementById('storyForm').onsubmit = handleStorySubmit;
    
    // Modal close events
    document.querySelectorAll('.modal').forEach(modal => {
        modal.onclick = function(e) {
            if (e.target === modal) {
                modal.classList.remove('show');
            }
        };
    });
});

</script>
</body>
</html>
