<!DOCTYPE html>
<html lang="vi">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, viewport-fit=cover">
  <title>Tr√¨nh Ph√¢n T√≠ch & T·∫°o Truy·ªán N√¢ng Cao</title>
  <script src="https://apis.google.com/js/api.js"></script>
  <script src="https://accounts.google.com/gsi/client"></script>
  <style>
    :root {
      --primary-color: #9b59b6;
      --secondary-color: #2980b9;
      --dark-color: #1e1e1e;
      --light-color: #bdc3c7;
      --accent-color: #e74c3c;
      --success-color: #2ecc71;
      --warning-color: #f39c12;
      --text-color: #ecf0f1;
      --card-bg: rgba(30, 30, 30, 0.95);
      --border-radius: 16px;
      --shadow: 0 4px 20px rgba(0, 0, 0, 0.6);
      --safe-area-inset-top: env(safe-area-inset-top);
      --safe-area-inset-bottom: env(safe-area-inset-bottom);
      --safe-area-inset-left: env(safe-area-inset-left);
      --safe-area-inset-right: env(safe-area-inset-right);
    }

    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    body {
      background: #121212;
      color: var(--text-color);
      font-family: sans-serif;
      min-height: 100vh;
    }

    .container {
      padding: 16px;
      padding-bottom: 80px;
    }

    .header {
      text-align: center;
      color: #fff;
      margin-bottom: 20px;
    }

    .card {
      background: var(--card-bg);
      border-radius: var(--border-radius);
      padding: 20px;
      margin-bottom: 20px;
    }

    .bottom-menu {
      position: fixed;
      bottom: 0;
      left: 0;
      right: 0;
      display: flex;
      justify-content: space-around;
      padding: 12px;
      background: #2c3e50;
    }

    .menu-item {
      color: var(--light-color);
      text-decoration: none;
      font-size: 0.8rem;
      opacity: 0.7;
    }

    .menu-item.active {
      opacity: 1;
    }

    .tab-content {
      display: none;
    }

    .tab-content.active {
      display: block;
    }
    .empty-state {
    text-align: center;
    color: #7f8c8d;
    font-style: italic;
    padding: 20px;
}

    .btn {
      background: var(--primary-color);
      color: #fff;
      border: none;
      padding: 10px 16px;
      border-radius: 8px;
      margin: 4px;
      cursor: pointer;
    }

    .btn:disabled {
      background: #777;
      cursor: not-allowed;
    }

    .story-content {
      background: #1e1e1e;
      padding: 12px;
      border-radius: 8px;
      margin: 8px 0;
      max-height: 50vh;
      overflow-y: auto;
    }
  </style>
</head>

<body>
  <div class="container">
    <div class="header">
      <h1>üìñ Tr√¨nh Ph√¢n T√≠ch & T·∫°o Truy·ªán</h1>
      <p>Ph√¢n t√≠ch n√¢ng cao v√† t·∫°o truy·ªán t·ª± ƒë·ªông</p>
    </div>
    <div id="tab-analysis" class="tab-content active">
      <div class="card">
        <h3>üîç Ph√¢n t√≠ch ngu·ªìn truy·ªán</h3>
        <div class="status-info" id="statusInfo">üî¥ Ch∆∞a k·∫øt n·ªëi Google
          Drive</div>
        <div class="detailed-status" id="detailedStatus"></div>
        <div class="progress-bar">
          <div class="progress-fill" id="progressBar" style="height:10px;background:#9b59b6;width:0%"></div>
        </div>
        <button class="btn" onclick="handleAuthClick()">üìÅ K·∫øt n·ªëi Google
          Drive</button>
        <button class="btn" id="scanBtn" onclick="scanFolder()" disabled>üîç
          Qu√©t th∆∞ m·ª•c</button>
        <button class="btn" id="analyzeBtn" onclick="analyzeFiles()" disabled>üß† Ph√¢n t√≠ch n√¢ng cao</button>
        <button class="btn" id="downloadAnalysisBtn" onclick="downloadAnalysisFromDrive()" disabled>üì• T·∫£i ph√¢n
          t√≠ch</button>
        <button class="btn" onclick="loadAnalysisLocal()">üîÑ T·∫£i cache
          local</button>
        <button class="btn" onclick="uploadAnalysisToDrive()">‚òÅÔ∏è Upload ph√¢n
          t√≠ch</button>
          <button class="btn" onclick="clearLocalCache()" style="background: #e74c3c;">üóëÔ∏è X√≥a cache</button>
      </div>
      <div class="card">
        <h3>üìä K·∫øt qu·∫£ ph√¢n t√≠ch</h3>
        <div id="analysisResults">
          <p>Ch∆∞a c√≥ d·ªØ li·ªáu ph√¢n t√≠ch.</p>
        </div>
      </div>
    </div>
  </div>
  <div class="bottom-menu">
    <a href="#" class="menu-item active" onclick="switchTab('tab-analysis')">üîç Ph√¢n t√≠ch</a>
  </div>
  <script>
    const CLIENT_ID = '398509518475-7bjid324tkuuh9gv8b0g92lhsgv8nrl5.apps.googleusercontent.com';
    const API_KEY = 'AIzaSyAbcWr0UPvC4YpsunE6uAa7E5pan9iys2o';
    const DISCOVERY_DOC = 'https://www.googleapis.com/discovery/v1/apis/drive/v3/rest';
    const SCOPES = 'https://www.googleapis.com/auth/drive';
    let tokenClient, gapi_inited = false, gsi_inited = false;
    let analysisData = [];
    const ANALYSIS_CACHE_NAME = 'AnalysisResults_QuanLyTruyen.json';
    let txtFiles = [];
 // T·ª´ nh·∫°y c·∫£m cho ph√¢n t√≠ch n√¢ng cao
    const sensitiveWords = {
      romantic: ['y√™u', 'th∆∞∆°ng', 'h√¥n', '√¥m', '·∫•p √¥m', '√¢m √°p', 'say ƒë·∫Øm', 'ƒëam m√™', 'd·ªãu d√†ng', 'ng·ªçt ng√†o', 'quy·∫øn r≈©', 'm√™ ho·∫∑c', 'th√¢n m·∫≠t', 'g·∫ßn g≈©i'],
      sexual: [
        'g·ªëi chƒÉn', 'ph√≤ng the', '√¢n √°i', 'l√†m t√¨nh', 'quan h·ªá', 't√¨nh d·ª•c',
        'd√¢m', 'd·ª•c', 'kho√°i c·∫£m', 'k√≠ch th√≠ch', 'kho·∫£ th√¢n', 'l√µa th·ªÉ',
        's∆∞·ªõng', 'r√™n r·ªâ', 'n·ª©ng', '∆∞·ªõt √°t', 'cao tr√†o', 'c·ª±c kho√°i', 'xu·∫•t tinh',
        'd∆∞∆°ng v·∫≠t', 'c·∫∑c', 'bu·ªìi', 'chim', 'c√°i ·∫•y',
        '√¢m ƒë·∫°o', 'l·ªìn', 'b∆∞·ªõm', '√¢m h·ªô', 'h·ªôt le', 'mu', 'l·ªó', 'xo·∫°c',
        'b√∫ v√∫', 'v√∫ to', 'v√∫ cƒÉng', 'b√∫ m√∫t', 'ng·ª±c tr·∫ßn', 'ng·ª±c kh·ªßng', 'ƒë·∫ßu ti',
        'b√∫ l·ªìn', 'b√∫ c·∫∑c', 'li·∫øm l·ªìn', 'li·∫øm bi', 'nu·ªët tinh', 'b√∫ h·ªôt le', 'b√∫ ƒë·∫ßu c·∫∑c',
        't·ª≠ cung', 'b·∫Øn v√†o t·ª≠ cung', 'c·∫∑c d√†i 20cm', 'ng·∫≠m tinh', 'ch·ªãch', 'ƒë·ªãt', 'n·∫Øc',
        'th·ªïi k√®n', 'bj', 'hj', 'anal', 'doggy', '69', 'threesome', 'th·ªß d√¢m',
        'ch∆°i g√°i', 'ƒëƒ©', 'g√°i m·∫°i d√¢m', 'm√¥ng to', 'th·ª•t ra th·ª•t v√†o', 'c·∫Øm s√¢u',
        's·ªù so·∫°ng', 'm√∫t', 'c·∫Øn', 'xoa', 'vu·ªët ve', 'h√∫p s√≤', 'ph√™', 'nghi·ªán sex',
        'xo·∫°c l·ªìn', 'xo·∫°c c·∫∑c', 'tra t·∫•n t√¨nh d·ª•c', 'h√†nh x√°c', 'ch·ªãu tr·∫≠n',
        'nh√©t', 'ƒë√∫t', 'l√†m nh·ª•c', 'b√≥p v√∫', 't√©t ƒë√≠t', 'v·ªó m√¥ng', 't√∫m t√≥c',
        'b·∫°o d√¢m', 'c∆∞·ª°ng hi·∫øp', 'hi·∫øp d√¢m', 'lo·∫°n lu√¢n', 'th·∫±ng cha', '√¥ng gi√† d√¢m ƒë√£ng',
        'con ƒëƒ©', 'con cave', 'ch·ªã d√¢u', 'em d√¢u', 'anh r·ªÉ', 'ch·ªã g√°i', 'm·∫π ch·ªìng', 'cha con', 'm·∫π con',
        'r√™n la', 'r√™n r·ªâ', 'h√©t l√™n v√¨ s∆∞·ªõng', 'm·∫Øt l·ªù ƒë·ªù', 'm·ªì h√¥i nh·ªÖ nh·∫°i',
        'b·∫Øn tinh', 'phun tinh', 'tinh d·ªãch', 'tinh tr√†n', 'nu·ªët s·∫°ch tinh',
        'm√πi tanh', 'v·ªã m·∫∑n', '∆∞·ªõt ƒë·∫´m', 'n∆∞·ªõc nh·ªùn', 'd·ªãch nh·ªùn',
        // ===== H√†nh ƒë·ªông & t√¨nh d·ª•c =====
        'l√†m t√¨nh', 'quan h·ªá', '√¢n √°i', 'th·ªß d√¢m', 'k√≠ch th√≠ch',
        'c·ªüi ƒë·ªì', 'vu·ªët ve', 's·ªù m√≥', '√¥m h√¥n', 'th√¢m nh·∫≠p',
        'r√™n r·ªâ', 'xu·∫•t tinh', 'cao tr√†o', 'c·ª±c kho√°i', '∆∞·ªõt √°t',

        // ===== L·ªùi tho·∫°i t√¨nh d·ª•c chung =====
        '"mu·ªën anh"', '"mu·ªën em"', '"l√†m em s∆∞·ªõng"', '"c·ª©ng qu√°"',
        '"em ∆∞·ªõt r·ªìi"', '"m·∫°nh l√™n"', '"ra ƒëi"', '"b·∫Øn v√†o trong"',

        // ===== Quan h·ªá gia ƒë√¨nh nh·∫°y c·∫£m =====
        'b·ªë ch·ªìng', 'con d√¢u', 'cha ch·ªìng', 'n√†ng d√¢u',
        '"b·ªë ch·ªìng"', '"con d√¢u"', '"cha ch·ªìng"', '"n√†ng d√¢u"',
        '"b·ªë ch·ªìng ∆°i"', '"con d√¢u ngoan"', '"b·ªë ch·ªìng l√†m cho con"',
        '"con d√¢u c·ªßa b·ªë"', '"b·ªë mu·ªën con"', '"b·ªë ch·ªìng kh√¥ng ch·ªãu n·ªïi"',
        '"con d√¢u s∆∞·ªõng qu√°"', '"l√†m d√¢u b·ªë"', '"b·ªë ch·ªìng y√™u con d√¢u"',

        // ===== C√°c t√¨nh hu·ªëng tho·∫°i ƒë·∫∑c th√π =====
        'quan h·ªá v·ªõi b·ªë ch·ªìng', 'quan h·ªá c√πng con d√¢u',
        'ch·ªãch con d√¢u', 'b·ªë ch·ªìng ƒë·ª• con d√¢u', 'b·ªë ch·ªìng hi·∫øp con d√¢u',
        'l√†m t√¨nh v·ªõi con d√¢u', 'b·ªë ch·ªìng √¥m con d√¢u',
        'con d√¢u r√™n', 'b·ªë ch·ªìng th·ªèa m√£n', 'b·ªë ch·ªìng c∆∞·ª°ng hi·∫øp'
      ],
      negative: ['gh√©t', 'h·∫≠n', 'gi·∫≠n', 't·ª©c', 't·ªßi', 'bu·ªìn', 'ƒëau', 'kh·ªï', 's·∫ßu', 'th·∫£m', 'bi', 'tang', 't·ª≠', 'ch·∫øt', 'gi·∫øt', 'h·∫°i', '√°c', 'd·ªØ', 'hung'],
      family: ['b·ªë', 'm·∫π', 'cha', 'con', 'ch·ªìng', 'v·ª£', 'd√¢u', 'r·ªÉ', 'anh', 'ch·ªã', 'em', '√¥ng', 'b√†', 'ch√∫', 'b√°c', 'c√¥', 'd√¨', 'c·∫≠u', 'm·ª£'],
      secret: ['b√≠ m·∫≠t', 'gi·∫•u gi·∫øm', 'che gi·∫•u', 'gi·∫•u di·∫øm', 'l√©n l√∫t', 'v·ª•ng tr·ªôm', '√¢m th·∫ßm', 'l·∫∑ng l·∫Ω', 'k√≠n ƒë√°o', 'ri√™ng t∆∞']
    };

    const emotionalWords = {
      positive: ['vui', 'h·∫°nh ph√∫c', 'y√™u', 'th∆∞∆°ng', 'tuy·ªát v·ªùi', 'ƒë·∫πp', 't·ªët', 'xu·∫•t s·∫Øc', 'th√†nh c√¥ng', 'hy v·ªçng'],
      negative: ['bu·ªìn', 'ƒëau', 'kh·ªï', 't·ªá', 'x·∫•u', 'th·∫•t b·∫°i', 'tuy·ªát v·ªçng', 'gh√©t', 't·ª©c gi·∫≠n', 'lo l·∫Øng', 's·ª£ h√£i', 'kh√≥c', 'tang th∆∞∆°ng', 'b·∫•t h·∫°nh', 'd·ªëi tr√°', 'ph·∫£n b·ªôi', 'l·ª´a d·ªëi', 'x√≥t xa', 'ƒëau ƒë·ªõn', 'x·∫•u h·ªï', 't·ªßi nh·ª•c'],
      neutral: ['b√¨nh th∆∞·ªùng', 'th√¥ng th∆∞·ªùng', 'trung b√¨nh', '·ªïn', 'ƒë∆∞·ª£c', 't·∫°m ·ªïn']
    };

    // T·ª´ kh√≥a ƒë·∫∑c bi·ªát cho ph√¢n t√≠ch h·ªôi tho·∫°i
    const dialogueIndicators = ['n√≥i', 'b·∫£o', 'h·ªèi', 'ƒë√°p', 'th∆∞a', 'k√™u', 'g·ªçi', 'h√©t', 'la', 'th√©t', 'th√¨ th·∫ßm', 'r·ªß r·ªâ', 'l√™n ti·∫øng', 'ph√°t bi·ªÉu', 'tr·∫£ l·ªùi', 'h·ªèi l·∫°i', 'ƒë√°p l·∫°i'];
    const dialoguePunctuation = ['"', "'", ':', ';', '-', '‚Äî', '‚Äì'];
    // ===== GOOGLE API INITIALIZATION =====
function gapiLoaded() {
    gapi.load('client', initializeGapiClient);
}

async function initializeGapiClient() {
    await gapi.client.init({
        apiKey: API_KEY,
        discoveryDocs: [DISCOVERY_DOC]
    });
    gapi_inited = true;
    maybeEnableButtons();
}

function gisLoaded() {
    tokenClient = google.accounts.oauth2.initTokenClient({
        client_id: CLIENT_ID,
        scope: SCOPES,
        callback: ''
    });
    gsi_inited = true;
    maybeEnableButtons();
}

function maybeEnableButtons() {
    if (gapi_inited && gsi_inited) {
        document.getElementById('scanBtn').disabled = false;
    }
}

function handleAuthClick() {
    tokenClient.callback = async (resp) => {
        if (resp.error !== undefined) {
            throw (resp);
        }
        gapi.client.setToken({access_token: resp.access_token});
        updateStatus('üü¢ ƒê√£ k·∫øt n·ªëi Google Drive');
        document.getElementById('scanBtn').disabled = false;
        document.getElementById('downloadAnalysisBtn').disabled = false;
    };

    if (gapi.client.getToken() === null) {
        tokenClient.requestAccessToken({prompt: 'consent'});
    } else {
        tokenClient.requestAccessToken({prompt: ''});
    }
}

// ===== UI UPDATE FUNCTIONS =====
function updateStatus(msg) {
    document.getElementById('statusInfo').innerText = msg;
}

function updateProgress(p) {
    document.getElementById('progressBar').style.width = p + '%';
}

function updateDetailedStatus(msg) {
    document.getElementById('detailedStatus').innerText = msg;
}
  // ===== LOCAL STORAGE FUNCTIONS =====
function saveAnalysisLocal() {
    const analysisContent = {
        analysisData: analysisData,
        timestamp: new Date().toISOString()
    };
    localStorage.setItem('analysisResults', JSON.stringify(analysisContent));
}

function loadAnalysisLocal() {
    const data = localStorage.getItem('analysisResults');
    if (data) {
        try {
            const parsed = JSON.parse(data);
            analysisData = parsed.analysisData || [];
            displayAdvancedAnalysisResults();
            updateStatus('‚úÖ ƒê√£ t·∫£i cache local');
            return true;
        } catch (e) {
            console.error('Error loading local cache:', e);
            updateStatus('‚ùå L·ªói khi t·∫£i cache local');
        }
    } else {
        updateStatus('‚ö†Ô∏è Kh√¥ng c√≥ cache local');
        displayEmptyState();
    }
    return false;
}
// ===== NEW FUNCTION: CLEAR CACHE & EMPTY STATE =====
function clearLocalCache() {
    if (confirm('B·∫°n c√≥ ch·∫Øc mu·ªën x√≥a to√†n b·ªô cache local?')) {
        localStorage.removeItem('analysisResults');
        analysisData = [];
        displayEmptyState();
        updateStatus('üóëÔ∏è ƒê√£ x√≥a cache local');
    }
}

function displayEmptyState() {
    const container = document.getElementById('analysisResults');
    container.innerHTML = `
        <div class="empty-state">
            <p>üì≠ Ch∆∞a c√≥ d·ªØ li·ªáu ph√¢n t√≠ch.</p>
            <p style="font-size: 0.9em; margin-top: 10px;">
                H√£y k·∫øt n·ªëi Google Drive, qu√©t th∆∞ m·ª•c v√† ph√¢n t√≠ch ƒë·ªÉ xem k·∫øt qu·∫£.
            </p>
        </div>
    `;
}
   // ===== GOOGLE DRIVE FUNCTIONS =====
function uploadAnalysisToDrive() {
    if (!analysisData || analysisData.length === 0) {
        alert("‚ö†Ô∏è Kh√¥ng c√≥ d·ªØ li·ªáu ph√¢n t√≠ch ƒë·ªÉ upload!");
        return;
    }

    const fileContent = JSON.stringify(analysisData, null, 2);
    const file = new Blob([fileContent], { type: 'application/json' });

    const metadata = {
        name: "analysisData.json",
        mimeType: "application/json"
    };

    const accessToken = gapi.client.getToken().access_token;
    const form = new FormData();
    form.append("metadata", new Blob([JSON.stringify(metadata)], { type: "application/json" }));
    form.append("file", file);

    fetch("https://www.googleapis.com/upload/drive/v3/files?uploadType=multipart&fields=id", {
        method: "POST",
        headers: new Headers({ "Authorization": "Bearer " + accessToken }),
        body: form
    }).then(res => res.json()).then(val => {
        alert("‚úÖ ƒê√£ upload ph√¢n t√≠ch l√™n Google Drive: " + val.id);
    }).catch(err => {
        console.error("Upload l·ªói:", err);
        alert("‚ùå L·ªói khi upload: " + err.message);
    });
}

async function downloadAnalysisFromDrive() {
    try {
        const accessToken = gapi.client.getToken().access_token;

        let res = await fetch(
            "https://www.googleapis.com/drive/v3/files?q=name='analysisData.json'&fields=files(id,name)",
            { headers: new Headers({ "Authorization": "Bearer " + accessToken }) }
        );
        let data = await res.json();

        if (!data.files || data.files.length === 0) {
            alert("‚ö†Ô∏è Kh√¥ng t√¨m th·∫•y file analysisData.json tr√™n Google Drive!");
            return;
        }

        const fileId = data.files[0].id;

        let fileRes = await fetch(
            `https://www.googleapis.com/drive/v3/files/${fileId}?alt=media`,
            { headers: new Headers({ "Authorization": "Bearer " + accessToken }) }
        );
        let content = await fileRes.json();

        analysisData = content;
        saveAnalysisLocal();

        alert("‚úÖ ƒê√£ t·∫£i ph√¢n t√≠ch v·ªÅ t·ª´ Google Drive!");
        displayAdvancedAnalysisResults();

    } catch (err) {
        console.error("Download l·ªói:", err);
        alert("‚ùå L·ªói khi t·∫£i ph√¢n t√≠ch t·ª´ Google Drive: " + err.message);
    }
}

const ROOT_FOLDER_NAME = "QuanLyTruyen";
   // ===== SCAN FOLDER FUNCTION =====
async function scanFolder() {
    updateStatus("üîç ƒêang qu√©t th∆∞ m·ª•c QuanLyTruyen...");
    updateProgress(5);

    try {
        const folderRes = await gapi.client.drive.files.list({
            q: `mimeType='application/vnd.google-apps.folder' and name='${ROOT_FOLDER_NAME}' and trashed=false`,
            fields: "files(id, name)"
        });

        if (!folderRes.result.files || folderRes.result.files.length === 0) {
            updateStatus("‚ùå Kh√¥ng t√¨m th·∫•y th∆∞ m·ª•c QuanLyTruyen tr√™n Google Drive!");
            return;
        }

        const rootFolderId = folderRes.result.files[0].id;
        txtFiles = [];
        await fetchFilesRecursive(rootFolderId, ROOT_FOLDER_NAME);

        if (txtFiles.length === 0) {
            updateStatus("‚ö†Ô∏è Kh√¥ng c√≥ file .txt n√†o trong QuanLyTruyen.");
            return;
        }

        updateStatus(`‚úÖ ƒê√£ qu√©t ƒë∆∞·ª£c ${txtFiles.length} file .txt`);
        updateProgress(100);
        document.getElementById("analyzeBtn").disabled = false;

    } catch (err) {
        console.error("‚ùå L·ªói khi qu√©t th∆∞ m·ª•c:", err);
        updateStatus("‚ùå L·ªói khi qu√©t th∆∞ m·ª•c: " + err.message);
    }
}

async function fetchFilesRecursive(folderId, folderPath) {
    let pageToken = null;
    do {
        const res = await gapi.client.drive.files.list({
            q: `'${folderId}' in parents and trashed=false`,
            fields: "nextPageToken, files(id, name, mimeType)",
            pageToken: pageToken
        });

        for (const file of res.result.files) {
            if (file.mimeType === "application/vnd.google-apps.folder") {
                await fetchFilesRecursive(file.id, `${folderPath}/${file.name}`);
            } else if (file.mimeType === "text/plain" || file.name.endsWith(".txt")) {
                txtFiles.push({
                    id: file.id,
                    name: file.name,
                    folderPath: folderPath
                });
            }
        }
        pageToken = res.result.nextPageToken;
    } while (pageToken);
}


// ===== ANALYZE FILES FUNCTION (FIXED) =====
async function analyzeFiles() {
    if (!txtFiles || txtFiles.length === 0) {
        alert('‚ö†Ô∏è Vui l√≤ng qu√©t th∆∞ m·ª•c tr∆∞·ªõc!');
        return;
    }

    // Load existing analysis from local cache
    let existingAnalysis = [];
    const localData = localStorage.getItem('analysisResults');
    if (localData) {
        try {
            existingAnalysis = JSON.parse(localData).analysisData || [];
        } catch (e) {
            console.error('Error loading existing analysis:', e);
        }
    }

    const analyzedFileNames = existingAnalysis.map(a => a.fileName);
    let filesToAnalyze = txtFiles.filter(f => !analyzedFileNames.includes(f.name));

    if (filesToAnalyze.length === 0) {
        updateStatus('‚úÖ T·∫•t c·∫£ file ƒë√£ ƒë∆∞·ª£c ph√¢n t√≠ch');
        analysisData = existingAnalysis;
        displayAdvancedAnalysisResults();
        return;
    }

    const totalFiles = Math.min(filesToAnalyze.length, 50); // Limit to prevent timeout
    analysisData = [...existingAnalysis];
    
    updateStatus(`üß† B·∫Øt ƒë·∫ßu ph√¢n t√≠ch ${totalFiles} file...`);

    for (let i = 0; i < totalFiles; i++) {
        const file = filesToAnalyze[i];
        updateProgress((i / totalFiles) * 100);
        updateDetailedStatus(`ƒêang ph√¢n t√≠ch: ${file.name} (${i + 1}/${totalFiles})`);

        try {
            // *** FIX: Actually read file content from Google Drive ***
            const content = await readFileFromDrive(file.id);
            const analysis = await performAdvancedAnalysis(content, file.name, file.folderPath);
            analysisData.push(analysis);
            saveAnalysisLocal();
            
            // Small delay to prevent rate limiting
            await new Promise(resolve => setTimeout(resolve, 100));
        } catch (err) {
            console.error(`Error analyzing ${file.name}:`, err);
            analysisData.push({
                fileName: file.name,
                folderPath: file.folderPath,
                timestamp: new Date().toLocaleString('vi-VN'),
                error: err.message
            });
        }
    }

    displayAdvancedAnalysisResults();
    updateProgress(100);
    updateStatus(`‚úÖ Ho√†n th√†nh ph√¢n t√≠ch ${totalFiles} file`);
    setTimeout(() => updateProgress(0), 2000);
}
// ===== NEW FUNCTION: READ FILE FROM DRIVE =====
async function readFileFromDrive(fileId) {
    try {
        const accessToken = gapi.client.getToken().access_token;
        const response = await fetch(
            `https://www.googleapis.com/drive/v3/files/${fileId}?alt=media`,
            {
                headers: {
                    'Authorization': `Bearer ${accessToken}`
                }
            }
        );
        
        if (!response.ok) {
            throw new Error(`Failed to read file: ${response.status}`);
        }
        
        return await response.text();
    } catch (error) {
        throw new Error(`Error reading file: ${error.message}`);
    }
}
 // ===== STORY ANALYSIS FUNCTIONS =====
async function performAdvancedAnalysis(content, fileName, folderPath) {
    const structure = analyzeStoryStructure(content);
    const wordCount = content.split(/\s+/).filter(word => word.length > 0).length;

    // Th√™m th·ªëng k√™ chi ti·∫øt
    const sensitiveStats = {
        romanticCount: structure.romantic ? structure.romantic.length : 0,
        sexualCount: structure.sexual ? structure.sexual.length : 0,
        negativeCount: structure.negative ? structure.negative.length : 0,
        familyCount: structure.family ? structure.family.length : 0,
        secretCount: structure.secret ? structure.secret.length : 0
    };

    const emotionStats = {
        positiveCount: structure.emotion?.positive ? structure.emotion.positive.length : 0,
        negativeCount: structure.emotion?.negative ? structure.emotion.negative.length : 0,
        neutralCount: structure.emotion?.neutral ? structure.emotion.neutral.length : 0
    };

    return {
        fileName: fileName,
        folderPath: folderPath,
        timestamp: new Date().toLocaleString('vi-VN'),
        basicStats: { 
            wordCount: wordCount,
            charCount: content.length,
            lineCount: content.split('\n').length
        },
        contentSample: content.substring(0, 200) + (content.length > 200 ? '...' : ''),
        storyStructure: structure,
        sensitiveStats: sensitiveStats,
        emotionStats: emotionStats
    };
}

function analyzeStoryStructure(content) {
    const lower = content.toLowerCase();
    
    // Helper function to find matches
    function findMatches(words) {
        return words.filter(w => lower.includes(w.toLowerCase()));
    }

    // 1. Structural analysis
    const contentLength = content.length;
    const moBai = content.substring(0, Math.min(300, contentLength));
    const ketBai = contentLength > 300 ? content.substring(Math.max(0, contentLength - 300)) : '';
    const thanBai = contentLength > 600 ? content.substring(300, contentLength - 300) : content.substring(300);

    // 2. Narrative perspective
    let ngoike = "Ng√¥i th·ª© ba";
    if (/\bt√¥i\b|\bta\b|\bch√∫ng t√¥i\b/i.test(content)) ngoike = "Ng√¥i th·ª© nh·∫•t";
    if (/\bb·∫°n\b|\bc·∫≠u\b|\bm√†y\b/i.test(content)) ngoike = "Ng√¥i th·ª© hai";

    // 3. Character detection (proper nouns)
    let characterMatches = content.match(/\b[A-Z√Ä√Å·∫¢√É·∫†√ÇƒÇƒê√ä√î∆†∆Ø][a-z√†√°·∫£√£·∫°√¢ƒÉƒë√™√¥∆°∆∞]+\b/g) || [];
    let uniqueChars = [...new Set(characterMatches)].slice(0, 10);

    // 4. Dialogue detection
    let dialogues = [];
    const lines = content.split('\n');
    for (const line of lines) {
        if (/["'].*["']/.test(line) || dialogueIndicators.some(ind => line.toLowerCase().includes(ind))) {
            dialogues.push(line.trim());
            if (dialogues.length >= 5) break;
        }
    }

    // 5. Time and place keywords
    const timeKeywords = ["s√°ng", "tr∆∞a", "chi·ªÅu", "t·ªëi", "ƒë√™m", "h√¥m qua", "ng√†y mai", "nƒÉm", "th√°ng", "tu·∫ßn", "gi·ªù"];
    const placeKeywords = ["nh√†", "l√†ng", "th√†nh ph·ªë", "r·ª´ng", "bi·ªÉn", "n√∫i", "tr∆∞·ªùng", "ch·ª£", "s√¥ng", "ph·ªë", "qu√™"];
    const eventKeywords = ["g·∫∑p g·ª°", "chia ly", "th·ª≠ th√°ch", "xung ƒë·ªôt", "chi·∫øn ƒë·∫•u", "gi·∫£i c·ª©u", "b√≠ m·∫≠t", "c∆∞·ªõi", "ch·∫øt"];

    let times = findMatches(timeKeywords);
    let places = findMatches(placeKeywords);
    let events = findMatches(eventKeywords);

    // 6. Sensitive content analysis
    let romantic = findMatches(sensitiveWords.romantic);
    let sexual = findMatches(sensitiveWords.sexual);
    let negative = findMatches(sensitiveWords.negative);
    let family = findMatches(sensitiveWords.family);
    let secret = findMatches(sensitiveWords.secret);

    // 7. Emotional analysis
    let emotionPos = findMatches(emotionalWords.positive);
    let emotionNeg = findMatches(emotionalWords.negative);
    let emotionNeu = findMatches(emotionalWords.neutral);

    return {
        moBai: moBai,
        thanBai: thanBai.substring(0, 500) + (thanBai.length > 500 ? '...' : ''),
        ketBai: ketBai,
        ngoike: ngoike,
        nhanVat: uniqueChars,
        hoiThoai: dialogues,
        thoiGian: times,
        diaDiem: places,
        tinhHuong: events,
        tuNgu18: sexual, // Renamed for consistency
        romantic: romantic,
        sexual: sexual,
        negative: negative,
        family: family,
        secret: secret,
        emotion: {
            positive: emotionPos,
            negative: emotionNeg,
            neutral: emotionNeu
        }
    };
}
// ===== DISPLAY RESULTS FUNCTION =====
function displayAdvancedAnalysisResults() {
    const safeArray = v => Array.isArray(v) ? v : [];
    const safeJoin = (value, separator = ', ') => {
        if (Array.isArray(value)) {
            return value.join(separator);
        }
        if (typeof value === "string") {
            return value;
        }
        return "";
    };

    const container = document.getElementById('analysisResults');
    if (!analysisData || analysisData.length === 0) {
        container.innerHTML = '<p>Ch∆∞a c√≥ d·ªØ li·ªáu ph√¢n t√≠ch.</p>';
        return;
    }

    let html = `<h4>üìä ƒê√£ ph√¢n t√≠ch ${analysisData.length} file truy·ªán</h4>`;

    // Statistics summary
    const totalWords = analysisData.reduce((sum, d) => sum + (d.basicStats?.wordCount || 0), 0);
    const avgWords = Math.round(totalWords / analysisData.length);
    html += `<div style="background:#2c3e50;padding:10px;margin:10px 0;border-radius:8px;">
        <p><strong>üìà Th·ªëng k√™ t·ªïng quan:</strong></p>
        <p>‚Ä¢ T·ªïng s·ªë t·ª´: ${totalWords.toLocaleString()} t·ª´</p>
        <p>‚Ä¢ Trung b√¨nh: ${avgWords.toLocaleString()} t·ª´/file</p>
    </div>`;

    analysisData.forEach((d, index) => {
        if (d.error) {
            html += `<div style="background:#e74c3c;padding:10px;margin:10px 0;border-radius:8px;">
                ‚ùå <strong>${d.fileName}</strong>: ${d.error}
            </div>`;
        } else {
            const struct = d.storyStructure || {};
            html += `<div style="background:#34495e;padding:15px;margin:10px 0;border-radius:8px;">
                <h5>üìÑ ${d.fileName}</h5>
                <p style="color:#bdc3c7;font-size:0.9em;">${d.folderPath} ‚Ä¢ ${d.timestamp}</p>
                
                <div style="display:grid;grid-template-columns:1fr 1fr;gap:10px;margin:10px 0;">
                    <div><strong>üìä S·ªë t·ª´:</strong> ${(d.basicStats?.wordCount || 0).toLocaleString()}</div>
                    <div><strong>üìù Ng√¥i k·ªÉ:</strong> ${struct.ngoike || 'Kh√¥ng x√°c ƒë·ªãnh'}</div>
                </div>

                <div style="margin:10px 0;">
                    <p><strong>üë• Nh√¢n v·∫≠t:</strong> ${safeJoin(struct.nhanVat)}</p>
                    <p><strong>‚è∞ Th·ªùi gian:</strong> ${safeJoin(struct.thoiGian)}</p>
                    <p><strong>üåç ƒê·ªãa ƒëi·ªÉm:</strong> ${safeJoin(struct.diaDiem)}</p>
                    <p><strong>üé≠ T√¨nh hu·ªëng:</strong> ${safeJoin(struct.tinhHuong)}</p>
                </div>

                <!-- Content Structure -->
                <div style="margin:10px 0;">
                    <details>
                        <summary style="cursor:pointer;color:#3498db;"><strong>üìñ M·ªü b√†i</strong></summary>
                        <div class="story-content">${struct.moBai || 'Kh√¥ng c√≥ d·ªØ li·ªáu'}</div>
                    </details>
                    
                    <details>
                        <summary style="cursor:pointer;color:#3498db;"><strong>üìñ Th√¢n b√†i</strong></summary>
                        <div class="story-content">${struct.thanBai || 'Kh√¥ng c√≥ d·ªØ li·ªáu'}</div>
                    </details>
                    
                    <details>
                        <summary style="cursor:pointer;color:#3498db;"><strong>üìñ K·∫øt b√†i</strong></summary>
                        <div class="story-content">${struct.ketBai || 'Kh√¥ng c√≥ d·ªØ li·ªáu'}</div>
                    </details>
                </div>

                <!-- Dialogue -->
                ${struct.hoiThoai && struct.hoiThoai.length > 0 ? `
                <details>
                    <summary style="cursor:pointer;color:#2ecc71;"><strong>üí¨ H·ªôi tho·∫°i (${struct.hoiThoai.length})</strong></summary>
                    <div class="story-content">
                        ${struct.hoiThoai.map(dialogue => `<p>‚Ä¢ ${dialogue}</p>`).join('')}
                    </div>
                </details>` : ''}

                <!-- Emotional Analysis -->
                <div style="margin:10px 0;">
                    <p><strong>üòä C·∫£m x√∫c t√≠ch c·ª±c:</strong> ${safeJoin(safeArray(struct.emotion?.positive))}</p>
                    <p><strong>üò¢ C·∫£m x√∫c ti√™u c·ª±c:</strong> ${safeJoin(safeArray(struct.emotion?.negative))}</p>
                    <p><strong>üòê C·∫£m x√∫c trung t√≠nh:</strong> ${safeJoin(safeArray(struct.emotion?.neutral))}</p>
                </div>

                <!-- Content Categories -->
                <div style="margin:10px 0;">
                    <p><strong>üíù Ng√¥n ng·ªØ t√¨nh c·∫£m:</strong> ${safeJoin(struct.romantic)}</p>
                    <p><strong>üë®‚Äçüë©‚Äçüëß‚Äçüë¶ Gia ƒë√¨nh:</strong> ${safeJoin(struct.family)}</p>
                    <p><strong>ü§´ B√≠ m·∫≠t:</strong> ${safeJoin(struct.secret)}</p>
                    <p><strong>‚ö†Ô∏è Ti√™u c·ª±c:</strong> ${safeJoin(struct.negative)}</p>
                    ${struct.sexual && struct.sexual.length > 0 ? `
                        <p><strong>üîû N·ªôi dung nh·∫°y c·∫£m:</strong> <span style="color:#e74c3c;">${struct.sexual.length} t·ª´ kh√≥a ph√°t hi·ªán</span></p>
                    ` : ''}
                </div>

                <!-- Content Sample -->
                <details>
                    <summary style="cursor:pointer;color:#95a5a6;"><strong>üìù M·∫´u n·ªôi dung</strong></summary>
                    <div class="story-content" style="font-style:italic;">${d.contentSample || 'Kh√¥ng c√≥ d·ªØ li·ªáu'}</div>
                </details>
            </div>`;
        }
    });

    container.innerHTML = html;
}
// ===== UI NAVIGATION =====
function switchTab(id) {
    document.querySelectorAll('.tab-content').forEach(t => t.classList.remove('active'));
    document.querySelectorAll('.menu-item').forEach(m => m.classList.remove('active'));
    
    document.getElementById(id).classList.add('active');
    event.target.classList.add('active');
}

// ===== INITIALIZATION =====
document.addEventListener('DOMContentLoaded', function() {
    // Try to load cached analysis on page load
    displayEmptyState();
});
    // ----------------- H√ÄM PH√ÇN T√çCH (gi·ªØ ho·∫∑c thay m·ªõi) -----------------
function analyzeStoryStructure(content) {
  const lower = (content || '').toLowerCase();

  // ƒë·∫£m b·∫£o fallback n·∫øu vocabulary kh√¥ng t·ªìn t·∫°i (an to√†n khi d√πng)
  const sWords = typeof sensitiveWords !== 'undefined' ? sensitiveWords : { romantic: [], sexual: [], negative: [], family: [], secret: [] };
  const eWords = typeof emotionalWords !== 'undefined' ? emotionalWords : { positive: [], negative: [], neutral: [] };
  const dIndicators = typeof dialogueIndicators !== 'undefined' ? dialogueIndicators : [];
  const dPunct = typeof dialoguePunctuation !== 'undefined' ? dialoguePunctuation : [];

  // M·ªü - th√¢n - k·∫øt
  let moBai = content.substring(0, 300);
  let ketBai = content.substring(Math.max(0, content.length - 300));
  let thanBai = content.substring(300, Math.max(300, content.length - 300));

  // Ng√¥i k·ªÉ
  let ngoike = "Ng√¥i th·ª© ba";
  if (/\bt√¥i\b|\bch√∫ng t√¥i\b/.test(lower)) ngoike = "Ng√¥i th·ª© nh·∫•t";
  if (/\bb·∫°n\b|\bc·∫≠u\b|\bm√†y\b/.test(lower)) ngoike = "Ng√¥i th·ª© hai";

  // Nh√¢n v·∫≠t - t√™n vi·∫øt hoa (l·∫•y t·ªëi ƒëa 10)
  let characterMatches = content.match(/\b[A-Z√Ä√Å·∫¢√É·∫†√ÇƒÇƒê√ä√î∆†∆Ø][a-z√†√°·∫£√£·∫°√¢ƒÉƒë√™√¥∆°∆∞]+\b/g) || [];
  let uniqueChars = [...new Set(characterMatches)].slice(0, 10);

  // H·ªôi tho·∫°i (d√≤ng c√≥ d·∫•u ngo·∫∑c ho·∫∑c ch·ª©a t·ª´ ch·ªâ tho·∫°i)
  let dialogues = [];
  content.split("\n").forEach(line => {
    if (/".*"/.test(line) || dIndicators.some(k => line.toLowerCase().includes(k))) {
      dialogues.push(line.trim());
    }
  });
  dialogues = dialogues.slice(0, 10);

  // Th·ªùi gian / ƒë·ªãa ƒëi·ªÉm / t√¨nh hu·ªëng
  const timeKeywords = ["s√°ng","tr∆∞a","chi·ªÅu","t·ªëi","ƒë√™m","h√¥m qua","ng√†y mai","nƒÉm","th√°ng"];
  let times = timeKeywords.filter(t => lower.includes(t));
  const placeKeywords = ["nh√†","l√†ng","th√†nh ph·ªë","r·ª´ng","bi·ªÉn","n√∫i","tr∆∞·ªùng","ch·ª£","s√¥ng"];
  let places = placeKeywords.filter(p => lower.includes(p));
  const eventKeywords = ["g·∫∑p g·ª°","chia ly","th·ª≠ th√°ch","xung ƒë·ªôt","chi·∫øn ƒë·∫•u","gi·∫£i c·ª©u","b√≠ m·∫≠t"];
  let events = eventKeywords.filter(e => lower.includes(e));

  // T·ª´ ng·ªØ nh·∫°y c·∫£m / c·∫£m x√∫c (d√πng danh s√°ch ƒë√£ khai b√°o)
  function findMatches(list){
    if(!Array.isArray(list) || list.length===0) return [];
    return list.filter(w => lower.includes(w)).slice(0, 20);
  }
  let romantic = findMatches(sWords.romantic);
  let sexual = findMatches(sWords.sexual);
  let negative = findMatches(sWords.negative);
  let family = findMatches(sWords.family);
  let secret = findMatches(sWords.secret);

  let emotionPos = findMatches(eWords.positive);
  let emotionNeg = findMatches(eWords.negative);
  let emotionNeu = findMatches(eWords.neutral);

  // H·ªôi tho·∫°i n√¢ng cao: d√≤ng c√≥ indicator ho·∫∑c d·∫•u c√¢u tho·∫°i
  let dialogueLines = content.split(/\n+/).filter(line => {
    const l = line.toLowerCase();
    return dIndicators.some(ind => l.includes(ind)) || dPunct.some(p => line.includes(p));
  }).slice(0, 10);

  return {
    moBai, thanBai, ketBai,
    ngoike,
    nhanVat: uniqueChars,
    hoiThoai: dialogues,
    dialogueLines,
    thoiGian: times,
    diaDiem: places,
    tinhHuong: events,
    tuNgu18: sexual,
    romantic, sexual, negative, family, secret,
    emotion: { positive: emotionPos, negative: emotionNeg, neutral: emotionNeu }
  };
}
   
  </script>
  <script async defer src="https://apis.google.com/js/api.js" onload="gapiLoaded()"></script>
  <script async defer src="https://accounts.google.com/gsi/client" onload="gisLoaded()"></script>
</body>

</html>
