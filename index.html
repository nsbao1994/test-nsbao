<!DOCTYPE html>
<html lang="vi">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Tr√¨nh Ph√¢n T√≠ch Truy·ªán AI</title>
    <script src="https://apis.google.com/js/api.js"></script>
    <script src="https://accounts.google.com/gsi/client"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'SF Pro Text', -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            color: #333;
            overflow-x: hidden;
        }

        .container {
            max-width: 100%;
            margin: 0;
            padding: 10px;
            padding-bottom: 80px; /* Space for bottom tabs */
        }

        .header {
            text-align: center;
            margin-bottom: 20px;
            color: white;
            padding: 20px 10px;
        }

        .header h1 {
            font-size: 1.8em;
            margin-bottom: 8px;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.3);
        }

        .header p {
            font-size: 1em;
            opacity: 0.9;
        }

        /* Tab Navigation */
        .tab-navigation {
            position: fixed;
            bottom: 0;
            left: 0;
            right: 0;
            background: white;
            box-shadow: 0 -2px 10px rgba(0,0,0,0.1);
            display: flex;
            z-index: 1000;
            border-top: 1px solid #e0e0e0;
        }

        .tab-button {
            flex: 1;
            padding: 12px 8px;
            text-align: center;
            border: none;
            background: none;
            color: #666;
            font-size: 11px;
            cursor: pointer;
            transition: all 0.2s ease;
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 4px;
        }

        .tab-button.active {
            color: #007AFF;
            background: #f0f8ff;
        }

        .tab-button .tab-icon {
            font-size: 20px;
        }

        /* Tab Content */
        .tab-content {
            display: none;
            animation: fadeIn 0.3s ease;
        }

        .tab-content.active {
            display: block;
        }

        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(10px); }
            to { opacity: 1; transform: translateY(0); }
        }

        /* Cards and Sections */
        .card {
            background: white;
            border-radius: 12px;
            padding: 20px;
            margin-bottom: 15px;
            box-shadow: 0 4px 12px rgba(0,0,0,0.1);
        }

        .card h3 {
            margin-bottom: 15px;
            font-size: 1.2em;
            color: #333;
        }

        /* Buttons */
        .btn-primary {
            background: linear-gradient(45deg, #4285f4, #34a853);
            color: white;
            border: none;
            padding: 14px 20px;
            border-radius: 25px;
            font-size: 1em;
            cursor: pointer;
            transition: all 0.3s ease;
            box-shadow: 0 4px 12px rgba(0,0,0,0.2);
            width: 100%;
            margin-bottom: 10px;
            font-weight: 500;
        }

        .btn-secondary {
            background: linear-gradient(45px, #54a0ff, #2e86de);
        }

        .btn-success {
            background: linear-gradient(45deg, #00d2d3, #01a3a4);
        }

        .btn-danger {
            background: linear-gradient(45deg, #ff6b6b, #ee5a24);
        }

        .btn-primary:hover:not(:disabled) {
            transform: translateY(-2px);
            box-shadow: 0 6px 16px rgba(0,0,0,0.3);
        }

        .btn-primary:disabled {
            background: #ccc;
            cursor: not-allowed;
            transform: none;
            box-shadow: none;
        }

        /* Status and Progress */
        .status-bar {
            background: #f8f9fa;
            padding: 10px 15px;
            border-radius: 8px;
            margin-bottom: 15px;
            font-size: 0.9em;
            border-left: 4px solid #007AFF;
        }

        .progress-bar {
            width: 100%;
            height: 6px;
            background: #e9ecef;
            border-radius: 3px;
            overflow: hidden;
            margin: 10px 0;
        }

        .progress-fill {
            height: 100%;
            background: linear-gradient(45deg, #28a745, #20c997);
            width: 0%;
            transition: width 0.3s ease;
        }

        /* Analysis Results */
        .file-card {
            background: white;
            border-radius: 10px;
            margin-bottom: 15px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.1);
            overflow: hidden;
        }

        .file-header {
            background: #f8f9fa;
            padding: 15px;
            border-bottom: 1px solid #e9ecef;
        }

        .file-name {
            font-weight: bold;
            color: #333;
            display: block;
            margin-bottom: 5px;
        }

        .file-header small {
            color: #666;
            font-size: 0.85em;
        }

        .collapsible {
            cursor: pointer;
            padding: 12px 15px;
            background: #f8f9fa;
            border: none;
            outline: none;
            font-size: 0.95em;
            font-weight: 500;
            border-bottom: 1px solid #e9ecef;
            width: 100%;
            text-align: left;
            transition: background-color 0.2s;
            color: #495057;
        }

        .collapsible:hover {
            background: #e8f4f8;
        }

        .collapsible.active {
            background: #d1ecf1;
            color: #0c5460;
        }

        .collapsible-content {
            max-height: 0;
            overflow: hidden;
            transition: max-height 0.3s ease-out;
            background: white;
        }

        .collapsible-content.active {
            max-height: 2000px;
            padding: 15px;
        }

        /* Grid layouts for mobile */
        .analysis-grid {
            display: grid;
            grid-template-columns: 1fr;
            gap: 10px;
            margin: 10px 0;
        }

        @media (min-width: 768px) {
            .analysis-grid {
                grid-template-columns: repeat(2, 1fr);
            }
        }

        .analysis-item {
            background: #f8f9fa;
            border-radius: 8px;
            padding: 12px;
            border-left: 4px solid #007bff;
        }

        .analysis-item h5 {
            color: #495057;
            margin-bottom: 6px;
            font-size: 0.95em;
            font-weight: 600;
        }

        .analysis-item p {
            margin: 0;
            font-size: 0.9em;
            line-height: 1.4;
        }

        /* Charts for mobile */
        .linguistic-chart {
            background: white;
            border-radius: 8px;
            padding: 12px;
            margin: 10px 0;
            border: 1px solid #dee2e6;
        }

        .chart-bar {
            display: flex;
            align-items: center;
            margin: 6px 0;
            font-size: 0.85em;
        }

        .chart-label {
            width: 80px;
            font-weight: 500;
            font-size: 0.8em;
            flex-shrink: 0;
        }

        .chart-progress {
            flex: 1;
            height: 16px;
            background: #e9ecef;
            border-radius: 8px;
            margin: 0 8px;
            overflow: hidden;
        }

        .chart-fill {
            height: 100%;
            background: linear-gradient(45deg, #007bff, #6610f2);
            transition: width 0.5s ease;
        }

        .chart-value {
            font-weight: bold;
            color: #495057;
            min-width: 30px;
            font-size: 0.8em;
        }

        /* Word cloud */
        .word-cloud {
            display: flex;
            flex-wrap: wrap;
            gap: 6px;
            margin: 10px 0;
        }

        .word-item {
            display: inline-block;
            padding: 4px 8px;
            background: linear-gradient(45deg, #667eea, #764ba2);
            color: white;
            border-radius: 12px;
            font-size: 0.8em;
            font-weight: 500;
        }

        /* Tags */
        .tag {
            display: inline-block;
            background: #e3f2fd;
            color: #1976d2;
            padding: 3px 6px;
            border-radius: 10px;
            font-size: 0.75em;
            margin: 2px;
        }

        /* Stats summary */
        .stats-summary {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 10px;
            margin: 15px 0;
        }

        .stat-card {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 15px;
            border-radius: 8px;
            text-align: center;
        }

        .stat-number {
            font-size: 1.5em;
            font-weight: bold;
            margin-bottom: 4px;
        }

        .stat-label {
            font-size: 0.8em;
            opacity: 0.9;
        }

        /* Story output */
        .story-output {
            background: #f8f9fa;
            border-left: 4px solid #007bff;
            padding: 15px;
            margin: 10px 0;
            border-radius: 0 8px 8px 0;
            white-space: pre-wrap;
            font-family: 'Times New Roman', serif;
            line-height: 1.6;
            font-size: 0.9em;
            max-height: 300px;
            overflow-y: auto;
        }

        /* Alerts */
        .alert {
            padding: 12px 15px;
            border-radius: 8px;
            margin: 10px 0;
            font-size: 0.9em;
        }

        .alert-error {
            background: #f8d7da;
            color: #721c24;
            border: 1px solid #f5c6cb;
        }

        .alert-success {
            background: #d4edda;
            color: #155724;
            border: 1px solid #c3e6cb;
        }

        /* Loading spinner */
        .loading {
            display: inline-block;
            width: 16px;
            height: 16px;
            border: 2px solid #f3f3f3;
            border-top: 2px solid #3498db;
            border-radius: 50%;
            animation: spin 1s linear infinite;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        /* Hidden class */
        .hidden {
            display: none !important;
        }

        /* Generation controls */
        .generation-controls {
            background: #f8f9fa;
            padding: 15px;
            border-radius: 8px;
            margin: 15px 0;
        }

        .generation-controls h4 {
            margin-bottom: 10px;
            color: #495057;
        }

        .control-group {
            margin-bottom: 15px;
        }

        .control-group label {
            display: block;
            margin-bottom: 5px;
            font-weight: 500;
            color: #495057;
        }

        .form-control {
            width: 100%;
            padding: 10px;
            border: 1px solid #ced4da;
            border-radius: 6px;
            font-size: 0.9em;
        }

        .form-control:focus {
            outline: none;
            border-color: #007AFF;
            box-shadow: 0 0 0 2px rgba(0,122,255,0.2);
        }

        /* Mobile optimizations */
        @media (max-width: 768px) {
            .container {
                padding: 5px;
            }
            
            .header {
                padding: 15px 5px;
            }
            
            .card {
                padding: 15px;
                margin-bottom: 10px;
            }
            
            .stats-summary {
                grid-template-columns: repeat(2, 1fr);
                gap: 8px;
            }
            
            .analysis-grid {
                grid-template-columns: 1fr;
                gap: 8px;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>Tr√¨nh Ph√¢n T√≠ch Truy·ªán AI</h1>
            <p>Ph√¢n t√≠ch v√† t·∫°o truy·ªán th√¥ng minh v·ªõi AI n√¢ng cao</p>
        </div>

        <!-- Tab Content Areas -->
        <div id="tab-auth" class="tab-content active">
            <div class="card">
                <div id="loginSection">
                    <h3>ƒêƒÉng nh·∫≠p Google Drive</h3>
                    <p style="margin-bottom: 15px;">K·∫øt n·ªëi v·ªõi Google Drive ƒë·ªÉ truy c·∫≠p th∆∞ m·ª•c "QuanLyTruyen"</p>
                    <button class="btn-primary" onclick="handleAuthClick()">
                        ƒêƒÉng nh·∫≠p Google Drive
                    </button>
                </div>
                <div id="loggedInSection" class="hidden">
                    <h3>ƒê√£ k·∫øt n·ªëi th√†nh c√¥ng!</h3>
                    <p id="userInfo" style="margin: 10px 0;"></p>
                    <button class="btn-danger" onclick="handleSignoutClick()">ƒêƒÉng xu·∫•t</button>
                </div>
            </div>

            <div class="card">
                <h3>Tr·∫°ng th√°i h·ªá th·ªëng</h3>
                <div class="status-bar" id="statusInfo">
                    <p>Ch∆∞a k·∫øt n·ªëi Google Drive</p>
                </div>
                <div class="progress-bar">
                    <div class="progress-fill" id="progressBar"></div>
                </div>
            </div>
        </div>

        <div id="tab-scan" class="tab-content">
            <div class="card">
                <h3>Qu·∫£n l√Ω File</h3>
                <button class="btn-primary" id="scanBtn" onclick="scanFolder()" disabled>
                    Qu√©t th∆∞ m·ª•c QuanLyTruyen
                </button>
                <button class="btn-secondary" id="loadAnalysisBtn" onclick="loadAnalysisResults()" disabled>
                    T·∫£i k·∫øt qu·∫£ ph√¢n t√≠ch ƒë√£ l∆∞u
                </button>
                <button class="btn-danger" id="clearCacheBtn" onclick="clearCache()" disabled>
                    X√≥a cache v√† qu√©t l·∫°i
                </button>
            </div>

            <div class="card">
                <h3>Ph√¢n t√≠ch n√¢ng cao</h3>
                <button class="btn-primary" id="analyzeBtn" onclick="analyzeFiles()" disabled>
                    Ph√¢n t√≠ch chi ti·∫øt t·∫•t c·∫£ file
                </button>
                <button class="btn-success" id="saveAnalysisBtn" onclick="saveAnalysisResults()" disabled>
                    L∆∞u k·∫øt qu·∫£ ph√¢n t√≠ch
                </button>
            </div>
        </div>

        <div id="tab-generate" class="tab-content">
            <div class="card">
                <h3>T·∫°o truy·ªán t·ª´ ph√¢n t√≠ch</h3>
                
                <div class="generation-controls">
                    <h4>C√†i ƒë·∫∑t t·∫°o truy·ªán</h4>
                    
                    <div class="control-group">
                        <label for="storyCount">S·ªë l∆∞·ª£ng truy·ªán:</label>
                        <select id="storyCount" class="form-control">
                            <option value="3">3 truy·ªán</option>
                            <option value="5" selected>5 truy·ªán</option>
                            <option value="10">10 truy·ªán</option>
                        </select>
                    </div>
                    
                    <div class="control-group">
                        <label for="storyLength">ƒê·ªô d√†i truy·ªán:</label>
                        <select id="storyLength" class="form-control">
                            <option value="short">Ng·∫Øn (200-500 t·ª´)</option>
                            <option value="medium" selected>Trung b√¨nh (500-1000 t·ª´)</option>
                            <option value="long">D√†i (1000-2000 t·ª´)</option>
                        </select>
                    </div>
                    
                    <div class="control-group">
                        <label for="storyStyle">Phong c√°ch:</label>
                        <select id="storyStyle" class="form-control">
                            <option value="classic">C·ªï ƒëi·ªÉn</option>
                            <option value="modern" selected>Hi·ªán ƒë·∫°i</option>
                            <option value="fantasy">Gi·∫£ t∆∞·ªüng</option>
                            <option value="romance">L√£ng m·∫°n</option>
                            <option value="adventure">Phi√™u l∆∞u</option>
                        </select>
                    </div>
                    
                    <div class="control-group">
                        <label for="storyTone">T√¥ng ƒëi·ªáu:</label>
                        <select id="storyTone" class="form-control">
                            <option value="positive" selected>T√≠ch c·ª±c</option>
                            <option value="neutral">Trung t√≠nh</option>
                            <option value="mixed">H·ªón h·ª£p</option>
                        </select>
                    </div>
                </div>

                <button class="btn-success" id="generateBtn" onclick="generateStories()" disabled>
                    T·∫°o truy·ªán m·ªõi
                </button>
                
                <button class="btn-primary" id="saveBtn" onclick="saveToGoogleDrive()" disabled>
                    L∆∞u truy·ªán l√™n Drive
                </button>
            </div>

            <div id="generatedStoriesContainer"></div>
        </div>

        <div id="tab-results" class="tab-content">
            <div class="card">
                <h3>K·∫øt qu·∫£ ph√¢n t√≠ch chi ti·∫øt</h3>
                <div id="analysisResults">
                    <p>Ch∆∞a c√≥ d·ªØ li·ªáu ph√¢n t√≠ch. Vui l√≤ng qu√©t v√† ph√¢n t√≠ch th∆∞ m·ª•c tr∆∞·ªõc.</p>
                </div>
            </div>
        </div>
    </div>

    <!-- Bottom Tab Navigation -->
    <div class="tab-navigation">
        <button class="tab-button active" onclick="switchTab('auth')">
            <div class="tab-icon">üîë</div>
            <div>ƒêƒÉng nh·∫≠p</div>
        </button>
        <button class="tab-button" onclick="switchTab('scan')">
            <div class="tab-icon">üîç</div>
            <div>Qu√©t & Ph√¢n t√≠ch</div>
        </button>
        <button class="tab-button" onclick="switchTab('generate')">
            <div class="tab-icon">‚úçÔ∏è</div>
            <div>T·∫°o truy·ªán</div>
        </button>
        <button class="tab-button" onclick="switchTab('results')">
            <div class="tab-icon">üìä</div>
            <div>K·∫øt qu·∫£</div>
        </button>
    </div>

    <script>
        // Google API Configuration
        const CLIENT_ID = '398509518475-7bjid324tkuuh9gv8b0g92lhsgv8nrl5.apps.googleusercontent.com';
        const API_KEY = 'AIzaSyAbcWr0UPvC4YpsunE6uAa7E5pan9iys2o';
        const DISCOVERY_DOC = 'https://www.googleapis.com/discovery/v1/apis/drive/v3/rest';
        const SCOPES = 'https://www.googleapis.com/auth/drive';

        let tokenClient;
        let gapi_inited = false;
        let gsi_inited = false;

        // Global variables
        let analysisData = [];
        let generatedStories = [];
        let scanCache = {};
        const CACHE_FILE_NAME = 'ScanCache_QuanLyTruyen.json';
        const ANALYSIS_CACHE_NAME = 'AnalysisResults_QuanLyTruyen.json';
        const STORIES_CACHE_NAME = 'GeneratedStories_QuanLyTruyen.json';

        // Tab switching function
        function switchTab(tabName) {
            // Remove active class from all tabs and buttons
            document.querySelectorAll('.tab-content').forEach(tab => {
                tab.classList.remove('active');
            });
            document.querySelectorAll('.tab-button').forEach(btn => {
                btn.classList.remove('active');
            });
            
            // Add active class to selected tab and button
            document.getElementById(`tab-${tabName}`).classList.add('active');
            document.querySelector(`[onclick="switchTab('${tabName}')"]`).classList.add('active');
        }

        // Vietnamese language processing data
        const vietnameseStopWords = [
            'l√†', 'c·ªßa', 'v√†', 'c√≥', 'm·ªôt', 'ƒë∆∞·ª£c', 'trong', 'kh√¥ng', 'v·ªõi', 't·ª´', 'ƒë·ªÉ', 'ƒë√£', 's·∫Ω',
            'v·ªÅ', 'cho', 'theo', 'nh∆∞', 'khi', 'v√†o', 'ra', 'l√™n', 'xu·ªëng', 'qua', 't·∫°i', 'hay',
            'r·∫±ng', 'n·∫øu', 'm√†', 'th√¨', 'ho·∫∑c', 'nh∆∞ng', 'v√¨', 'n√™n', 'ƒë·∫øn', 'b·∫±ng', 'tr√™n', 'd∆∞·ªõi'
        ];

        const emotionalWords = {
            positive: ['vui', 'h·∫°nh ph√∫c', 'y√™u', 'th∆∞∆°ng', 'tuy·ªát v·ªùi', 'ƒë·∫πp', 't·ªët', 'xu·∫•t s·∫Øc', 'th√†nh c√¥ng', 'hy v·ªçng', 'v·∫ª vang', 'h√¢n hoan', 'ph·∫•n kh√≠ch', 'c∆∞·ªùi', 'vui m·ª´ng'],
            negative: ['bu·ªìn', 'ƒëau', 'kh·ªï', 't·ªá', 'x·∫•u', 'th·∫•t b·∫°i', 'tuy·ªát v·ªçng', 'gh√©t', 't·ª©c gi·∫≠n', 'lo l·∫Øng', 's·ª£ h√£i', 'kh√≥c', 'tang th∆∞∆°ng', 'b·∫•t h·∫°nh'],
            neutral: ['b√¨nh th∆∞·ªùng', 'th√¥ng th∆∞·ªùng', 'trung b√¨nh', '·ªïn', 'ƒë∆∞·ª£c', 't·∫°m ·ªïn']
        };

        // Story templates for generation
        const storyTemplates = {
            classic: {
                opening: ["Ng√†y x·ª≠a ng√†y x∆∞a, c√≥ m·ªôt", "Trong m·ªôt ng√¥i l√†ng nh·ªè", "V√†o m·ªôt th·ªùi ƒë·∫°i xa x∆∞a"],
                middle: ["Nh∆∞ng r·ªìi m·ªôt ng√†y", "ƒê·ªôt nhi√™n", "Kh√¥ng ng·ªù"],
                ending: ["V√† t·ª´ ƒë√≥", "Cu·ªëi c√πng", "Th·∫ø l√†"]
            },
            modern: {
                opening: ["Trong th·ªùi ƒë·∫°i c√¥ng ngh·ªá", "·ªû m·ªôt th√†nh ph·ªë l·ªõn", "H√¥m nay"],
                middle: ["Tuy nhi√™n", "B·∫•t ng·ªù", "L√∫c n√†y"],
                ending: ["K·∫øt qu·∫£", "Cu·ªëi c√πng", "Sau t·∫•t c·∫£"]
            },
            fantasy: {
                opening: ["Trong th·∫ø gi·ªõi ph√©p thu·∫≠t", "·ªû v∆∞∆°ng qu·ªëc xa x√¥i", "N∆°i nh·ªØng sinh v·∫≠t th·∫ßn tho·∫°i"],
                middle: ["Nh∆∞ng m·ªôt th·∫ø l·ª±c ƒëen t·ªëi", "ƒê·ªôt nhi√™n ma thu·∫≠t", "Khi s·ª©c m·∫°nh c·ªï ƒë·∫°i"],
                ending: ["V√† √°nh s√°ng chi·∫øn th·∫Øng", "H√≤a b√¨nh ƒë∆∞·ª£c kh√¥i ph·ª•c", "Ma thu·∫≠t mang l·∫°i"]
            },
            romance: {
                opening: ["C√¢u chuy·ªán t√¨nh y√™u", "Hai tr√°i tim", "T√¨nh c·ªù g·∫∑p g·ª°"],
                middle: ["Nh∆∞ng ƒë·ªãnh m·ªánh", "T√¨nh y√™u ƒë√≠ch th·ª±c", "Tr√°i tim h·ªç"],
                ending: ["V√† t√¨nh y√™u ƒë√£", "H·ªç hi·ªÉu r·∫±ng", "H·∫°nh ph√∫c m√£i m√£i"]
            },
            adventure: {
                opening: ["Cu·ªôc phi√™u l∆∞u b·∫Øt ƒë·∫ßu", "H√†nh tr√¨nh kh√°m ph√°", "Th√°m hi·ªÉm v√πng ƒë·∫•t"],
                middle: ["Nh∆∞ng nguy hi·ªÉm r√¨nh r·∫≠p", "Th·ª≠ th√°ch kh√≥ khƒÉn", "B·∫•t ng·ªù"],
                ending: ["Cu·ªôc phi√™u l∆∞u k·∫øt th√∫c", "H·ªç ƒë√£ kh√°m ph√°", "Kinh nghi·ªám qu√Ω b√°u"]
            }
        };

        // Initialize Google APIs
        function gapiLoaded() {
            gapi.load('client', initializeGapiClient);
        }

        async function initializeGapiClient() {
            await gapi.client.init({
                apiKey: API_KEY,
                discoveryDocs: [DISCOVERY_DOC],
            });
            gapi_inited = true;
            maybeEnableButtons();
        }

        function gisLoaded() {
            tokenClient = google.accounts.oauth2.initTokenClient({
                client_id: CLIENT_ID,
                scope: SCOPES,
                callback: '',
            });
            gsi_inited = true;
            maybeEnableButtons();
        }

        function maybeEnableButtons() {
            if (gapi_inited && gsi_inited) {
                document.getElementById('scanBtn').disabled = false;
            }
        }

        // Authentication functions
        function handleAuthClick() {
            tokenClient.callback = async (resp) => {
                if (resp.error !== undefined) {
                    throw (resp);
                }
                await showLoggedInState();
            };

            if (gapi.client.getToken() === null) {
                tokenClient.requestAccessToken({prompt: 'consent'});
            } else {
                tokenClient.requestAccessToken({prompt: ''});
            }
        }

        function handleSignoutClick() {
            const token = gapi.client.getToken();
            if (token !== null) {
                google.accounts.oauth2.revoke(token.access_token);
                gapi.client.setToken('');
                showLoggedOutState();
            }
        }

        async function showLoggedInState() {
            document.getElementById('loginSection').classList.add('hidden');
            document.getElementById('loggedInSection').classList.remove('hidden');
            
            const buttons = ['scanBtn', 'clearCacheBtn', 'loadAnalysisBtn'];
            buttons.forEach(id => document.getElementById(id).disabled = false);
            
            try {
                const response = await gapi.client.request({
                    path: 'https://www.googleapis.com/oauth2/v1/userinfo',
                });
                document.getElementById('userInfo').textContent = `Xin ch√†o, ${response.result.name}!`;
                updateStatus('ƒê√£ k·∫øt n·ªëi Google Drive');
            } catch (error) {
                console.error('Error getting user info:', error);
            }
        }

        function showLoggedOutState() {
            document.getElementById('loginSection').classList.remove('hidden');
            document.getElementById('loggedInSection').classList.add('hidden');
            updateStatus('Ch∆∞a k·∫øt n·ªëi Google Drive');
            
            const buttons = ['scanBtn', 'clearCacheBtn', 'loadAnalysisBtn', 'analyzeBtn', 'saveAnalysisBtn', 'generateBtn', 'saveBtn'];
            buttons.forEach(id => document.getElementById(id).disabled = true);
        }

        // Story Generation Functions (Fixed Implementation)
        async function generateStories() {
            if (!analysisData || analysisData.length === 0) {
                showAlert('Vui l√≤ng ph√¢n t√≠ch file tr∆∞·ªõc khi t·∫°o truy·ªán!', 'error');
                switchTab('scan');
                return;
            }
            
            const storyCount = parseInt(document.getElementById('storyCount').value);
            const storyLength = document.getElementById('storyLength').value;
            const storyStyle = document.getElementById('storyStyle').value;
            const storyTone = document.getElementById('storyTone').value;
            
            updateStatus('ƒêang t·∫°o truy·ªán t·ª´ d·ªØ li·ªáu ph√¢n t√≠ch...');
            updateProgress(10);
            
            generatedStories = [];
            
            try {
                // Analyze themes and characters from analysis data
                const commonThemes = extractCommonThemes();
                const mainCharacters = extractMainCharacters();
                const emotionalTones = extractEmotionalTones();
                
                updateProgress(30);
                
                for (let i = 0; i < storyCount; i++) {
                    updateStatus(`ƒêang t·∫°o truy·ªán ${i + 1}/${storyCount}...`);
                    
                    const story = await generateSingleStory(
                        storyStyle, 
                        storyLength, 
                        storyTone,
                        commonThemes,
                        mainCharacters,
                        emotionalTones,
                        i + 1
                    );
                    
                    generatedStories.push(story);
                    updateProgress(30 + ((i + 1) / storyCount) * 60);
                    
                    // Small delay to show progress
                    await new Promise(resolve => setTimeout(resolve, 500));
                }
                
                updateProgress(90);
                displayGeneratedStories();
                document.getElementById('saveBtn').disabled = false;
                
                updateStatus(`ƒê√£ t·∫°o th√†nh c√¥ng ${storyCount} truy·ªán`);
                updateProgress(100);
                
                setTimeout(() => updateProgress(0), 2000);
                
            } catch (error) {
                console.error('Error generating stories:', error);
                showAlert(`L·ªói khi t·∫°o truy·ªán: ${error.message}`, 'error');
                updateStatus('L·ªói khi t·∫°o truy·ªán');
                updateProgress(0);
            }
        }

        function extractCommonThemes() {
            const themeCount = {};
            
            analysisData.forEach(analysis => {
                if (analysis.thematicAnalysis && analysis.thematicAnalysis.mainThemes) {
                    analysis.thematicAnalysis.mainThemes.forEach(theme => {
                        themeCount[theme.theme] = (themeCount[theme.theme] || 0) + theme.mentions;
                    });
                }
            });
            
            return Object.entries(themeCount)
                .sort(([,a], [,b]) => b - a)
                .slice(0, 5)
                .map(([theme]) => theme);
        }

        function extractMainCharacters() {
            const characterNames = [];
            const characterTraits = [];
            
            analysisData.forEach(analysis => {
                if (analysis.characterAnalysis && analysis.characterAnalysis.characters) {
                    analysis.characterAnalysis.characters.forEach(char => {
                        if (char.importance === 'Ch√≠nh' || char.appearances > 3) {
                            characterNames.push(char.name);
                            if (char.traits && char.traits.length > 0) {
                                characterTraits.push(...char.traits.map(t => t.trait));
                            }
                        }
                    });
                }
            });
            
            return {
                names: [...new Set(characterNames)].slice(0, 5),
                traits: [...new Set(characterTraits)].slice(0, 10)
            };
        }

        function extractEmotionalTones() {
            const emotionCount = { positive: 0, negative: 0, neutral: 0 };
            
            analysisData.forEach(analysis => {
                if (analysis.emotionalAnalysis && analysis.emotionalAnalysis.emotionBreakdown) {
                    Object.entries(analysis.emotionalAnalysis.emotionBreakdown).forEach(([emotion, data]) => {
                        emotionCount[emotion] += data.count;
                    });
                }
            });
            
            const total = Object.values(emotionCount).reduce((a, b) => a + b, 0);
            return Object.entries(emotionCount).map(([emotion, count]) => ({
                emotion,
                percentage: total > 0 ? (count / total * 100).toFixed(1) : 0
            }));
        }

        async function generateSingleStory(style, length, tone, themes, characters, emotions, storyNumber) {
            // Get word count based on length setting
            const wordCounts = {
                short: { min: 200, max: 500 },
                medium: { min: 500, max: 1000 },
                long: { min: 1000, max: 2000 }
            };
            
            const targetWords = Math.floor(Math.random() * (wordCounts[length].max - wordCounts[length].min)) + wordCounts[length].min;
            
            // Select random theme and characters
            const selectedTheme = themes[Math.floor(Math.random() * themes.length)] || 'T√¨nh b·∫°n';
            const selectedCharacterName = characters.names[Math.floor(Math.random() * characters.names.length)] || generateVietnameseName();
            const selectedTrait = characters.traits[Math.floor(Math.random() * characters.traits.length)] || 't·ªët b·ª•ng';
            
            // Get templates for the style
            const templates = storyTemplates[style] || storyTemplates.modern;
            
            // Generate story content
            const opening = templates.opening[Math.floor(Math.random() * templates.opening.length)];
            const middle = templates.middle[Math.floor(Math.random() * templates.middle.length)];
            const ending = templates.ending[Math.floor(Math.random() * templates.ending.length)];
            
            // Create story structure
            const story = {
                id: `story_${Date.now()}_${storyNumber}`,
                title: generateStoryTitle(selectedTheme, style),
                content: generateStoryContent(opening, middle, ending, selectedCharacterName, selectedTheme, selectedTrait, tone, targetWords),
                metadata: {
                    style: style,
                    length: length,
                    tone: tone,
                    theme: selectedTheme,
                    character: selectedCharacterName,
                    wordCount: 0, // Will be calculated
                    createdAt: new Date().toISOString()
                }
            };
            
            // Calculate actual word count
            story.metadata.wordCount = story.content.split(/\s+/).length;
            
            return story;
        }

        function generateVietnameseName() {
            const firstNames = ['An', 'B√¨nh', 'C∆∞·ªùng', 'Dung', 'Em', 'H√†', 'H√≤a', 'Linh', 'Mai', 'Nam', 'Oanh', 'Phong', 'Quang', 'S∆°n', 'Th·∫£o', 'Uy√™n', 'VƒÉn', 'Xu√¢n', 'Y·∫øn', 'Zung'];
            const lastNames = ['Nguy·ªÖn', 'Tr·∫ßn', 'L√™', 'Ph·∫°m', 'Ho√†ng', 'Phan', 'V≈©', 'V√µ', 'ƒê·∫∑ng', 'B√πi'];
            
            const firstName = firstNames[Math.floor(Math.random() * firstNames.length)];
            const lastName = lastNames[Math.floor(Math.random() * lastNames.length)];
            
            return `${lastName} ${firstName}`;
        }

        function generateStoryTitle(theme, style) {
            const titleTemplates = {
                'T√¨nh y√™u': ['M·ªëi T√¨nh ƒê·∫ßu', 'Y√™u Th∆∞∆°ng M√£i M√£i', 'Tr√°i Tim V√† N·ª• C∆∞·ªùi', 'T√¨nh Y√™u ƒê√≠ch Th·ª±c'],
                'Gia ƒë√¨nh': ['T√¨nh Th√¢n Y√™u', 'M√°i ·∫§m Gia ƒê√¨nh', 'Y√™u Th∆∞∆°ng Nh√†', 'K·ª∑ Ni·ªám Gia ƒê√¨nh'],
                'T√¨nh b·∫°n': ['T√¨nh B·∫°n ƒê·∫πp', 'Nh·ªØng Ng∆∞·ªùi B·∫°n Th√¢n', 'H·ªØu Ngh·ªã Vƒ©nh C·ª≠u', 'B·∫°n B√® M√£i M√£i'],
                'Phi√™u l∆∞u': ['Cu·ªôc Phi√™u L∆∞u K·ª≥ Th√∫', 'H√†nh Tr√¨nh Kh√°m Ph√°', 'Th√°m Hi·ªÉm B√≠ ·∫®n', 'Chuy·∫øn ƒêi Kh√≥ Qu√™n'],
                'H·ªçc t·∫≠p': ['Con ƒê∆∞·ªùng Tri Th·ª©c', 'H·ªçc H·ªèi V√† Tr∆∞·ªüng Th√†nh', 'Gi·∫•c M∆° H·ªçc Tr√≤', 'Th·∫ßy C√¥ V√† H·ªçc Sinh']
            };
            
            const templates = titleTemplates[theme] || ['C√¢u Chuy·ªán Cu·ªôc S·ªëng', 'Nh·ªØng Ng√†y Th√°ng ƒê·∫πp', 'K·ª∑ Ni·ªám Kh√≥ Qu√™n'];
            return templates[Math.floor(Math.random() * templates.length)];
        }

        function generateStoryContent(opening, middle, ending, characterName, theme, trait, tone, targetWords) {
            let content = '';
            
            // Opening paragraph
            content += `${opening}, c√≥ ${characterName} - m·ªôt ng∆∞·ªùi r·∫•t ${trait}. `;
            
            // Add theme-based context
            switch(theme) {
                case 'T√¨nh y√™u':
                    content += `${characterName} lu√¥n tin v√†o t√¨nh y√™u ƒë√≠ch th·ª±c v√† mong mu·ªën t√¨m ƒë∆∞·ª£c ng∆∞·ªùi b·∫°n ƒë·ªùi c·ªßa ƒë·ªùi m√¨nh. `;
                    break;
                case 'Gia ƒë√¨nh':
                    content += `${characterName} sinh ra trong m·ªôt gia ƒë√¨nh ·∫•m √°p, n∆°i t√¨nh y√™u th∆∞∆°ng ƒë∆∞·ª£c chia s·∫ª m·ªói ng√†y. `;
                    break;
                case 'T√¨nh b·∫°n':
                    content += `${characterName} c√≥ nh·ªØng ng∆∞·ªùi b·∫°n th·∫≠t t·ªët, lu√¥n s√°t c√°nh b√™n nhau trong m·ªçi ho√†n c·∫£nh. `;
                    break;
                case 'Phi√™u l∆∞u':
                    content += `${characterName} lu√¥n khao kh√°t ƒë∆∞·ª£c kh√°m ph√° nh·ªØng v√πng ƒë·∫•t m·ªõi, tr·∫£i nghi·ªám nh·ªØng ƒëi·ªÅu th√∫ v·ªã. `;
                    break;
                default:
                    content += `${characterName} s·ªëng cu·ªôc ƒë·ªùi b√¨nh th∆∞·ªùng nh∆∞ng ƒë·∫ßy √Ω nghƒ©a. `;
            }
            
            content += '\n\n';
            
            // Middle development
            content += `${middle}, cu·ªôc s·ªëng c·ªßa ${characterName} c√≥ nh·ªØng thay ƒë·ªïi l·ªõn. `;
            
            // Add conflict based on theme
            switch(theme) {
                case 'T√¨nh y√™u':
                    content += `${characterName} g·∫∑p ƒë∆∞·ª£c m·ªôt ng∆∞·ªùi ƒë·∫∑c bi·ªát, nh∆∞ng t√¨nh y√™u kh√¥ng ph·∫£i l√∫c n√†o c≈©ng su√¥n s·∫ª. H·ªç ph·∫£i v∆∞·ª£t qua nhi·ªÅu th·ª≠ th√°ch ƒë·ªÉ hi·ªÉu ƒë∆∞·ª£c √Ω nghƒ©a th·ª±c s·ª± c·ªßa t√¨nh y√™u. `;
                    break;
                case 'Gia ƒë√¨nh':
                    content += `Gia ƒë√¨nh ${characterName} g·∫∑p ph·∫£i kh√≥ khƒÉn, nh∆∞ng ch√≠nh l√∫c n√†y h·ªç m·ªõi th·∫•y ƒë∆∞·ª£c s·ª©c m·∫°nh c·ªßa t√¨nh th√¢n. M·ªçi ng∆∞·ªùi ƒëo√†n k·∫øt ƒë·ªÉ v∆∞·ª£t qua th·ª≠ th√°ch. `;
                    break;
                case 'T√¨nh b·∫°n':
                    content += `${characterName} v√† nh·ªØng ng∆∞·ªùi b·∫°n ph·∫£i ƒë·ªëi m·∫∑t v·ªõi m·ªôt th·ª≠ th√°ch l·ªõn. T√¨nh b·∫°n c·ªßa h·ªç ƒë∆∞·ª£c th·ª≠ th√°ch, nh∆∞ng c≈©ng ƒë∆∞·ª£c c·ªßng c·ªë m·∫°nh m·∫Ω h∆°n. `;
                    break;
                case 'Phi√™u l∆∞u':
                    content += `Trong cu·ªôc phi√™u l∆∞u c·ªßa m√¨nh, ${characterName} g·∫∑p ph·∫£i nhi·ªÅu nguy hi·ªÉm b·∫•t ng·ªù. Nh∆∞ng ch√≠nh nh·ªØng th·ª≠ th√°ch n√†y ƒë√£ gi√∫p h·ªç tr∆∞·ªüng th√†nh v√† m·∫°nh m·∫Ω h∆°n. `;
                    break;
                default:
                    content += `${characterName} ph·∫£i ƒë·ªëi m·∫∑t v·ªõi m·ªôt quy·∫øt ƒë·ªãnh quan tr·ªçng trong cu·ªôc ƒë·ªùi. ƒê√¢y l√† l√∫c ƒë·ªÉ h·ªç th·ªÉ hi·ªán b·∫£n ch·∫•t th·∫≠t s·ª± c·ªßa m√¨nh. `;
            }
            
            content += '\n\n';
            
            // Resolution and ending
            content += `${ending}, ${characterName} ƒë√£ h·ªçc ƒë∆∞·ª£c nh·ªØng b√†i h·ªçc qu√Ω gi√°. `;
            
            // Add positive ending based on tone
            if (tone === 'positive') {
                switch(theme) {
                    case 'T√¨nh y√™u':
                        content += `T√¨nh y√™u ƒë√£ chi·∫øn th·∫Øng m·ªçi kh√≥ khƒÉn. ${characterName} t√¨m ƒë∆∞·ª£c h·∫°nh ph√∫c b√™n ng∆∞·ªùi m√¨nh y√™u v√† hi·ªÉu r·∫±ng t√¨nh y√™u ƒë√≠ch th·ª±c ƒë√°ng ƒë·ªÉ ch·ªù ƒë·ª£i v√† chi·∫øn ƒë·∫•u.`;
                        break;
                    case 'Gia ƒë√¨nh':
                        content += `Gia ƒë√¨nh h·ªç tr·ªü n√™n g·∫Øn k·∫øt h∆°n bao gi·ªù h·∫øt. ${characterName} c·∫£m nh·∫≠n ƒë∆∞·ª£c s·ª± ·∫•m √°p v√† bi·∫øt r·∫±ng gia ƒë√¨nh ch√≠nh l√† n∆°i ƒë·ªÉ tr·ªü v·ªÅ khi kh√≥ khƒÉn.`;
                        break;
                    case 'T√¨nh b·∫°n':
                        content += `T√¨nh b·∫°n c·ªßa h·ªç tr·ªü n√™n b·ªÅn ch·∫∑t h∆°n sau th·ª≠ th√°ch. ${characterName} hi·ªÉu r·∫±ng c√≥ ƒë∆∞·ª£c nh·ªØng ng∆∞·ªùi b·∫°n th·∫≠t s·ª± l√† ƒëi·ªÅu may m·∫Øn nh·∫•t trong ƒë·ªùi.`;
                        break;
                    case 'Phi√™u l∆∞u':
                        content += `Cu·ªôc phi√™u l∆∞u k·∫øt th√∫c v·ªõi nh·ªØng tr·∫£i nghi·ªám tuy·ªát v·ªùi. ${characterName} tr·ªü v·ªÅ v·ªõi h√†nh trang ƒë·∫ßy k·ª∑ ni·ªám ƒë·∫πp v√† s·ª± tr∆∞·ªüng th√†nh ƒë√°ng k·ªÉ.`;
                        break;
                    default:
                        content += `Cu·ªëi c√πng m·ªçi vi·ªác ƒë·ªÅu tr·ªü n√™n t·ªët ƒë·∫πp. ${characterName} c·∫£m th·∫•y h·∫°nh ph√∫c v√† bi·∫øt ∆°n v√¨ nh·ªØng g√¨ cu·ªôc s·ªëng ƒë√£ ban t·∫∑ng.`;
                }
            } else {
                content += `D√π kh√¥ng ph·∫£i t·∫•t c·∫£ ƒë·ªÅu nh∆∞ mong ƒë·ª£i, nh∆∞ng ${characterName} ƒë√£ tr∆∞·ªüng th√†nh v√† hi·ªÉu ƒë∆∞·ª£c √Ω nghƒ©a cu·ªôc s·ªëng. H·ªç bi·∫øt r·∫±ng m·ªói tr·∫£i nghi·ªám ƒë·ªÅu c√≥ gi√° tr·ªã ri√™ng c·ªßa n√≥.`;
            }
            
            // Expand content if needed to reach target word count
            const currentWords = content.split(/\s+/).length;
            if (currentWords < targetWords * 0.8) {
                content += '\n\n';
                content += generateAdditionalContent(characterName, theme, tone, targetWords - currentWords);
            }
            
            return content;
        }

        function generateAdditionalContent(characterName, theme, tone, remainingWords) {
            let additional = '';
            
            // Add more descriptive content
            additional += `Nh·ªØng ng√†y th√°ng tr√¥i qua, ${characterName} lu√¥n nh·ªõ v·ªÅ kho·∫£ng th·ªùi gian ƒë·∫∑c bi·ªát ·∫•y. `;
            
            switch(theme) {
                case 'T√¨nh y√™u':
                    additional += `H·ªç hi·ªÉu r·∫±ng t√¨nh y√™u kh√¥ng ch·ªâ l√† c·∫£m x√∫c m·∫°nh m·∫Ω l√∫c ƒë·∫ßu, m√† c√≤n l√† s·ª± quan t√¢m, chia s·∫ª v√† ƒë·ªìng h√†nh trong t·ª´ng kho·∫£nh kh·∫Øc c·ªßa cu·ªôc s·ªëng. M·ªói ng√†y tr√¥i qua, t√¨nh y√™u ·∫•y l·∫°i c√†ng s√¢u s·∫Øc v√† √Ω nghƒ©a h∆°n. `;
                    break;
                case 'Gia ƒë√¨nh':
                    additional += `Gia ƒë√¨nh kh√¥ng ch·ªâ l√† n∆°i ƒë·ªÉ s·ªëng, m√† c√≤n l√† n∆°i ƒë·ªÉ y√™u th∆∞∆°ng v√† ƒë∆∞·ª£c y√™u th∆∞∆°ng. ${characterName} c·∫£m nh·∫≠n ƒë∆∞·ª£c r·∫±ng d√π c√≥ ƒëi ƒë√¢u xa, tr√°i tim h·ªç v·∫´n lu√¥n h∆∞·ªõng v·ªÅ m√°i nh√† ·∫•m √°p v√† nh·ªØng ng∆∞·ªùi th√¢n y√™u. `;
                    break;
                case 'T√¨nh b·∫°n':
                    additional += `T√¨nh b·∫°n ƒë√≠ch th·ª±c kh√¥ng ƒëo l∆∞·ªùng b·∫±ng th·ªùi gian hay kho·∫£ng c√°ch, m√† b·∫±ng s·ª± hi·ªÉu bi·∫øt v√† s·∫ª chia. ${characterName} bi·∫øt r·∫±ng c√≥ ƒë∆∞·ª£c nh·ªØng ng∆∞·ªùi b·∫°n s·∫µn s√†ng ƒë·ª©ng b√™n m√¨nh trong l√∫c kh√≥ khƒÉn l√† ƒëi·ªÅu qu√Ω gi√° nh·∫•t. `;
                    break;
                default:
                    additional += `Cu·ªôc s·ªëng c√≥ nhi·ªÅu m√†u s·∫Øc kh√°c nhau, v√† ${characterName} ƒë√£ h·ªçc ƒë∆∞·ª£c c√°ch tr√¢n tr·ªçng t·ª´ng kho·∫£nh kh·∫Øc, d√π vui hay bu·ªìn. H·ªç hi·ªÉu r·∫±ng ch√≠nh nh·ªØng tr·∫£i nghi·ªám ƒëa d·∫°ng ·∫•y ƒë√£ l√†m n√™n m·ªôt cu·ªôc ƒë·ªùi tr·ªçn v·∫πn. `;
            }
            
            return additional;
        }

        function displayGeneratedStories() {
            const container = document.getElementById('generatedStoriesContainer');
            container.innerHTML = '';
            
            if (generatedStories.length === 0) {
                container.innerHTML = '<p>Ch∆∞a c√≥ truy·ªán n√†o ƒë∆∞·ª£c t·∫°o.</p>';
                return;
            }
            
            // Add summary card
            const summaryCard = document.createElement('div');
            summaryCard.className = 'card';
            summaryCard.innerHTML = `
                <h3>T·ªïng quan truy·ªán ƒë√£ t·∫°o</h3>
                <div class="stats-summary">
                    <div class="stat-card">
                        <div class="stat-number">${generatedStories.length}</div>
                        <div class="stat-label">Truy·ªán ƒë√£ t·∫°o</div>
                    </div>
                    <div class="stat-card">
                        <div class="stat-number">${generatedStories.reduce((sum, story) => sum + story.metadata.wordCount, 0)}</div>
                        <div class="stat-label">T·ªïng s·ªë t·ª´</div>
                    </div>
                    <div class="stat-card">
                        <div class="stat-number">${Math.round(generatedStories.reduce((sum, story) => sum + story.metadata.wordCount, 0) / generatedStories.length)}</div>
                        <div class="stat-label">T·ª´/truy·ªán TB</div>
                    </div>
                    <div class="stat-card">
                        <div class="stat-number">${Math.round(generatedStories.reduce((sum, story) => sum + story.metadata.wordCount, 0) / 250)}</div>
                        <div class="stat-label">Ph√∫t ƒë·ªçc ∆∞·ªõc t√≠nh</div>
                    </div>
                </div>
            `;
            container.appendChild(summaryCard);
            
            // Add individual stories
            generatedStories.forEach((story, index) => {
                const storyCard = document.createElement('div');
                storyCard.className = 'file-card';
                
                storyCard.innerHTML = `
                    <div class="file-header">
                        <span class="file-name">${story.title}</span>
                        <small>
                            ${story.metadata.wordCount} t·ª´ | ${story.metadata.style} | ${story.metadata.theme}
                            <br>T·∫°o l√∫c: ${new Date(story.metadata.createdAt).toLocaleString('vi-VN')}
                        </small>
                    </div>
                    
                    <button class="collapsible" onclick="toggleCollapsible(this)">
                        ƒê·ªçc truy·ªán
                    </button>
                    <div class="collapsible-content">
                        <div class="story-output">${story.content}</div>
                    </div>
                    
                    <button class="collapsible" onclick="toggleCollapsible(this)">
                        Chi ti·∫øt k·ªπ thu·∫≠t
                    </button>
                    <div class="collapsible-content">
                        <div class="analysis-grid">
                            <div class="analysis-item">
                                <h5>Phong c√°ch</h5>
                                <p>${story.metadata.style}</p>
                            </div>
                            <div class="analysis-item">
                                <h5>ƒê·ªô d√†i</h5>
                                <p>${story.metadata.length} (${story.metadata.wordCount} t·ª´)</p>
                            </div>
                            <div class="analysis-item">
                                <h5>T√¥ng ƒëi·ªáu</h5>
                                <p>${story.metadata.tone}</p>
                            </div>
                            <div class="analysis-item">
                                <h5>Ch·ªß ƒë·ªÅ ch√≠nh</h5>
                                <p>${story.metadata.theme}</p>
                            </div>
                            <div class="analysis-item">
                                <h5>Nh√¢n v·∫≠t ch√≠nh</h5>
                                <p>${story.metadata.character}</p>
                            </div>
                            <div class="analysis-item">
                                <h5>Th·ªùi gian ƒë·ªçc</h5>
                                <p>${Math.round(story.metadata.wordCount / 250)} ph√∫t</p>
                            </div>
                        </div>
                    </div>
                `;
                
                container.appendChild(storyCard);
            });
        }

        async function saveToGoogleDrive() {
            if (!generatedStories || generatedStories.length === 0) {
                showAlert('Kh√¥ng c√≥ truy·ªán n√†o ƒë·ªÉ l∆∞u!', 'error');
                return;
            }
            
            updateStatus('ƒêang l∆∞u truy·ªán l√™n Google Drive...');
            updateProgress(10);
            
            try {
                // Create stories collection
                const storiesCollection = {
                    timestamp: new Date().toISOString(),
                    totalStories: generatedStories.length,
                    stories: generatedStories,
                    metadata: {
                        generationSettings: {
                            storyCount: generatedStories.length,
                            storyLength: document.getElementById('storyLength').value,
                            storyStyle: document.getElementById('storyStyle').value,
                            storyTone: document.getElementById('storyTone').value
                        },
                        totalWords: generatedStories.reduce((sum, story) => sum + story.metadata.wordCount, 0),
                        averageWords: Math.round(generatedStories.reduce((sum, story) => sum + story.metadata.wordCount, 0) / generatedStories.length)
                    }
                };
                
                updateProgress(30);
                
                // Check if stories file already exists
                const existingResponse = await gapi.client.drive.files.list({
                    q: `name='${STORIES_CACHE_NAME}' and trashed=false`,
                    fields: 'files(id)'
                });
                
                updateProgress(50);
                
                const storiesContent = JSON.stringify(storiesCollection, null, 2);
                
                if (existingResponse.result.files.length > 0) {
                    // Update existing file
                    const fileId = existingResponse.result.files[0].id;
                    await gapi.client.request({
                        path: `https://www.googleapis.com/upload/drive/v3/files/${fileId}`,
                        method: 'PATCH',
                        params: { uploadType: 'media' },
                        headers: { 'Content-Type': 'application/json' },
                        body: storiesContent
                    });
                } else {
                    // Create new file
                    await gapi.client.request({
                        path: 'https://www.googleapis.com/upload/drive/v3/files',
                        method: 'POST',
                        params: { uploadType: 'multipart' },
                        headers: { 'Content-Type': 'multipart/related; boundary="boundary"' },
                        body: createMultipartBody({
                            name: STORIES_CACHE_NAME,
                            description: 'B·ªô s∆∞u t·∫≠p truy·ªán ƒë∆∞·ª£c t·∫°o t·ª´ AI'
                        }, storiesContent)
                    });
                }
                
                updateProgress(70);
                
                // Also save individual story files
                for (let i = 0; i < generatedStories.length; i++) {
                    const story = generatedStories[i];
                    const fileName = `Truyen_${Date.now()}_${i + 1}_${story.title.replace(/[^a-zA-Z0-9]/g, '_')}.txt`;
                    
                    const storyContent = `${story.title}\n${'='.repeat(50)}\n\n${story.content}\n\n${'='.repeat(50)}\nTh√¥ng tin k·ªπ thu·∫≠t:\n- Phong c√°ch: ${story.metadata.style}\n- ƒê·ªô d√†i: ${story.metadata.length} (${story.metadata.wordCount} t·ª´)\n- T√¥ng ƒëi·ªáu: ${story.metadata.tone}\n- Ch·ªß ƒë·ªÅ: ${story.metadata.theme}\n- Nh√¢n v·∫≠t: ${story.metadata.character}\n- T·∫°o l√∫c: ${new Date(story.metadata.createdAt).toLocaleString('vi-VN')}`;
                    
                    await gapi.client.request({
                        path: 'https://www.googleapis.com/upload/drive/v3/files',
                        method: 'POST',
                        params: { uploadType: 'multipart' },
                        headers: { 'Content-Type': 'multipart/related; boundary="boundary"' },
                        body: createMultipartBody({
                            name: fileName,
                            description: `Truy·ªán ƒë∆∞·ª£c t·∫°o t·ª´ AI - ${story.title}`,
                            parents: await getOrCreateStoriesFolder()
                        }, storyContent)
                    });
                    
                    updateProgress(70 + ((i + 1) / generatedStories.length) * 20);
                }
                
                updateProgress(95);
                updateStatus('ƒê√£ l∆∞u truy·ªán l√™n Google Drive th√†nh c√¥ng');
                showAlert(`ƒê√£ l∆∞u ${generatedStories.length} truy·ªán l√™n Google Drive!`, 'success');
                
                updateProgress(100);
                setTimeout(() => updateProgress(0), 2000);
                
            } catch (error) {
                console.error('Error saving stories:', error);
                updateStatus(`L·ªói khi l∆∞u truy·ªán: ${error.message}`);
                showAlert(`L·ªói khi l∆∞u truy·ªán: ${error.message}`, 'error');
                updateProgress(0);
            }
        }

        async function getOrCreateStoriesFolder() {
            try {
                // First, find the main QuanLyTruyen folder
                const mainFolderResponse = await gapi.client.drive.files.list({
                    q: "name='QuanLyTruyen' and mimeType='application/vnd.google-apps.folder' and trashed=false",
                    fields: 'files(id, name)'
                });
                
                if (mainFolderResponse.result.files.length === 0) {
                    throw new Error('Kh√¥ng t√¨m th·∫•y th∆∞ m·ª•c QuanLyTruyen');
                }
                
                const mainFolderId = mainFolderResponse.result.files[0].id;
                
                // Check if TruyenDuocTao folder exists
                const storiesFolderResponse = await gapi.client.drive.files.list({
                    q: `name='TruyenDuocTao' and mimeType='application/vnd.google-apps.folder' and '${mainFolderId}' in parents and trashed=false`,
                    fields: 'files(id, name)'
                });
                
                if (storiesFolderResponse.result.files.length > 0) {
                    return [storiesFolderResponse.result.files[0].id];
                }
                
                // Create TruyenDuocTao folder
                const createResponse = await gapi.client.drive.files.create({
                    resource: {
                        name: 'TruyenDuocTao',
                        mimeType: 'application/vnd.google-apps.folder',
                        parents: [mainFolderId]
                    }
                });
                
                return [createResponse.result.id];
                
            } catch (error) {
                console.error('Error creating stories folder:', error);
                return [];
            }
        }

        // Utility functions
        function showAlert(message, type = 'info') {
            const alertClass = type === 'error' ? 'alert-error' : 'alert-success';
            const alertDiv = document.createElement('div');
            alertDiv.className = `alert ${alertClass}`;
            alertDiv.textContent = message;
            
            // Insert at the top of the current tab
            const activeTab = document.querySelector('.tab-content.active');
            if (activeTab) {
                activeTab.insertBefore(alertDiv, activeTab.firstChild);
                
                // Remove alert after 5 seconds
                setTimeout(() => {
                    if (alertDiv.parentNode) {
                        alertDiv.parentNode.removeChild(alertDiv);
                    }
                }, 5000);
            }
        }

        function updateStatus(message) {
            document.getElementById('statusInfo').innerHTML = `<p>${message}</p>`;
        }

        function updateProgress(percent) {
            document.getElementById('progressBar').style.width = percent + '%';
        }

        function createMultipartBody(metadata, data) {
            const delimiter = 'boundary';
            let body = '';
            
            body += `--${delimiter}\r\n`;
            body += 'Content-Type: application/json\r\n\r\n';
            body += JSON.stringify(metadata) + '\r\n';
            body += `--${delimiter}\r\n`;
            body += 'Content-Type: text/plain\r\n\r\n';
            body += data + '\r\n';
            body += `--${delimiter}--`;
            
            return body;
        }

        function toggleCollapsible(element) {
            element.classList.toggle('active');
            const content = element.nextElementSibling;
            content.classList.toggle('active');
        }

        // Analysis functions (simplified versions for mobile)
        async function analyzeFiles() {
            if (!window.txtFiles || window.txtFiles.length === 0) {
                showAlert('Vui l√≤ng qu√©t th∆∞ m·ª•c tr∆∞·ªõc khi ph√¢n t√≠ch!', 'error');
                switchTab('scan');
                return;
            }
            
            updateStatus('B·∫Øt ƒë·∫ßu ph√¢n t√≠ch chi ti·∫øt...');
            analysisData = [];
            
            const totalFiles = Math.min(window.txtFiles.length, 20); // Limit for mobile
            
            for (let i = 0; i < totalFiles; i++) {
                const file = window.txtFiles[i];
                updateProgress((i / totalFiles) * 100);
                updateStatus(`ƒêang ph√¢n t√≠ch: ${file.name} (${i+1}/${totalFiles})`);
                
                try {
                    const response = await gapi.client.drive.files.get({
                        fileId: file.id,
                        alt: 'media'
                    });
                    
                    const content = response.body;
                    const analysis = await performBasicAnalysis(content, file.name, file.folderPath);
                    analysisData.push(analysis);
                    
                    await new Promise(resolve => setTimeout(resolve, 100));
                    
                } catch (error) {
                    console.error(`Error analyzing file ${file.name}:`, error);
                    analysisData.push({
                        fileName: file.name,
                        error: error.message
                    });
                }
            }
            
            displayAnalysisResults();
            document.getElementById('generateBtn').disabled = false;
            document.getElementById('saveAnalysisBtn').disabled = false;
            updateProgress(100);
            updateStatus(`Ho√†n th√†nh ph√¢n t√≠ch ${totalFiles} file`);
            
            setTimeout(() => updateProgress(0), 2000);
        }

        async function performBasicAnalysis(content, fileName, folderPath) {
            const words = content.split(/\s+/).filter(w => w.length > 0);
            const sentences = content.split(/[.!?]+/).filter(s => s.trim().length > 0);
            const paragraphs = content.split(/\n\s*\n/).filter(p => p.trim().length > 0);
            
            // Basic theme analysis
            const themes = analyzeBasicThemes(content);
            
            // Basic character analysis
            const characters = analyzeBasicCharacters(content);
            
            // Basic emotion analysis
            const emotions = analyzeBasicEmotions(content);
            
            return {
                fileName: fileName,
                folderPath: folderPath || 'Unknown',
                timestamp: new Date().toLocaleString('vi-VN'),
                basicStats: {
                    wordCount: words.length,
                    sentenceCount: sentences.length,
                    paragraphCount: paragraphs.length,
                    avgWordsPerSentence: Math.round(words.length / sentences.length * 10) / 10
                },
                thematicAnalysis: {
                    mainThemes: themes
                },
                characterAnalysis: {
                    characters: characters
                },
                emotionalAnalysis: {
                    emotionBreakdown: emotions,
                    overallTone: determineBasicTone(emotions)
                },
                contentSample: content.substring(0, 500) + (content.length > 500 ? '...' : '')
            };
        }

        function analyzeBasicThemes(content) {
            const themeKeywords = {
                'T√¨nh y√™u': ['y√™u', 'th∆∞∆°ng', 't√¨nh c·∫£m', 'l√£ng m·∫°n', 'tim'],
                'Gia ƒë√¨nh': ['gia ƒë√¨nh', 'b·ªë', 'm·∫π', 'con', 'anh em'],
                'T√¨nh b·∫°n': ['b·∫°n', 'b·∫°n b√®', 't√¨nh b·∫°n'],
                'Phi√™u l∆∞u': ['phi√™u l∆∞u', 'kh√°m ph√°', 'h√†nh tr√¨nh'],
                'H·ªçc t·∫≠p': ['h·ªçc', 'tr∆∞·ªùng', 'th·∫ßy', 'c√¥', 'b√†i']
            };
            
            const themes = [];
            Object.entries(themeKeywords).forEach(([theme, keywords]) => {
                const mentions = keywords.reduce((count, keyword) => {
                    return count + (content.toLowerCase().match(new RegExp(keyword, 'g')) || []).length;
                }, 0);
                if (mentions > 0) {
                    themes.push({ theme, mentions });
                }
            });
            
            return themes.sort((a, b) => b.mentions - a.mentions).slice(0, 3);
        }

        function analyzeBasicCharacters(content) {
            const namePattern = /\b[A-Z√Ä-·ª∏][a-z√†-·ªπ]{2,15}\b/g;
            const potentialNames = content.match(namePattern) || [];
            
            const nameCounts = {};
            potentialNames.forEach(name => {
                if (name.length > 2 && name.length < 20) {
                    nameCounts[name] = (nameCounts[name] || 0) + 1;
                }
            });
            
            return Object.entries(nameCounts)
                .filter(([name, count]) => count >= 2)
                .sort(([,a], [,b]) => b - a)
                .slice(0, 5)
                .map(([name, appearances]) => ({
                    name,
                    appearances,
                    importance: appearances > 5 ? 'Ch√≠nh' : 'Ph·ª•'
                }));
        }

        function analyzeBasicEmotions(content) {
            const emotions = { positive: 0, negative: 0, neutral: 0 };
            
            Object.entries(emotionalWords).forEach(([category, words]) => {
                const mentions = words.reduce((count, word) => {
                    return count + (content.toLowerCase().match(new RegExp(word, 'g')) || []).length;
                }, 0);
                emotions[category] = { count: mentions };
            });
            
            return emotions;
        }

        function determineBasicTone(emotions) {
            const positive = emotions.positive?.count || 0;
            const negative = emotions.negative?.count || 0;
            
            if (positive > negative) return 'T√≠ch c·ª±c';
            if (negative > positive) return 'Ti√™u c·ª±c';
            return 'Trung t√≠nh';
        }

        function displayAnalysisResults() {
            const container = document.getElementById('analysisResults');
            container.innerHTML = '';
            
            if (analysisData.length === 0) {
                container.innerHTML = '<p>Ch∆∞a c√≥ d·ªØ li·ªáu ph√¢n t√≠ch.</p>';
                return;
            }
            
            // Summary
            const totalWords = analysisData.reduce((sum, analysis) => 
                sum + (analysis.basicStats?.wordCount || 0), 0);
            
            const summaryCard = document.createElement('div');
            summaryCard.className = 'card';
            summaryCard.innerHTML = `
                <h3>T·ªïng quan ph√¢n t√≠ch</h3>
                <div class="stats-summary">
                    <div class="stat-card">
                        <div class="stat-number">${analysisData.filter(a => !a.error).length}</div>
                        <div class="stat-label">File ph√¢n t√≠ch</div>
                    </div>
                    <div class="stat-card">
                        <div class="stat-number">${totalWords.toLocaleString()}</div>
                        <div class="stat-label">T·ªïng t·ª´</div>
                    </div>
                </div>
            `;
            container.appendChild(summaryCard);
            
            // Individual files
            analysisData.forEach(analysis => {
                if (analysis.error) return;
                
                const fileCard = document.createElement('div');
                fileCard.className = 'file-card';
                
                fileCard.innerHTML = `
                    <div class="file-header">
                        <span class="file-name">${analysis.fileName}</span>
                        <small>${analysis.folderPath} | ${analysis.timestamp}</small>
                    </div>
                    
                    <button class="collapsible" onclick="toggleCollapsible(this)">
                        Th·ªëng k√™ c∆° b·∫£n
                    </button>
                    <div class="collapsible-content">
                        <div class="analysis-grid">
                            <div class="analysis-item">
                                <h5>S·ªë t·ª´</h5>
                                <p>${analysis.basicStats.wordCount}</p>
                            </div>
                            <div class="analysis-item">
                                <h5>S·ªë c√¢u</h5>
                                <p>${analysis.basicStats.sentenceCount}</p>
                            </div>
                            <div class="analysis-item">
                                <h5>T√¥ng ƒëi·ªáu</h5>
                                <p>${analysis.emotionalAnalysis.overallTone}</p>
                            </div>
                        </div>
                    </div>
                    
                    <button class="collapsible" onclick="toggleCollapsible(this)">
                        Ch·ªß ƒë·ªÅ & Nh√¢n v·∫≠t
                    </button>
                    <div class="collapsible-content">
                        ${analysis.thematicAnalysis.mainThemes.length > 0 ? `
                            <h5>Ch·ªß ƒë·ªÅ ch√≠nh:</h5>
                            <div class="word-cloud">
                                ${analysis.thematicAnalysis.mainThemes.map(theme => 
                                    `<span class="word-item">${theme.theme} (${theme.mentions})</span>`
                                ).join('')}
                            </div>
                        ` : ''}
                        
                        ${analysis.characterAnalysis.characters.length > 0 ? `
                            <h5>Nh√¢n v·∫≠t:</h5>
                            <div class="word-cloud">
                                ${analysis.characterAnalysis.characters.map(char => 
                                    `<span class="word-item">${char.name} (${char.appearances})</span>`
                                ).join('')}
                            </div>
                        ` : ''}
                    </div>
                    
                    <button class="collapsible" onclick="toggleCollapsible(this)">
                        N·ªôi dung m·∫´u
                    </button>
                    <div class="collapsible-content">
                        <div class="story-output">${analysis.contentSample}</div>
                    </div>
                `;
                
                container.appendChild(fileCard);
            });
            
            switchTab('results');
        }

        // Scanning functions
        async function scanFolder() {
            updateProgress(5);
            updateStatus('Ki·ªÉm tra cache qu√©t tr∆∞·ªõc ƒë√≥...');
            
            try {
                const cacheExists = await checkCacheExists();
                if (cacheExists) {
                    const useCache = confirm('ƒê√£ t√¨m th·∫•y k·∫øt qu·∫£ qu√©t tr∆∞·ªõc ƒë√≥. S·ª≠ d·ª•ng cache?');
                    if (useCache) {
                        await loadFromCache();
                        return;
                    }
                }
                
                updateProgress(10);
                updateStatus('ƒêang qu√©t th∆∞ m·ª•c QuanLyTruyen...');
                
                const folderResponse = await gapi.client.drive.files.list({
                    q: "name='QuanLyTruyen' and mimeType='application/vnd.google-apps.folder'",
                    fields: 'files(id, name)'
                });
                
                if (folderResponse.result.files.length === 0) {
                    throw new Error('Kh√¥ng t√¨m th·∫•y th∆∞ m·ª•c QuanLyTruyen');
                }
                
                const folderId = folderResponse.result.files[0].id;
                updateProgress(20);
                
                const allTxtFiles = await scanFolderRecursive(folderId);
                
                updateProgress(80);
                updateStatus(`T√¨m th·∫•y ${allTxtFiles.length} file txt`);
                
                window.txtFiles = allTxtFiles;
                scanCache = {
                    timestamp: new Date().toISOString(),
                    totalFiles: allTxtFiles.length,
                    files: allTxtFiles
                };
                
                await saveCacheToGoogleDrive();
                
                document.getElementById('analyzeBtn').disabled = false;
                updateProgress(100);
                
                displayScanResults(allTxtFiles);
                setTimeout(() => updateProgress(0), 2000);
                
            } catch (error) {
                console.error('Error scanning folder:', error);
                updateStatus(`L·ªói: ${error.message}`);
                updateProgress(0);
            }
        }

        async function scanFolderRecursive(folderId, depth = 0, maxDepth = 5) {
            if (depth > maxDepth) return [];
            
            let allFiles = [];
            let nextPageToken = null;
            
            do {
                const response = await gapi.client.drive.files.list({
                    q: `'${folderId}' in parents and trashed=false`,
                    fields: 'nextPageToken, files(id, name, parents, mimeType, size, modifiedTime)',
                    pageSize: 100,
                    pageToken: nextPageToken
                });
                
                const items = response.result.files;
                nextPageToken = response.result.nextPageToken;
                
                for (const item of items) {
                    if (item.mimeType === 'text/plain' && item.name.endsWith('.txt')) {
                        const folderPath = await getFolderPath(item.parents[0]);
                        allFiles.push({ ...item, folderPath });
                        
                        if (allFiles.length >= 50) break; // Mobile limit
                    } else if (item.mimeType === 'application/vnd.google-apps.folder') {
                        updateStatus(`ƒêang qu√©t: ${item.name}`);
                        const subFiles = await scanFolderRecursive(item.id, depth + 1, maxDepth);
                        allFiles = allFiles.concat(subFiles);
                        
                        if (allFiles.length >= 50) break;
                    }
                }
                
            } while (nextPageToken && allFiles.length < 50);
            
            return allFiles;
        }

        async function getFolderPath(folderId) {
            try {
                const response = await gapi.client.drive.files.get({
                    fileId: folderId,
                    fields: 'name, parents'
                });
                
                const folder = response.result;
                if (!folder.parents || folder.name === 'QuanLyTruyen') {
                    return folder.name;
                }
                
                const parentPath = await getFolderPath(folder.parents[0]);
                return `${parentPath}/${folder.name}`;
            } catch (error) {
                return 'Unknown';
            }
        }

        function displayScanResults(files) {
            const container = document.getElementById('analysisResults');
            
            const filesByFolder = {};
            files.forEach(file => {
                const folder = file.folderPath || 'Unknown';
                if (!filesByFolder[folder]) {
                    filesByFolder[folder] = [];
                }
                filesByFolder[folder].push(file);
            });
            
            let html = `
                <div class="card">
                    <h3>K·∫øt qu·∫£ qu√©t th∆∞ m·ª•c</h3>
                    <p>T·ªïng c·ªông: ${files.length} file txt</p>
                    
                    <h4>Ph√¢n b·ªë theo th∆∞ m·ª•c:</h4>
            `;
            
            Object.entries(filesByFolder).forEach(([folder, folderFiles]) => {
                html += `
                    <div style="margin: 10px 0; padding: 10px; background: #f8f9fa; border-radius: 5px;">
                        <strong>${folder}</strong> (${folderFiles.length} file)
                    </div>
                `;
            });
            
            html += `</div>`;
            container.innerHTML = html;
        }

        // Cache functions
        async function checkCacheExists() {
            try {
                const response = await gapi.client.drive.files.list({
                    q: `name='${CACHE_FILE_NAME}' and trashed=false`,
                    fields: 'files(id)'
                });
                return response.result.files.length > 0;
            } catch (error) {
                return false;
            }
        }

        async function loadFromCache() {
            updateProgress(20);
            updateStatus('ƒêang t·∫£i cache...');
            
            try {
                const response = await gapi.client.drive.files.list({
                    q: `name='${CACHE_FILE_NAME}' and trashed=false`,
                    fields: 'files(id, modifiedTime)'
                });
                
                const cacheFile = response.result.files[0];
                updateProgress(50);
                
                const cacheResponse = await gapi.client.drive.files.get({
                    fileId: cacheFile.id,
                    alt: 'media'
                });
                
                const cacheData = JSON.parse(cacheResponse.body);
                scanCache = cacheData;
                window.txtFiles = cacheData.files;
                
                updateProgress(90);
                updateStatus(`ƒê√£ t·∫£i cache: ${cacheData.totalFiles} file`);
                
                document.getElementById('analyzeBtn').disabled = false;
                displayScanResults(cacheData.files);
                updateProgress(100);
                
                setTimeout(() => updateProgress(0), 2000);
                
            } catch (error) {
                console.error('Error loading cache:', error);
                await scanFolder();
            }
        }

        async function saveCacheToGoogleDrive() {
            try {
                const existingResponse = await gapi.client.drive.files.list({
                    q: `name='${CACHE_FILE_NAME}' and trashed=false`,
                    fields: 'files(id)'
                });
                
                const cacheContent = JSON.stringify(scanCache, null, 2);
                
                if (existingResponse.result.files.length > 0) {
                    const fileId = existingResponse.result.files[0].id;
                    await gapi.client.request({
                        path: `https://www.googleapis.com/upload/drive/v3/files/${fileId}`,
                        method: 'PATCH',
                        params: { uploadType: 'media' },
                        headers: { 'Content-Type': 'application/json' },
                        body: cacheContent
                    });
                } else {
                    await gapi.client.request({
                        path: 'https://www.googleapis.com/upload/drive/v3/files',
                        method: 'POST',
                        params: { uploadType: 'multipart' },
                        headers: { 'Content-Type': 'multipart/related; boundary="boundary"' },
                        body: createMultipartBody({
                            name: CACHE_FILE_NAME,
                            description: 'Cache file for QuanLyTruyen scanner'
                        }, cacheContent)
                    });
                }
            } catch (error) {
                console.error('Error saving cache:', error);
            }
        }

        async function clearCache() {
            if (!confirm('B·∫°n c√≥ ch·∫Øc ch·∫Øn mu·ªën x√≥a cache?')) return;
            
            try {
                const response = await gapi.client.drive.files.list({
                    q: `name='${CACHE_FILE_NAME}' and trashed=false`,
                    fields: 'files(id)'
                });
                
                if (response.result.files.length > 0) {
                    await gapi.client.drive.files.delete({
                        fileId: response.result.files[0].id
                    });
                }
                
                scanCache = {};
                window.txtFiles = [];
                updateStatus('ƒê√£ x√≥a cache');
                
            } catch (error) {
                console.error('Error clearing cache:', error);
            }
        }

        // Save/Load Analysis
        async function saveAnalysisResults() {
            if (analysisData.length === 0) {
                showAlert('Kh√¥ng c√≥ d·ªØ li·ªáu ƒë·ªÉ l∆∞u!', 'error');
                return;
            }
            
            try {
                const analysisReport = {
                    timestamp: new Date().toISOString(),
                    totalFiles: analysisData.length,
                    analysisData: analysisData
                };
                
                const analysisContent = JSON.stringify(analysisReport, null, 2);
                
                await gapi.client.request({
                    path: 'https://www.googleapis.com/upload/drive/v3/files',
                    method: 'POST',
                    params: { uploadType: 'multipart' },
                    headers: { 'Content-Type': 'multipart/related; boundary="boundary"' },
                    body: createMultipartBody({
                        name: ANALYSIS_CACHE_NAME,
                        description: 'K·∫øt qu·∫£ ph√¢n t√≠ch truy·ªán'
                    }, analysisContent)
                });
                
                showAlert('ƒê√£ l∆∞u k·∫øt qu·∫£ ph√¢n t√≠ch!', 'success');
                
            } catch (error) {
                console.error('Error saving analysis:', error);
                showAlert(`L·ªói khi l∆∞u: ${error.message}`, 'error');
            }
        }

        async function loadAnalysisResults() {
            try {
                const response = await gapi.client.drive.files.list({
                    q: `name='${ANALYSIS_CACHE_NAME}' and trashed=false`,
                    fields: 'files(id, modifiedTime)'
                });
                
                if (response.result.files.length === 0) {
                    showAlert('Kh√¥ng t√¨m th·∫•y k·∫øt qu·∫£ ph√¢n t√≠ch ƒë√£ l∆∞u', 'error');
                    return;
                }
                
                const analysisFile = response.result.files[0];
                
                const analysisResponse = await gapi.client.drive.files.get({
                    fileId: analysisFile.id,
                    alt: 'media'
                });
                
                const analysisReport = JSON.parse(analysisResponse.body);
                analysisData = analysisReport.analysisData;
                
                displayAnalysisResults();
                document.getElementById('generateBtn').disabled = false;
                document.getElementById('saveAnalysisBtn').disabled = false;
                
                showAlert(`ƒê√£ t·∫£i ${analysisReport.totalFiles} file ph√¢n t√≠ch!`, 'success');
                
            } catch (error) {
                console.error('Error loading analysis:', error);
                showAlert(`L·ªói khi t·∫£i: ${error.message}`, 'error');
            }
        }

        // Initialize
        window.onload = function() {
            if (typeof gapi !== 'undefined') {
                gapiLoaded();
            }
            if (typeof google !== 'undefined') {
                gisLoaded();
            }
            
            updateStatus('Ch∆∞a k·∫øt n·ªëi Google Drive');
        };

        // Make functions globally accessible
        window.toggleCollapsible = toggleCollapsible;
        window.switchTab = switchTab;
        window.handleAuthClick = handleAuthClick;
        window.handleSignoutClick = handleSignoutClick;
        window.scanFolder = scanFolder;
        window.clearCache = clearCache;
        window.loadAnalysisResults = loadAnalysisResults;
        window.analyzeFiles = analyzeFiles;
        window.saveAnalysisResults = saveAnalysisResults;
        window.generateStories = generateStories;
        window.saveToGoogleDrive = saveToGoogleDrive;
    </script>
</body>
</html>
