<!DOCTYPE html>
<html lang="vi">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, viewport-fit=cover">
    <title>Trình Phân Tích & Tạo Truyện Nâng Cao</title>
    <script src="https://apis.google.com/js/api.js"></script>
    <script src="https://accounts.google.com/gsi/client"></script>
    <style>
        :root {
           --primary-color: #9b59b6;
    --secondary-color: #2980b9;
    --dark-color: #1e1e1e;
    --light-color: #bdc3c7;
    --accent-color: #e74c3c;
    --success-color: #2ecc71;
    --warning-color: #f39c12;
    --text-color: #ecf0f1;
    --card-bg: rgba(30, 30, 30, 0.95);
    --border-radius: 16px;
    --shadow: 0 4px 20px rgba(0, 0, 0, 0.6);
            --safe-area-inset-top: env(safe-area-inset-top);
            --safe-area-inset-bottom: env(safe-area-inset-bottom);
            --safe-area-inset-left: env(safe-area-inset-left);
            --safe-area-inset-right: env(safe-area-inset-right);
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            -webkit-tap-highlight-color: transparent;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Helvetica, Arial, sans-serif;
    background: #121212;   /* nền đen thuần */
    min-height: 100vh;
    color: var(--text-color);
    padding: var(--safe-area-inset-top) var(--safe-area-inset-right) var(--safe-area-inset-bottom) var(--safe-area-inset-left);
    line-height: 1.6;
        }

        .container {
            max-width: 100%;
            margin: 0 auto;
            padding: 16px;
            padding-bottom: 80px;
        }

        .header {
            text-align: center;
            margin-bottom: 20px;
            color: white;
            padding-top: 12px;
        }

        .header h1 {
            font-size: 1.8rem;
            margin-bottom: 8px;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.3);
            font-weight: 700;
        }

        .header p {
            font-size: 1rem;
            opacity: 0.9;
            font-weight: 400;
        }

        .card {
            background: var(--card-bg);
            border-radius: var(--border-radius);
            padding: 20px;
            margin-bottom: 20px;
            box-shadow: var(--shadow);
            backdrop-filter: blur(10px);
        }

        .bottom-menu {
            position: fixed;
            bottom: 0;
            left: 0;
            right: 0;
            background: rgba(44, 62, 80, 0.95);
            backdrop-filter: blur(10px);
            padding: 12px 16px;
            padding-bottom: calc(16px + var(--safe-area-inset-bottom));
            display: flex;
            justify-content: space-around;
            border-top: 1px solid rgba(255, 255, 255, 0.1);
            z-index: 1000;
        }

        .menu-item {
            display: flex;
            flex-direction: column;
            align-items: center;
            color: var(--light-color);
            text-decoration: none;
            font-size: 0.8rem;
            opacity: 0.7;
            transition: opacity 0.3s;
        }

        .menu-item.active {
            opacity: 1;
        }

        .menu-icon {
            font-size: 1.4rem;
            margin-bottom: 4px;
        }

        .tab-content {
            display: none;
        }

        .tab-content.active {
            display: block;
        }

        .btn {
            background: var(--primary-color);
            color: white;
            border: none;
            padding: 14px 20px;
            border-radius: 50px;
            font-size: 1rem;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
            box-shadow: 0 4px 12px rgba(0,0,0,0.15);
            margin: 6px 0;
            width: 100%;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
        }

        .btn-secondary {
            background: var(--secondary-color);
        }

        .btn-danger {
            background: var(--accent-color);
        }

        .btn-success {
            background: var(--success-color);
        }

        .btn-warning {
            background: var(--warning-color);
        }

        .btn:disabled {
            background: #95a5a6;
            cursor: not-allowed;
            transform: none;
            box-shadow: none;
        }

        .story-content {
            background: #1e1e1e;
            border-radius: 12px;
            padding: 16px;
            margin: 12px 0;
            border-left: 4px solid var(--primary-color);
            font-family: 'Times New Roman', serif;
            line-height: 1.8;
            max-height: 50vh;
            overflow-y: auto;
        }

        .chapter-title {
            color: var(--primary-color);
            font-size: 1.2rem;
            margin-bottom: 10px;
            font-weight: bold;
        }

        .progress-container {
            margin: 15px 0;
        }

        .progress-bar {
            width: 100%;
            height: 20px;
            background: #e9ecef;
            border-radius: 10px;
            overflow: hidden;
        }

        .progress-fill {
            height: 100%;
            background: linear-gradient(to right, #8e44ad, #3498db);
            width: 0%;
            transition: width 0.5s ease;
            border-radius: 10px;
        }

        .status-info {
            padding: 10px;
            border-radius: 8px;
            margin: 10px 0;
            background: rgba(255, 255, 255, 0.2);
            color: white;
        }

        .detailed-status {
            font-size: 0.9rem;
            color: #ecf0f1;
            margin-top: 5px;
        }

        .toggle-container {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin: 12px 0;
        }

        .toggle-switch {
            position: relative;
            display: inline-block;
            width: 50px;
            height: 24px;
        }

        .toggle-switch input {
            opacity: 0;
            width: 0;
            height: 0;
        }

        .slider {
            position: absolute;
            cursor: pointer;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-color: #ccc;
            transition: .4s;
            border-radius: 24px;
        }

        .slider:before {
            position: absolute;
            content: "";
            height: 18px;
            width: 18px;
            left: 3px;
            bottom: 3px;
            background-color: white;
            transition: .4s;
            border-radius: 50%;
        }

        input:checked + .slider {
            background-color: var(--primary-color);
        }

        input:checked + .slider:before {
            transform: translateX(26px);
        }

        .character-profile {
            display: flex;
            align-items: center;
            margin: 15px 0;
            padding: 10px;
            background: rgba(236, 240, 241, 0.3);
            border-radius: 10px;
        }

        .character-avatar {
            width: 50px;
            height: 50px;
            border-radius: 50%;
            background: var(--primary-color);
            display: flex;
            align-items: center;
            justify-content: center;
            color: white;
            font-size: 1.5rem;
            margin-right: 15px;
        }

        .character-details {
            flex: 1;
        }

        .character-name {
            font-weight: bold;
            color: var(--dark-color);
        }

        .character-desc {
            font-size: 0.9rem;
            color: #7f8c8d;
        }

        .emotion-tag {
            display: inline-block;
            padding: 4px 10px;
            border-radius: 15px;
            font-size: 0.8rem;
            margin: 3px;
            background: #e74c3c;
            color: white;
        }

        .emotion-buon {
            background: #3498db;
        }

        .emotion-dau {
            background: #e74c3c;
        }

        .emotion-bat-luc {
            background: #95a5a6;
        }

        .sensitive-word {
            background: #e74c3c;
            color: white;
            padding: 2px 4px;
            border-radius: 4px;
            font-size: 0.9em;
        }

        .dialogue {
            font-style: italic;
            color: #2c3e50;
            margin: 5px 0;
            padding-left: 15px;
            border-left: 3px solid #3498db;
        }

        .analysis-result-item {
            margin: 10px 0;
            padding: 10px;
            background: #2c2c2c;
            border-radius: 8px;
        }

        .loading {
            display: inline-block;
            width: 18px;
            height: 18px;
            border: 2px solid #f3f3f3;
            border-top: 2px solid var(--primary-color);
            border-radius: 50%;
            animation: spin 1s linear infinite;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        @media only screen and (device-width: 375px) and (device-height: 812px) and (-webkit-device-pixel-ratio: 3) {
            .container {
                padding: 12px;
                padding-bottom: 80px;
            }
            
            .header h1 {
                font-size: 1.6rem;
            }
            
            .card {
                padding: 16px;
            }
            
            .btn {
                padding: 12px 16px;
                font-size: 0.9rem;
            }
            
            .story-content {
                font-size: 0.95rem;
                max-height: 45vh;
            }
        }
        
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>📖 Trình Phân Tích & Tạo Truyện</h1>
            <p>Phân tích nâng cao và tạo truyện tự động</p>
        </div>

        <div id="tab-analysis" class="tab-content active">
            <div class="card">
                <h3>🔍 Phân tích nguồn truyện</h3>
                <p>Phân tích các file văn bản để tạo dữ liệu cho truyện</p>
                
                <div class="status-info" id="statusInfo">
                    <p>🔴 Chưa kết nối Google Drive</p>
                    <div class="detailed-status" id="detailedStatus"></div>
                </div>
                <div id="detailedStatus" style="margin-top:10px; color:#555; font-size:14px;"></div>
                <div class="progress-container">
                    <div class="progress-bar">
                        <div class="progress-fill" id="progressBar"></div>
                    </div>
                </div>
                
                <button class="btn" onclick="handleAuthClick()">
                    📁 Kết nối Google Drive
                </button>
                
                <button class="btn btn-secondary" id="scanBtn" onclick="scanFolder()" disabled>
                    🔍 Quét thư mục
                </button>
                
                <button class="btn btn-warning" id="analyzeBtn" onclick="analyzeFiles()" disabled>
                    🧠 Phân tích nâng cao
                </button>
                
                <button class="btn btn-success" id="downloadAnalysisBtn" onclick="downloadAnalysis()" disabled>
                    📥 Tải phân tích xuống
                </button>
                
                <div class="toggle-container">
                    <span>Bỏ qua file đã phân tích</span>
                    <label class="toggle-switch">
                        <input type="checkbox" id="skipAnalyzedFiles" checked>
                        <span class="slider"></span>
                    </label>
                </div>
            </div>
            
            <div class="card">
                <button class="btn btn-secondary" id="downloadScanCacheBtn" onclick="downloadScanCache()" disabled>
    📥 Tải danh sách đã quét
</button>
                <h3>📊 Kết quả phân tích</h3>
                <div id="analysisResults">
                    <p>Chưa có dữ liệu phân tích. Vui lòng quét và phân tích thư mục trước.</p>
                </div>
            </div>
        </div>

        <div id="tab-write" class="tab-content">
            <div class="card">
                <h3>✍️ Viết truyện</h3>
                <p>Tạo truyện mới dựa trên dữ liệu đã phân tích</p>
                
                <div class="character-profile">
                    <div class="character-avatar">👨</div>
                    <div class="character-details">
                        <div class="character-name">Người kể chuyện</div>
                        <div class="character-desc">Tạo truyện từ dữ liệu đã phân tích</div>
                    </div>
                </div>
                
                <div class="toggle-container">
                    <span>Số chương (50+):</span>
                    <input type="number" id="minChapters" value="50" min="50" max="100" style="width: 60px; padding: 5px; border-radius: 5px; border: 1px solid #ddd;">
                </div>

                <div class="toggle-container">
                    <span>Độ nhạy cảm:</span>
                    <input type="range" id="sensitivityLevel" min="1" max="10" value="5" style="width: 120px;">
                    <span id="sensitivityValue">5</span>
                </div>
                
                <button class="btn btn-success" id="generateBtn" onclick="generateStories()" disabled>
                    ✍️ Bắt đầu viết truyện
                </button>
                
                <div class="progress-container">
                    <div class="progress-bar">
                        <div class="progress-fill" id="writeProgressBar"></div>
                    </div>
                </div>
                
                <div class="status-info">
                    <p id="writeStatus">Chưa bắt đầu viết truyện</p>
                    <div class="detailed-status" id="writeDetailedStatus"></div>
                </div>
            </div>
            
            <div class="card">
                <h3>📖 Truyện đang viết</h3>
                <div id="generatedStories">
                    <p>Chưa có truyện nào được tạo. Hãy bấm "Bắt đầu viết truyện" để bắt đầu.</p>
                </div>
            </div>
        </div>

        <div id="tab-stories" class="tab-content">
            <div class="card">
                <h3>📚 Thư viện truyện</h3>
                <p>Những truyện đã được tạo và lưu trữ</p>
                
                <div id="storiesLibrary">
                    <p>Chưa có truyện nào trong thư viện.</p>
                    <div id="readerContainer" style="display:none; margin-top:20px;">
    <h3 id="readerTitle">📖 Đang đọc truyện</h3>
    <div id="readerContent" class="story-content"></div>
    <div style="margin-top:10px; display:flex; justify-content:space-between;">
        <button class="btn btn-secondary" onclick="prevChapter()">⬅️ Chương trước</button>
        <button class="btn btn-secondary" onclick="nextChapter()">Chương tiếp ➡️</button>
    </div>
                </div>
                
                <button class="btn btn-secondary" id="loadStoriesBtn" onclick="loadStories()">
                    🔄 Tải danh sách truyện
                </button>
            </div>
        </div>

        <div id="tab-settings" class="tab-content">
            <div class="card">
                <h3>⚙️ Cài đặt</h3>
                
                <div class="toggle-container">
                    <span>Tự động lưu tiến độ</span>
                    <label class="toggle-switch">
                        <input type="checkbox" id="autoSaveResults" checked>
                        <span class="slider"></span>
                    </label>
                </div>
                
                <div class="toggle-container">
                    <span>Gửi dữ liệu cải thiện AI</span>
                    <label class="toggle-switch">
                        <input type="checkbox" id="sendImprovementData" checked>
                        <span class="slider"></span>
                    </label>
                </div>
                
                <button class="btn" onclick="clearCache()">
                    🗑️ Xóa dữ liệu tạm
                </button>
                
                <button class="btn btn-danger" onclick="handleSignoutClick()">
                    🚪 Đăng xuất
                </button>
            </div>
            
            <div class="card">
                <h3>ℹ️ Thông tin ứng dụng</h3>
                <p>Phiên bản: 2.1.0</p>
                <p>Phân tích nâng cao: Hội thoại & Từ nhạy cảm</p>
                <p>Góc nhìn: Linh hoạt theo phân tích</p>
            </div>
        </div>
    </div>

    <div class="bottom-menu">
        <a href="#" class="menu-item active" onclick="switchTab('tab-analysis')">
            <div class="menu-icon">🔍</div>
            <span>Phân tích</span>
        </a>
        <a href="#" class="menu-item" onclick="switchTab('tab-write')">
            <div class="menu-icon">✍️</div>
            <span>Viết truyện</span>
        </a>
        <a href="#" class="menu-item" onclick="switchTab('tab-stories')">
            <div class="menu-icon">📚</div>
            <span>Thư viện</span>
        </a>
        <a href="#" class="menu-item" onclick="switchTab('tab-settings')">
            <div class="menu-icon">⚙️</div>
            <span>Cài đặt</span>
        </a>
    </div>

    <script>
        // Google API Configuration
        const CLIENT_ID = '398509518475-7bjid324tkuuh9gv8b0g92lhsgv8nrl5.apps.googleusercontent.com';
        const API_KEY = 'AIzaSyAbcWr0UPvC4YpsunE6uAa7E5pan9iys2o';
        const DISCOVERY_DOC = 'https://www.googleapis.com/discovery/v1/apis/drive/v3/rest';
        const SCOPES = 'https://www.googleapis.com/auth/drive';

        let tokenClient;
        let gapi_inited = false;
        let gsi_inited = false;

        // Global variables
        let analysisData = [];
        let generatedStories = [];
        let scanCache = {};
        const CACHE_FILE_NAME = 'ScanCache_QuanLyTruyen.json';
        const ANALYSIS_CACHE_NAME = 'AnalysisResults_QuanLyTruyen.json';
        const STORY_CACHE_NAME = 'GeneratedStories_QuanLyTruyen.json';

        // Vietnamese language processing data - Mở rộng cho phân tích nâng cao
        const vietnameseStopWords = [
            'là', 'của', 'và', 'có', 'một', 'được', 'trong', 'không', 'với', 'từ', 'để', 'đã', 'sẽ',
            'về', 'cho', 'theo', 'như', 'khi', 'vào', 'ra', 'lên', 'xuống', 'qua', 'tại', 'hay',
            'rằng', 'nếu', 'mà', 'thì', 'hoặc', 'nhưng', 'vì', 'nên', 'đến', 'bằng', 'trên', 'dưới'
        ];

        // Từ nhạy cảm cho phân tích nâng cao
        const sensitiveWords = {
            romantic: ['yêu', 'thương', 'hôn', 'ôm', 'ấp ôm', 'âm áp', 'say đắm', 'đam mê', 'dịu dàng', 'ngọt ngào', 'quyến rũ', 'mê hoặc', 'thân mật', 'gần gũi'],
            sexual: [
                'gối chăn', 'phòng the', 'ân ái', 'làm tình', 'quan hệ', 'tình dục',
                'dâm', 'dục', 'khoái cảm', 'kích thích', 'khoả thân', 'lõa thể',
                'sướng', 'rên rỉ', 'nứng', 'ướt át', 'cao trào', 'cực khoái', 'xuất tinh',
                'dương vật', 'cặc', 'buồi', 'chim', 'cái ấy',
                'âm đạo', 'lồn', 'bướm', 'âm hộ', 'hột le', 'mu', 'lỗ', 'xoạc',
                'bú vú', 'vú to', 'vú căng', 'bú mút', 'ngực trần', 'ngực khủng', 'đầu ti',
                'bú lồn', 'bú cặc', 'liếm lồn', 'liếm bi', 'nuốt tinh', 'bú hột le', 'bú đầu cặc',
                'tử cung', 'bắn vào tử cung', 'cặc dài 20cm', 'ngậm tinh', 'chịch', 'địt', 'nắc',
                'thổi kèn', 'bj', 'hj', 'anal', 'doggy', '69', 'threesome', 'thủ dâm',
                'chơi gái', 'đĩ', 'gái mại dâm', 'mông to', 'thụt ra thụt vào', 'cắm sâu',
                'sờ soạng', 'mút', 'cắn', 'xoa', 'vuốt ve', 'húp sò', 'phê', 'nghiện sex',
                'xoạc lồn', 'xoạc cặc', 'tra tấn tình dục', 'hành xác', 'chịu trận',
                'nhét', 'đút', 'làm nhục', 'bóp vú', 'tét đít', 'vỗ mông', 'túm tóc',
                'bạo dâm', 'cưỡng hiếp', 'hiếp dâm', 'loạn luân', 'thằng cha', 'ông già dâm đãng',
                'con đĩ', 'con cave', 'chị dâu', 'em dâu', 'anh rể', 'chị gái', 'mẹ chồng', 'cha con', 'mẹ con',
                'rên la', 'rên rỉ', 'hét lên vì sướng', 'mắt lờ đờ', 'mồ hôi nhễ nhại',
                'bắn tinh', 'phun tinh', 'tinh dịch', 'tinh tràn', 'nuốt sạch tinh',
                'mùi tanh', 'vị mặn', 'ướt đẫm', 'nước nhờn', 'dịch nhờn',
                 // ===== Hành động & tình dục =====
        'làm tình', 'quan hệ', 'ân ái', 'thủ dâm', 'kích thích',
        'cởi đồ', 'vuốt ve', 'sờ mó', 'ôm hôn', 'thâm nhập',
        'rên rỉ', 'xuất tinh', 'cao trào', 'cực khoái', 'ướt át',

        // ===== Lời thoại tình dục chung =====
        '"muốn anh"', '"muốn em"', '"làm em sướng"', '"cứng quá"',
        '"em ướt rồi"', '"mạnh lên"', '"ra đi"', '"bắn vào trong"',

        // ===== Quan hệ gia đình nhạy cảm =====
        'bố chồng', 'con dâu', 'cha chồng', 'nàng dâu',
        '"bố chồng"', '"con dâu"', '"cha chồng"', '"nàng dâu"',
        '"bố chồng ơi"', '"con dâu ngoan"', '"bố chồng làm cho con"',
        '"con dâu của bố"', '"bố muốn con"', '"bố chồng không chịu nổi"',
        '"con dâu sướng quá"', '"làm dâu bố"', '"bố chồng yêu con dâu"',
        
        // ===== Các tình huống thoại đặc thù =====
        'quan hệ với bố chồng', 'quan hệ cùng con dâu', 
        'chịch con dâu', 'bố chồng đụ con dâu', 'bố chồng hiếp con dâu',
        'làm tình với con dâu', 'bố chồng ôm con dâu',
        'con dâu rên', 'bố chồng thỏa mãn', 'bố chồng cưỡng hiếp'
            ],
            negative: ['ghét', 'hận', 'giận', 'tức', 'tủi', 'buồn', 'đau', 'khổ', 'sầu', 'thảm', 'bi', 'tang', 'tử', 'chết', 'giết', 'hại', 'ác', 'dữ', 'hung'],
            family: ['bố', 'mẹ', 'cha', 'con', 'chồng', 'vợ', 'dâu', 'rể', 'anh', 'chị', 'em', 'ông', 'bà', 'chú', 'bác', 'cô', 'dì', 'cậu', 'mợ'],
            secret: ['bí mật', 'giấu giếm', 'che giấu', 'giấu diếm', 'lén lút', 'vụng trộm', 'âm thầm', 'lặng lẽ', 'kín đáo', 'riêng tư']
        };

        const emotionalWords = {
            positive: ['vui', 'hạnh phúc', 'yêu', 'thương', 'tuyệt vời', 'đẹp', 'tốt', 'xuất sắc', 'thành công', 'hy vọng'],
            negative: ['buồn', 'đau', 'khổ', 'tệ', 'xấu', 'thất bại', 'tuyệt vọng', 'ghét', 'tức giận', 'lo lắng', 'sợ hãi', 'khóc', 'tang thương', 'bất hạnh', 'dối trá', 'phản bội', 'lừa dối', 'xót xa', 'đau đớn', 'xấu hổ', 'tủi nhục'],
            neutral: ['bình thường', 'thông thường', 'trung bình', 'ổn', 'được', 'tạm ổn']
        };

        // Từ khóa đặc biệt cho phân tích hội thoại
        const dialogueIndicators = ['nói', 'bảo', 'hỏi', 'đáp', 'thưa', 'kêu', 'gọi', 'hét', 'la', 'thét', 'thì thầm', 'rủ rỉ', 'lên tiếng', 'phát biểu', 'trả lời', 'hỏi lại', 'đáp lại'];
        const dialoguePunctuation = ['"', "'", ':', ';', '-', '—', '–'];

        // Initialize Google APIs
        function gapiLoaded() {
            gapi.load('client', initializeGapiClient);
        }

        async function initializeGapiClient() {
            await gapi.client.init({
                apiKey: API_KEY,
                discoveryDocs: [DISCOVERY_DOC],
            });
            gapi_inited = true;
            maybeEnableButtons();
            await loadAnalysisData(); // Tải dữ liệu phân tích khi khởi động
        }

        function gisLoaded() {
            tokenClient = google.accounts.oauth2.initTokenClient({
                client_id: CLIENT_ID,
                scope: SCOPES,
                callback: '',
            });
            gsi_inited = true;
            maybeEnableButtons();
        }

        function maybeEnableButtons() {
            if (gapi_inited && gsi_inited) {
                document.getElementById('scanBtn').disabled = false;
            }
        }

        // Authentication functions
        function handleAuthClick() {
            tokenClient.callback = async (resp) => {
                if (resp.error !== undefined) {
                    throw (resp);
                }
                await showLoggedInState();
            };

            if (gapi.client.getToken() === null) {
                tokenClient.requestAccessToken({prompt: 'consent'});
            } else {
                tokenClient.requestAccessToken({prompt: ''});
            }
        }

        function handleSignoutClick() {
            const token = gapi.client.getToken();
            if (token !== null) {
                google.accounts.oauth2.revoke(token.access_token);
                gapi.client.setToken('');
                showLoggedOutState();
            }
        }

        async function showLoggedInState() {
             updateStatus('🟢 Đã kết nối Google Drive');
    
    const enableButtons = ['scanBtn', 'analyzeBtn', 'generateBtn', 
                           'downloadAnalysisBtn', 'downloadScanCacheBtn', 
                           'loadStoriesBtn'];
    enableButtons.forEach(id => {
        if (document.getElementById(id)) {
            document.getElementById(id).disabled = false;
        }
    });

    try {
        const response = await gapi.client.request({
            path: 'https://openidconnect.googleapis.com/v1/userinfo'
        });
        // 👉 Có thể hiển thị tên / email người dùng tại đây
        console.log("User Info:", response.result);
    } catch (error) {
        console.error('Error getting user info:', error);
    }
        }

        function showLoggedOutState() {
              updateStatus('🔴 Chưa kết nối Google Drive');

    const disableButtons = ['scanBtn', 'analyzeBtn', 'generateBtn', 
                            'downloadAnalysisBtn', 'downloadScanCacheBtn', 
                            'loadStoriesBtn'];
    disableButtons.forEach(id => {
        if (document.getElementById(id)) {
            document.getElementById(id).disabled = true;
        }
    });

    // Ẩn luôn trình đọc truyện nếu đang mở
    document.getElementById('readerContainer').style.display = "none";
        }

        // Tab switching function
        function switchTab(tabId) {
            document.querySelectorAll('.tab-content').forEach(tab => {
                tab.classList.remove('active');
            });
            
            document.getElementById(tabId).classList.add('active');
            
            document.querySelectorAll('.menu-item').forEach(item => {
                item.classList.remove('active');
            });
            
            const menuItems = document.querySelectorAll('.menu-item');
            for (let item of menuItems) {
                if (item.textContent.includes(
                    tabId === 'tab-analysis' ? 'Phân tích' :
                    tabId === 'tab-write' ? 'Viết truyện' :
                    tabId === 'tab-stories' ? 'Thư viện' : 'Cài đặt'
                )) {
                    item.classList.add('active');
                    break;
                }
            }
            
            return false;
        }

        // Advanced Analysis Functions
        async function analyzeFiles() {
            if (!window.txtFiles || window.txtFiles.length === 0) {
                alert('Vui lòng quét thư mục trước khi phân tích!');
                return;
            }
            
            updateStatus('🧠 Bắt đầu phân tích nâng cao...');
            analysisData = [];
            
            const skipAnalyzed = document.getElementById('skipAnalyzedFiles').checked;
            let filesToAnalyze = window.txtFiles;
            
            if (skipAnalyzed) {
                try {
                    const response = await gapi.client.drive.files.list({
                        q: `name='${ANALYSIS_CACHE_NAME}' and trashed=false`,
                        fields: 'files(id)'
                    });
                    
                    if (response.result.files.length > 0) {
                        const analysisResponse = await gapi.client.drive.files.get({
                            fileId: response.result.files[0].id,
                            alt: 'media'
                        });
                        
                        const existingAnalysis = JSON.parse(analysisResponse.body);
                        const analyzedFileNames = existingAnalysis.analysisData.map(a => a.fileName);
                        
                        filesToAnalyze = window.txtFiles.filter(file => 
                            !analyzedFileNames.includes(file.name)
                        );
                        
                        if (filesToAnalyze.length === 0) {
                            updateStatus('✅ Tất cả file đã được phân tích trước đó');
                            analysisData = existingAnalysis.analysisData;
                            displayAdvancedAnalysisResults();
                            document.getElementById('generateBtn').disabled = false;
                            document.getElementById('downloadAnalysisBtn').disabled = false;
                            return;
                        }
                        
                        analysisData = existingAnalysis.analysisData;
                        updateStatus(`🔍 Bỏ qua ${window.txtFiles.length - filesToAnalyze.length} file đã phân tích, tiếp tục với ${filesToAnalyze.length} file mới`);
                    }
                } catch (error) {
                    console.log('No existing analysis found or error loading it, analyzing all files');
                }
            }
            
            const totalFiles = Math.min(filesToAnalyze.length, 50);
            
            for (let i = 0; i < totalFiles; i++) {
                const file = filesToAnalyze[i];
                updateProgress((i / totalFiles) * 100);
                updateStatus(`🧠 Đang phân tích: ${file.name} (${i+1}/${totalFiles})`);
                updateDetailedStatus(`Phân tích hội thoại và từ nhạy cảm...`);
                
                try {
                    const response = await gapi.client.drive.files.get({
                        fileId: file.id,
                        alt: 'media'
                    });
                    
                    const content = response.body;
                    const analysis = await performAdvancedAnalysis(content, file.name, file.folderPath);
                    analysisData.push(analysis);
                    
                    if (document.getElementById('autoSaveResults').checked) {
                        await autoSaveAnalysis();
                    }
                    
                    await new Promise(resolve => setTimeout(resolve, 500));
                    
                } catch (error) {
                    console.error(`Error analyzing file ${file.name}:`, error);
                    analysisData.push({
                        fileName: file.name,
                        error: error.message
                    });
                }
            }
            
            displayAdvancedAnalysisResults();
            document.getElementById('generateBtn').disabled = false;
            document.getElementById('downloadAnalysisBtn').disabled = false;
            updateProgress(100);
            updateStatus(`✅ Hoàn thành phân tích ${totalFiles} file`);
            updateDetailedStatus('');
            
            setTimeout(() => updateProgress(0), 2000);
        }

        async function performAdvancedAnalysis(content, fileName, folderPath) {
            await new Promise(resolve => setTimeout(resolve, 100));
            
            const analysis = {
                fileName: fileName,
                folderPath: folderPath || 'Unknown',
                timestamp: new Date().toLocaleString('vi-VN'),
                
                // Phân tích cơ bản
                basicStats: analyzeBasicStats(content),
                
                // Phân tích cảm xúc
                emotionalAnalysis: analyzeEmotionsAdvanced(content),
                
                // Phân tích chủ đề
                thematicAnalysis: analyzeThemes(content),
                
                // Phân tích nhân vật
                characterAnalysis: analyzeCharactersAdvanced(content),
                
                // Phân tích hội thoại (mới)
                dialogueAnalysis: analyzeDialogues(content),
                
                // Phân tích từ nhạy cảm (mới)
                sensitiveAnalysis: analyzeSensitiveContent(content),
                
                // Phân tích cốt truyện
                narrativeAnalysis: analyzeNarrativeStructure(content),
                
                // Mẫu nội dung
                contentSample: content.substring(0, 1000) + (content.length > 1000 ? '...' : '')
            };
            
            return analysis;
        }

        function analyzeBasicStats(content) {
            const sentences = content.split(/[.!?]+/).filter(s => s.trim().length > 0);
            const paragraphs = content.split(/\n\s*\n/).filter(p => p.trim().length > 0);
            const words = content.split(/\s+/).filter(w => w.length > 0);
            const characters = content.length;
            const charactersNoSpaces = content.replace(/\s/g, '').length;
            
            return {
                wordCount: words.length,
                sentenceCount: sentences.length,
                paragraphCount: paragraphs.length,
                characterCount: characters,
                characterCountNoSpaces: charactersNoSpaces,
                avgWordsPerSentence: Math.round(words.length / sentences.length * 10) / 10,
                avgSentencesPerParagraph: Math.round(sentences.length / paragraphs.length * 10) / 10,
                avgWordLength: Math.round(charactersNoSpaces / words.length * 10) / 10
            };
        }

        function analyzeEmotionsAdvanced(content) {
            const words = content.toLowerCase().split(/\s+/);
            const sentences = content.split(/[.!?]+/).filter(s => s.trim().length > 0);
            
            let emotionCounts = {
                positive: 0,
                negative: 0,
                neutral: 0
            };
            
            let emotionDistribution = [];
            let emotionalSentences = [];
            
            words.forEach(word => {
                for (const [emotion, keywords] of Object.entries(emotionalWords)) {
                    if (keywords.some(kw => word.includes(kw))) {
                        emotionCounts[emotion]++;
                        break;
                    }
                }
            });
            
            sentences.forEach((sentence, index) => {
                const sentenceLower = sentence.toLowerCase();
                let emotionScore = 0;
                
                for (const [emotion, keywords] of Object.entries(emotionalWords)) {
                    keywords.forEach(kw => {
                        if (sentenceLower.includes(kw)) {
                            emotionScore += emotion === 'positive' ? 1 : emotion === 'negative' ? -1 : 0;
                        }
                    });
                }
                
                if (Math.abs(emotionScore) > 0) {
                    emotionalSentences.push({
                        sentence: sentence.trim(),
                        emotionScore: emotionScore,
                        index: index
                    });
                }
            });
            
            const totalEmotionalWords = emotionCounts.positive + emotionCounts.negative + emotionCounts.neutral;
            
            if (totalEmotionalWords > 0) {
                emotionDistribution = [
                    { emotion: 'positive', percentage: Math.round((emotionCounts.positive / totalEmotionalWords) * 100) },
                    { emotion: 'negative', percentage: Math.round((emotionCounts.negative / totalEmotionalWords) * 100) },
                    { emotion: 'neutral', percentage: Math.round((emotionCounts.neutral / totalEmotionalWords) * 100) }
                ];
            }
            
            return {
                emotionCounts,
                emotionDistribution,
                emotionalSentences: emotionalSentences.slice(0, 10),
                dominantEmotion: emotionDistribution.length > 0 ? 
                    emotionDistribution.reduce((prev, current) => 
                        (prev.percentage > current.percentage) ? prev : current).emotion : 'neutral'
            };
        }

        function analyzeThemes(content) {
            const words = content.toLowerCase().split(/\s+/);
            const wordFrequency = {};
            
            words.forEach(word => {
                if (word.length > 3 && !vietnameseStopWords.includes(word)) {
                    wordFrequency[word] = (wordFrequency[word] || 0) + 1;
                }
            });
            
            const sortedWords = Object.entries(wordFrequency)
                .sort((a, b) => b[1] - a[1])
                .slice(0, 20);
            
            const themes = [];
            sortedWords.forEach(([word, count]) => {
                if (count > 2) {
                    themes.push({ word, count });
                }
            });
            
            return themes;
        }

        function analyzeCharactersAdvanced(content) {
            const lines = content.split('\n');
            const characters = [];
            const characterMentions = {};
            
            lines.forEach(line => {
                // Tìm tên nhân vật (viết hoa chữ cái đầu)
                const nameMatches = line.match(/\b[A-ZÀÁẢÃẠĂẰẮẲẴẶÂẦẤẨẪẬĐÈÉẺẼẸÊỀẾỂỄỆÌÍỈĨỊÒÓỎÕỌÔỒỐỔỖỘƠỜỚỞỠỢÙÚỦŨỤƯỪỨỬỮỰỲÝỶỸỴ][a-zàáảãạăằắẳẵặâầấẩẫậđèéẻẽẹêềếểễệìíỉĩịòóỏõọôồốổỗộơờớởỡợùúủũụưừứửữựỳýỷỹỵ]+\b/g);
                
                if (nameMatches) {
                    nameMatches.forEach(name => {
                        if (name.length > 2 && !characterMentions[name]) {
                            characterMentions[name] = 0;
                            characters.push({
                                name: name,
                                mentions: 0,
                                firstAppearance: line.substring(0, 100) + '...'
                            });
                        }
                        if (characterMentions[name] !== undefined) {
                            characterMentions[name]++;
                        }
                    });
                }
            });
            
            characters.forEach(char => {
                char.mentions = characterMentions[char.name] || 0;
            });
            
            return characters.sort((a, b) => b.mentions - a.mentions).slice(0, 10);
        }

        function analyzeDialogues(content) {
            const lines = content.split('\n');
            const dialogues = [];
            let dialogueCount = 0;
            
            lines.forEach((line, index) => {
                const trimmedLine = line.trim();
                
                // Kiểm tra xem dòng này có phải là hội thoại không
                const isDialogue = dialogueIndicators.some(indicator => 
                    trimmedLine.toLowerCase().includes(indicator)
                ) || dialoguePunctuation.some(punct => 
                    trimmedLine.includes(punct)
                );
                
                if (isDialogue && trimmedLine.length > 10) {
                    dialogueCount++;
                    
                    // Tìm câu hội thoại trực tiếp (trong dấu ngoặc kép)
                    const directDialogueMatch = trimmedLine.match(/["'](.*?)["']/);
                    if (directDialogueMatch) {
                        dialogues.push({
                            type: 'direct',
                            content: directDialogueMatch[1],
                            context: trimmedLine,
                            lineNumber: index + 1
                        });
                    } else {
                        dialogues.push({
                            type: 'indirect',
                            content: trimmedLine,
                            context: '',
                            lineNumber: index + 1
                        });
                    }
                }
            });
            
            return {
                totalDialogues: dialogueCount,
                sampleDialogues: dialogues.slice(0, 5)
            };
        }

        function analyzeSensitiveContent(content) {
            const contentLower = content.toLowerCase();
            const foundSensitiveWords = {};
            let totalSensitiveWords = 0;
            
            // Kiểm tra tất cả các loại từ nhạy cảm
            for (const [category, words] of Object.entries(sensitiveWords)) {
                foundSensitiveWords[category] = [];
                
                words.forEach(word => {
                    const regex = new RegExp('\\b' + word + '\\b', 'gi');
                    const matches = contentLower.match(regex);
                    
                    if (matches) {
                        foundSensitiveWords[category].push({
                            word: word,
                            count: matches.length
                        });
                        totalSensitiveWords += matches.length;
                    }
                });
            }
            
            // Tính điểm nhạy cảm
            let sensitivityScore = 0;
            if (totalSensitiveWords > 0) {
                sensitivityScore = Math.min(10, Math.floor(totalSensitiveWords / 5) + 
                    (foundSensitiveWords.sexual ? foundSensitiveWords.sexual.length * 2 : 0));
            }
            
            return {
                foundSensitiveWords,
                totalSensitiveWords,
                sensitivityScore
            };
        }

        function analyzeNarrativeStructure(content) {
            const sentences = content.split(/[.!?]+/).filter(s => s.trim().length > 0);
            const paragraphs = content.split(/\n\s*\n/).filter(p => p.trim().length > 0);
            
            return {
                estimatedReadingTime: Math.ceil(sentences.length / 10),
                complexityScore: Math.min(10, Math.ceil(sentences.length / 50 + paragraphs.length / 10)),
                narrativeStyle: sentences.length > paragraphs.length * 5 ? 'descriptive' : 'dialogue-heavy'
            };
        }

        function displayAdvancedAnalysisResults() {
            const resultsContainer = document.getElementById('analysisResults');
            
            if (!analysisData || analysisData.length === 0) {
                resultsContainer.innerHTML = '<p>Chưa có dữ liệu phân tích. Vui lòng quét và phân tích thư mục trước.</p>';
                return;
            }
            
            let html = `<h4>📊 Tổng quan phân tích (${analysisData.length} file)</h4>`;
            
            analysisData.forEach((data, index) => {
                if (data.error) {
                    html += `
                        <div class="analysis-result-item">
                            <h4>❌ ${data.fileName}</h4>
                            <p>Lỗi: ${data.error}</p>
                        </div>
                    `;
                    return;
                }
                
                html += `
                    <div class="analysis-result-item">
                        <h4>📄 ${data.fileName} (${data.folderPath})</h4>
                        <p><strong>Thời gian:</strong> ${data.timestamp}</p>
                        
                        <div class="toggle-container" onclick="toggleDetails('details-${index}')">
                            <span>📈 Thống kê cơ bản</span>
                            <span>▼</span>
                        </div>
                        <div id="details-${index}" style="display:none;">
                            <p><strong>Số từ:</strong> ${data.basicStats.wordCount}</p>
                            <p><strong>Số câu:</strong> ${data.basicStats.sentenceCount}</p>
                            <p><strong>Số đoạn:</strong> ${data.basicStats.paragraphCount}</p>
                            <p><strong>Độ dài trung bình từ:</strong> ${data.basicStats.avgWordLength} ký tự</p>
                            <p><strong>Từ/câu trung bình:</strong> ${data.basicStats.avgWordsPerSentence}</p>
                            
                            <div class="toggle-container" onclick="toggleDetails('emotion-${index}')">
                                <span>😊 Phân tích cảm xúc</span>
                                <span>▼</span>
                            </div>
                            <div id="emotion-${index}" style="display:none;">
                                <p><strong>Cảm xúc chủ đạo:</strong> ${data.emotionalAnalysis.dominantEmotion}</p>
                                <p><strong>Tích cực:</strong> ${data.emotionalAnalysis.emotionCounts.positive} từ</p>
                                <p><strong>Tiêu cực:</strong> ${data.emotionalAnalysis.emotionCounts.negative} từ</p>
                                <p><strong>Trung tính:</strong> ${data.emotionalAnalysis.emotionCounts.neutral} từ</p>
                                
                                ${data.emotionalAnalysis.emotionDistribution.map(ed => 
                                    `<p><strong>${ed.emotion}:</strong> ${ed.percentage}%</p>`
                                ).join('')}
                            </div>
                            
                            <div class="toggle-container" onclick="toggleDetails('dialogue-${index}')">
                                <span>💬 Phân tích hội thoại</span>
                                <span>▼</span>
                            </div>
                            <div id="dialogue-${index}" style="display:none;">
                                <p><strong>Tổng số hội thoại:</strong> ${data.dialogueAnalysis.totalDialogues}</p>
                                ${data.dialogueAnalysis.sampleDialogues.map(d => 
                                    `<div class="dialogue">
                                        <p>${d.content.substring(0, 100)}${d.content.length > 100 ? '...' : ''}</p>
                                        <small>Dòng ${d.lineNumber}, Loại: ${d.type}</small>
                                    </div>`
                                ).join('')}
                            </div>
                            
                            <div class="toggle-container" onclick="toggleDetails('sensitive-${index}')">
                                <span>⚠️ Từ nhạy cảm</span>
                                <span>▼</span>
                            </div>
                            <div id="sensitive-${index}" style="display:none;">
                                <p><strong>Điểm nhạy cảm:</strong> ${data.sensitiveAnalysis.sensitivityScore}/10</p>
                                <p><strong>Tổng từ nhạy cảm:</strong> ${data.sensitiveAnalysis.totalSensitiveWords}</p>
                                
                                ${Object.entries(data.sensitiveAnalysis.foundSensitiveWords).map(([category, words]) => {
                                    if (words.length === 0) return '';
                                    return `
                                        <p><strong>${category}:</strong> ${words.map(w => `${w.word} (${w.count})`).join(', ')}</p>
                                    `;
                                }).join('')}
                            </div>
                            
                            <div class="toggle-container" onclick="toggleDetails('sample-${index}')">
                                <span>🔍 Mẫu nội dung</span>
                                <span>▼</span>
                            </div>
                            <div id="sample-${index}" style="display:none;">
                                <div class="story-content">
                                    ${highlightSensitiveWords(data.contentSample)}
                                </div>
                            </div>
                        </div>
                    </div>
                `;
            });
            
            resultsContainer.innerHTML = html;
        }

        function highlightSensitiveWords(text) {
            let highlightedText = text;
            
            // Tô sáng tất cả các từ nhạy cảm
            for (const [category, words] of Object.entries(sensitiveWords)) {
                for (const word of words) {
                    const regex = new RegExp('\\b' + word + '\\b', 'gi');
                    highlightedText = highlightedText.replace(regex, 
                        match => `<span class="sensitive-word">${match}</span>`
                    );
                }
            }
            
            return highlightedText;
        }

        function toggleDetails(id) {
            const element = document.getElementById(id);
            if (element.style.display === 'none') {
                element.style.display = 'block';
            } else {
                element.style.display = 'none';
            }
        }

        // Scan folder function
        async function scanFolder() {
            updateStatus('🔍 Đang quét thư mục "QuanLyTruyen"...');
            updateProgress(10);
            
            try {
                // Tìm thư mục QuanLyTruyen
                const folderResponse = await gapi.client.drive.files.list({
                    q: "name='QuanLyTruyen' and mimeType='application/vnd.google-apps.folder' and trashed=false",
                    fields: 'files(id, name)'
                });
                
                if (folderResponse.result.files.length === 0) {
                    updateStatus('❌ Không tìm thấy thư mục "QuanLyTruyen"');
                    return;
                }
                
                const folderId = folderResponse.result.files[0].id;
                updateProgress(30);
                updateStatus('📂 Đang tìm kiếm file văn bản...');
                
                // Tìm tất cả các file .txt trong thư mục và các thư mục con
                let allFiles = [];
                let nextPageToken = null;
                
                do {
                    const fileResponse = await gapi.client.drive.files.list({
                        q: `'${folderId}' in parents and trashed=false`,
                        fields: 'nextPageToken, files(id, name, mimeType, parents)',
                        pageSize: 100,
                        pageToken: nextPageToken || undefined
                    });
                    
                    const files = fileResponse.result.files;
                    
                    for (let file of files) {
                        if (file.mimeType === 'application/vnd.google-apps.folder') {
                            // Đệ quy vào thư mục con
                            const subFiles = await getFilesFromFolder(file.id, file.name);
                            allFiles = allFiles.concat(subFiles);
                        } else if (file.name.endsWith('.txt')) {
                            file.folderPath = 'QuanLyTruyen';
                            allFiles.push(file);
                        }
                    }
                    
                    nextPageToken = fileResponse.result.nextPageToken;
                } while (nextPageToken);
                
                updateProgress(70);
                
                if (allFiles.length === 0) {
                    updateStatus('❌ Không tìm thấy file văn bản (.txt) trong thư mục');
                    return;
                }
                
                window.txtFiles = allFiles;
                updateProgress(100);
                updateStatus(`✅ Đã tìm thấy ${allFiles.length} file văn bản`);
                document.getElementById('analyzeBtn').disabled = false;
                document.getElementById('downloadScanCacheBtn').disabled = false;
                
                // Lưu cache scan
                scanCache = {
                    files: allFiles.map(f => ({ id: f.id, name: f.name, folderPath: f.folderPath })),
                    timestamp: new Date().toISOString()
                };
                
                await saveScanCache();
                
            } catch (error) {
                console.error('Error scanning folder:', error);
                updateStatus('❌ Lỗi khi quét thư mục: ' + error.message);
            }
        }

        async function getFilesFromFolder(folderId, folderPath) {
            let files = [];
            let nextPageToken = null;
            
            do {
                const response = await gapi.client.drive.files.list({
                    q: `'${folderId}' in parents and trashed=false`,
                    fields: 'nextPageToken, files(id, name, mimeType, parents)',
                    pageSize: 100,
                    pageToken: nextPageToken || undefined
                });
                
                const folderFiles = response.result.files;
                
                for (let file of folderFiles) {
                    if (file.mimeType === 'application/vnd.google-apps.folder') {
                        // Đệ quy vào thư mục con
                        const subFiles = await getFilesFromFolder(file.id, `${folderPath}/${file.name}`);
                        files = files.concat(subFiles);
                    } else if (file.name.endsWith('.txt')) {
                        file.folderPath = folderPath;
                        files.push(file);
                    }
                }
                
                nextPageToken = response.result.nextPageToken;
            } while (nextPageToken);
            
            return files;
        }

        async function saveScanCache() {
            try {
                // Kiểm tra xem file cache đã tồn tại chưa
                const response = await gapi.client.drive.files.list({
                    q: `name='${CACHE_FILE_NAME}' and trashed=false`,
                    fields: 'files(id)'
                });
                
                const cacheContent = JSON.stringify(scanCache);
                const media = {
                    mimeType: 'application/json',
                    body: cacheContent
                };
                
                if (response.result.files.length > 0) {
                    // Cập nhật file cache đã tồn tại
                    await gapi.client.drive.files.update({
                        fileId: response.result.files[0].id,
                        media: media
                    });
                } else {
                    // Tạo file cache mới
                    const metadata = {
                        name: CACHE_FILE_NAME,
                        mimeType: 'application/json'
                    };
                    
                    await gapi.client.drive.files.create({
                        resource: metadata,
                        media: media,
                        fields: 'id'
                    });
                }
            } catch (error) {
                console.error('Error saving scan cache:', error);
            }
        }

        async function loadScanCache() {
            try {
                const response = await gapi.client.drive.files.list({
                    q: `name='${CACHE_FILE_NAME}' and trashed=false`,
                    fields: 'files(id)'
                });
                
                if (response.result.files.length > 0) {
                    const cacheResponse = await gapi.client.drive.files.get({
                        fileId: response.result.files[0].id,
                        alt: 'media'
                    });
                    
                    scanCache = JSON.parse(cacheResponse.body);
                    
                    // Kiểm tra xem cache có còn hợp lệ không (không quá 24 giờ)
                    const cacheAge = new Date() - new Date(scanCache.timestamp);
                    if (cacheAge < 24 * 60 * 60 * 1000) {
                        window.txtFiles = scanCache.files;
                        document.getElementById('analyzeBtn').disabled = false;
                         document.getElementById('downloadScanCacheBtn').disabled = false;
                        updateStatus(`✅ Đã tải cache scan với ${scanCache.files.length} file`);
                        return true;
                    }
                }
            } catch (error) {
                console.error('Error loading scan cache:', error);
            }
            
            return false;
        }

        async function autoSaveAnalysis() {
    try {
        const analysisContent = {
            analysisData: analysisData,
            timestamp: new Date().toISOString()
        };

        const contentString = JSON.stringify(analysisContent);
        const media = {
            mimeType: 'application/json',
            body: contentString
        };

        // Kiểm tra xem file đã tồn tại chưa
        const response = await gapi.client.drive.files.list({
            q: `name='${ANALYSIS_CACHE_NAME}' and trashed=false`,
            fields: 'files(id)'
        });

        if (response.result.files.length > 0) {
            // 🔄 Update file duy nhất
            await gapi.client.request({
                path: `/upload/drive/v3/files/${response.result.files[0].id}`,
                method: 'PATCH',
                params: { uploadType: 'media' },
                body: contentString
            });
        } else {
            // ➕ Create file mới
            const metadata = {
                name: ANALYSIS_CACHE_NAME,
                mimeType: 'application/json'
            };

            await gapi.client.drive.files.create({
                resource: metadata,
                media: media,
                fields: 'id'
            });
        }
    } catch (error) {
        console.error('Error auto-saving analysis:', error);
    }
}


        async function loadAnalysisData() {
            try {
                const response = await gapi.client.drive.files.list({
                    q: `name='${ANALYSIS_CACHE_NAME}' and trashed=false`,
                    fields: 'files(id)'
                });
                
                if (response.result.files.length > 0) {
                    const analysisResponse = await gapi.client.drive.files.get({
                        fileId: response.result.files[0].id,
                        alt: 'media'
                    });
                    
                    const analysisContent = JSON.parse(analysisResponse.body);
                    analysisData = analysisContent.analysisData;
                    
                    displayAdvancedAnalysisResults();
                    document.getElementById('generateBtn').disabled = false;
                    document.getElementById('downloadAnalysisBtn').disabled = false;
                    
                    updateStatus('✅ Đã tải dữ liệu phân tích từ lần trước');
                    return true;
                }
            } catch (error) {
                console.error('Error loading analysis data:', error);
            }
            
            return false;
        }

        async function downloadAnalysis() {
           try {
        const response = await gapi.client.drive.files.list({
            q: `name='${ANALYSIS_CACHE_NAME}' and trashed=false`,
            fields: 'files(id, name)'
        });

        if (response.result.files.length === 0) {
            alert("❌ Không tìm thấy file phân tích trên Google Drive!");
            return;
        }

        const fileId = response.result.files[0].id;
        const analysisResponse = await gapi.client.drive.files.get({
            fileId: fileId,
            alt: 'media'
        });

        const analysisContent = JSON.parse(analysisResponse.body);
        analysisData = analysisContent.analysisData;

        displayAdvancedAnalysisResults();
        updateStatus('✅ Đã tải dữ liệu phân tích từ Google Drive');
    } catch (error) {
        console.error('Error downloading analysis:', error);
        updateStatus('❌ Lỗi khi tải dữ liệu phân tích từ Google Drive');
    }
        }

        // Story generation functions
        async function generateStories() {
            if (!analysisData || analysisData.length === 0) {
        alert('⚠️ Vui lòng phân tích dữ liệu trước khi tạo truyện!');
        return;
    }

    updateWriteStatus('✍️ Bắt đầu viết truyện...');
    updateWriteProgress(0);

    const minChapters = parseInt(document.getElementById('minChapters').value) || 50;
    const sensitivityLevel = parseInt(document.getElementById('sensitivityLevel').value) || 5;

    generatedStories = [];

    // Tìm hoặc tạo thư mục cha QuanLyTruyen
    let storiesFolderId = await findOrCreateFolder('QuanLyTruyen');

    for (let i = 0; i < analysisData.length; i++) {
        const data = analysisData[i];
        updateWriteStatus(`📖 Đang viết truyện từ: ${data.fileName} (${i+1}/${analysisData.length})`);
        updateWriteProgress((i / analysisData.length) * 50);

        try {
            // Tạo truyện từ data phân tích
            const story = await generateStoryFromAnalysis(data, minChapters, sensitivityLevel);
            generatedStories.push(story);

            // Lưu vào Google Drive
            await saveStoryToDrive(story, storiesFolderId);

            updateWriteDetailedStatus(`✅ Đã tạo: ${story.title} (${story.chapters.length} chương)`);
        } catch (error) {
            console.error(`Error generating story from ${data.fileName}:`, error);
            updateWriteDetailedStatus(`❌ Lỗi với ${data.fileName}: ${error.message}`);
        }

        await new Promise(resolve => setTimeout(resolve, 500));
    }

    displayGeneratedStories();
    updateWriteProgress(100);
    updateWriteStatus(`🎉 Hoàn thành tạo ${generatedStories.length} truyện`);
        }

        async function generateStoryFromAnalysis(analysis, minChapters, sensitivityLevel) {
             const title = generateTitle(analysis);
  const description = generateDescription(analysis);

  const chapters = [];
  const numChapters = Math.max(minChapters, Math.floor(analysis.basicStats.wordCount / 2500));

  for (let i = 1; i <= numChapters; i++) {
    const chapterTitle = `Chương ${i}: ${generateChapterTitle(analysis, i)}`;
    const chapterContent = await generateChapterContent(analysis, sensitivityLevel, 2000, 3000);

    chapters.push({
      title: chapterTitle,
      content: chapterContent,
      wordCount: chapterContent.split(/\s+/).length
    });
  }

  return { title, description, chapters };
    //        const title = generateTitle(analysis);       // tên truyện tự sinh
    // const description = generateDescription(analysis);

    // const chapters = [];
    // const numChapters = Math.max(minChapters, Math.floor(analysis.basicStats.wordCount / 2500));

    // for (let i = 1; i <= numChapters; i++) {
    //     const chapterTitle = `Chương ${i}: ${generateChapterTitle(analysis, i)}`;
    //     const chapterContent = generateChapterContent(analysis, sensitivityLevel, 2000, 3000);

    //     chapters.push({
    //         title: chapterTitle,
    //         content: chapterContent,
    //         wordCount: chapterContent.split(/\s+/).length
    //     });
    }

    // return {
    //     title: title,
    //     description: description,
    //     chapters: chapters,
    //     source: analysis.fileName,
    //     generatedAt: new Date().toLocaleString('vi-VN'),
    //     totalWords: chapters.reduce((sum, ch) => sum + ch.wordCount, 0)
    // };
        // }

        function generateTitle(analysis) {
            const themes = analysis.thematicAnalysis.slice(0, 3).map(t => t.word);
            const characters = analysis.characterAnalysis.slice(0, 2).map(c => c.name);
            
            const titlePatterns = [
                `${characters[0]} và ${characters[1]}`,
                `Cuộc đời ${characters[0]}`,
                `Hành trình của ${characters[0]}`,
                `Tình ${themes[0]}`,
                `Bí mật ${themes[0]}`,
                `${themes[0]} và ${themes[1]}`,
                `Mối tình ${themes[0]}`,
                `Số phận ${characters[0]}`,
                `Người ${themes[0]}`,
                `Nỗi đau ${themes[0]}`,
                `Ánh sáng ${themes[0]}`,
                `Bóng tối ${themes[0]}`
            ];
            
            return titlePatterns[Math.floor(Math.random() * titlePatterns.length)];
        }

        function generateDescription(analysis) {
            const themes = analysis.thematicAnalysis.slice(0, 3).map(t => t.word);
            const characters = analysis.characterAnalysis.slice(0, 2).map(c => c.name);
            const emotion = analysis.emotionalAnalysis.dominantEmotion;
            
            const descriptions = [
                `Câu chuyện về ${characters[0]} và ${characters[1]} trong thế giới đầy ${themes[0]} và ${themes[1]}. Một hành trình đầy ${emotion} sẽ thay đổi cuộc đời họ mãi mãi.`,
                `${characters[0]} đã luôn tin rằng ${themes[0]} là thứ quan trọng nhất, cho đến khi gặp ${characters[1]}. Liệu ${emotion} có giúp họ vượt qua mọi thử thách?`,
                `Trong một xã hội đầy rẫy ${themes[0]}, ${characters[0]} phải đấu tranh để tìm ra ý nghĩa thực sự của ${themes[1]}. Một câu chuyện đầy ${emotion} và bất ngờ.`,
                `Khi ${themes[0]} và ${themes[1]} đụng độ, ${characters[0]} và ${characters[1]} phải đưa ra những lựa chọn khó khăn. Liệu ${emotion} có đủ để giữ họ lại với nhau?`,
                `Bí mật về ${themes[0]} đã được giấu kín hàng thế kỷ, cho đến khi ${characters[0]} vô tình khám phá ra. Một hành trình ${emotion} đầy nguy hiểm bắt đầu.`
            ];
            
            return descriptions[Math.floor(Math.random() * descriptions.length)];
        }

        function generateChapterTitle(analysis, chapterNumber) {
            const themes = analysis.thematicAnalysis.map(t => t.word);
            const emotions = ['Vui', 'Buồn', 'Giận', 'Yêu', 'Thất vọng', 'Hy vọng', 'Đau khổ', 'Hạnh phúc'];
            const events = ['Gặp gỡ', 'Chia ly', 'Khám phá', 'Thử thách', 'Biến cố', 'Bí mật', 'Lựa chọn', 'Hy sinh'];
            
            return `${events[Math.floor(Math.random() * events.length)]} ${emotions[Math.floor(Math.random() * emotions.length)]}`;
        }

        function generateChapterContent(analysis, sensitivityLevel, minWords = 2000, maxWords = 3000) {
             const wordCountTarget = Math.floor(Math.random() * (maxWords - minWords)) + minWords;

  // Ngẫu nhiên bối cảnh
  const times = ["một đêm mưa", "một buổi chiều oi ả", "một buổi sáng tinh mơ", "lúc hoàng hôn buông xuống"];
  const places = ["phòng khách", "phòng ngủ cũ của bố", "căn bếp im lìm", "gác nhỏ phía sau nhà"];
  const weathers = ["mưa rơi rả rích", "gió thổi rít qua khe cửa", "trời oi bức khó chịu", "không gian tĩnh lặng"];
  const chosenTime = times[Math.floor(Math.random() * times.length)];
  const chosenPlace = places[Math.floor(Math.random() * places.length)];
  const chosenWeather = weathers[Math.floor(Math.random() * weathers.length)];

  // Prompt cho AI
  const prompt = `
  Hãy viết một chương truyện dài khoảng ${wordCountTarget} từ theo ngôi thứ nhất.
  Người kể chuyện là người chồng, phát hiện mối quan hệ giữa vợ (con dâu) và bố (bố chồng).
  Anh ta chọn im lặng, bất lực, chỉ quan sát và dằn vặt.
  Trong lời thoại: vợ gọi "bố", bố gọi "con".
  Bối cảnh: ${chosenTime}, tại ${chosenPlace}, ngoài trời ${chosenWeather}.
  Miêu tả cảm xúc nội tâm, hội thoại, nguyên nhân, khung cảnh, cao trào và dư âm.
  `;

  return new Promise((resolve, reject) => {
    textGenerator.generate(
      {
        seed: prompt,        // gợi ý đầu vào
        length: 2000,        // số ký tự (chỉnh cao hơn nếu muốn dài hơn)
        temperature: 0.6     // độ sáng tạo (0.5–0.7 ổn)
      },
      (err, result) => {
        if (err) {
          console.error(err);
          reject("❌ Lỗi khi sinh văn bản với ml5");
        } else {
          resolve(result.sample); // văn bản AI sinh
        }
      }
    );
  });
            // const targetWords = Math.floor(Math.random() * (maxWords - minWords + 1)) + minWords;
            // let content = '';
            // let wordCount = 0;
            
            // // Lấy các yếu tố từ phân tích để tạo nội dung
            // const themes = analysis.thematicAnalysis.map(t => t.word);
            // const characters = analysis.characterAnalysis.map(c => c.name);
            // const emotionalStyle = analysis.emotionalAnalysis.dominantEmotion;
            
            // // Tạo nội dung cho đến khi đạt số từ mong muốn
            // while (wordCount < targetWords) {
            //     // Tạo đoạn văn ngẫu nhiên dựa trên phân tích
            //     const paragraph = generateParagraph(analysis, themes, characters, emotionalStyle, sensitivityLevel);
            //     content += paragraph + '\n\n';
            //     wordCount += paragraph.split(/\s+/).length;
            // }
            
            // return content;
        }

        function generateParagraph(analysis, themes, characters, emotionalStyle, sensitivityLevel) {
            const paragraphTypes = ['description', 'dialogue', 'action', 'reflection'];
            const type = paragraphTypes[Math.floor(Math.random() * paragraphTypes.length)];
            
            switch (type) {
                case 'description':
                    return generateDescriptiveParagraph(themes, emotionalStyle);
                case 'dialogue':
                    return generateDialogueParagraph(characters, analysis.dialogueAnalysis);
                case 'action':
                    return generateActionParagraph(characters, themes);
                case 'reflection':
                    return generateReflectionParagraph(characters, emotionalStyle);
                default:
                    return generateDescriptiveParagraph(themes, emotionalStyle);
            }
        }

        function generateDescriptiveParagraph(themes, emotionalStyle) {
            const descriptions = [
                `Bầu trời đầy sao lấp lánh trên đầu, mang đến cảm giác ${emotionalStyle} khó tả. ${themes[0]} và ${themes[1]} hòa quyện vào nhau tạo nên một khung cảnh đẹp đến nao lòng.`,
                `Con đường làng quanh co uốn lượn giữa những rặng tre xanh rì. Tiếng gió thổi vi vu qua kẽ lá, mang theo hương thơm của ${themes[2]} và ${themes[0]}.`,
                `Căn phòng nhỏ ấm áp với ánh đèn vàng dịu dàng. Trên bàn, một ly trà nóng bốc khói nghi ngút, tỏa hương thơm của ${themes[1]} và kỷ niệm.`,
                `Mặt hồ phẳng lặng như gương, phản chiếu những đám mây trắng bồng bềnh. Xa xa, tiếng chim hót véo von hòa cùng tiếng gió thổi mang đến sự bình yên ${emotionalStyle}.`,
                `Thành phố nhộn nhịp với những tòa nhà cao tầng san sát nhau. Ánh đèn neon đủ màu nhấp nháy, tạo nên một thế giới ${themes[0]} đầy màu sắc và ${emotionalStyle}.`
            ];
            
            return descriptions[Math.floor(Math.random() * descriptions.length)];
        }

        function generateDialogueParagraph(characters, dialogueAnalysis) {
            if (characters.length < 2) {
                return generateDescriptiveParagraph(['thiên nhiên', 'phong cảnh'], 'bình yên');
            }
            
            const char1 = characters[Math.floor(Math.random() * characters.length)];
            let char2 = characters[Math.floor(Math.random() * characters.length)];
            
            // Đảm bảo 2 nhân vật khác nhau
            while (char2 === char1 && characters.length > 1) {
                char2 = characters[Math.floor(Math.random() * characters.length)];
            }
            
            const dialogues = [
                `${char1} nhìn ${char2} chằm chằm: "Tại sao anh lại làm thế?"\n${char2} cúi đầu: "Em không hiểu đâu, có những thứ buộc phải như vậy."`,
                `"Tôi đã nghĩ chúng ta hiểu nhau hơn thế," ${char1} nói với giọng đầy thất vọng.\n${char2} thở dài: "Đôi khi hiểu quá rõ lại khiến người ta đau khổ."`,
                `${char1} mỉm cười: "Mọi chuyện rồi sẽ ổn thôi."\n${char2} lắc đầu: "Tôi không chắc như vậy, có quá nhiều rủi ro."`,
                `"Anh có bao giờ nghĩ về tương lai của chúng ta?" ${char1} hỏi khẽ.\n${char2} im lặng một lúc: "Tương lai là thứ không thể đoán trước, em à."`,
                `${char1} nắm tay ${char2}: "Dù thế nào đi nữa, tôi vẫn sẽ luôn bên cạnh em."\n${char2} mắt rưng rưng: "Anh thật sự nghĩ vậy sao?"`
            ];
            
            return dialogues[Math.floor(Math.random() * dialogues.length)];
        }

        function generateActionParagraph(characters, themes) {
            const char = characters[Math.floor(Math.random() * characters.length)];
            
            const actions = [
                `Bất chợt, ${char} lao về phía trước với tốc độ chóng mặt, vượt qua mọi chướng ngại vật với sự khéo léo đáng kinh ngạc.`,
                `Với một động tác nhanh như chớp, ${char} rút vũ khí ra và chuẩn bị cho trận chiến sắp tới.`,
                `${char} hét lên đầy phẫn nộ và tấn công đối thủ bằng tất cả sức mạnh có trong người.`,
                `Không chần chừ thêm nữa, ${char} nhảy xuống từ trên cao, xoay người và tiếp đất một cách nhẹ nhàng.`,
                `Với đôi mắt sắc lẹm, ${char} quan sát xung quanh, tìm kiếm bất kỳ dấu hiệu nguy hiểm nào.`
            ];
            
            return actions[Math.floor(Math.random() * actions.length)];
        }

        function generateReflectionParagraph(characters, emotionalStyle) {
            const char = characters[Math.floor(Math.random() * characters.length)];
            
            const reflections = [
                `${char} ngồi một mình trong phòng, suy nghĩ về những gì đã xảy ra. Cảm giác ${emotionalStyle} trào dâng trong lòng.`,
                `Trong im lặng, ${char} nhận ra rằng có những thứ quan trọng hơn những gì mình từng nghĩ.`,
                `${char} tự hỏi liệu mình đã đưa ra quyết định đúng đắn hay không. Sự ${emotionalStyle} khiến trái tim nhói đau.`,
                `Ký ức ùa về như thác lũ, khiến ${char} không thể kìm được nước mắt. Những kỷ niệm ${emotionalStyle} cứ thế xoáy sâu vào tâm trí.`,
                `${char} nhìn ra xa, suy ngẫm về ý nghĩa thực sự của cuộc sống và những gì thực sự quan trọng.`
            ];
            
            return reflections[Math.floor(Math.random() * reflections.length)];
        }

        async function findOrCreateFolder(folderName) {
            try {
                // Tìm thư mục
                const response = await gapi.client.drive.files.list({
                    q: `name='${folderName}' and mimeType='application/vnd.google-apps.folder' and trashed=false`,
                    fields: 'files(id, name)'
                });
                
                if (response.result.files.length > 0) {
                    return response.result.files[0].id;
                }
                
                // Tạo thư mục mới nếu không tìm thấy
                const metadata = {
                    name: folderName,
                    mimeType: 'application/vnd.google-apps.folder'
                };
                
                const folder = await gapi.client.drive.files.create({
                    resource: metadata,
                    fields: 'id'
                });
                
                return folder.result.id;
            } catch (error) {
                console.error('Error finding/creating folder:', error);
                throw error;
            }
        }

        async function saveStoryToDrive(story, parentFolderId) {
           try {
        // Tạo thư mục riêng cho truyện
        const storyFolderMetadata = {
            name: story.title,
            mimeType: 'application/vnd.google-apps.folder',
            parents: [parentFolderId]
        };

        const storyFolder = await gapi.client.drive.files.create({
            resource: storyFolderMetadata,
            fields: 'id'
        });

        const storyFolderId = storyFolder.result.id;

        // Tạo file mô tả
        const descriptionContent = `Tựa đề: ${story.title}\nMô tả: ${story.description}\nNguồn: ${story.source}\nNgày tạo: ${story.generatedAt}\nSố chương: ${story.chapters.length}\nTổng số từ: ${story.totalWords}`;
        await gapi.client.drive.files.create({
            resource: { name: 'Mô tả.txt', mimeType: 'text/plain', parents: [storyFolderId] },
            media: { mimeType: 'text/plain', body: descriptionContent },
            fields: 'id'
        });

        // Tạo từng chương
        for (let i = 0; i < story.chapters.length; i++) {
            const chapter = story.chapters[i];
            const content = `${chapter.title}\n\n${chapter.content}`;

            await gapi.client.drive.files.create({
                resource: { name: `Chương ${i+1}.txt`, mimeType: 'text/plain', parents: [storyFolderId] },
                media: { mimeType: 'text/plain', body: content },
                fields: 'id'
            });
        }

        return storyFolderId;
    } catch (error) {
        console.error('❌ Error saving story to drive:', error);
        throw error;
    }
        }

        function displayGeneratedStories() {
            const container = document.getElementById('generatedStories');
            
            if (!generatedStories || generatedStories.length === 0) {
                container.innerHTML = '<p>Chưa có truyện nào được tạo. Hãy bấm "Bắt đầu viết truyện" để bắt đầu.</p>';
                return;
            }
            
            let html = `<h4>📚 ${generatedStories.length} truyện đã được tạo</h4>`;
            
            generatedStories.forEach((story, index) => {
                html += `
                    <div class="analysis-result-item">
                        <h4>📖 ${story.title}</h4>
                        <p><strong>Nguồn:</strong> ${story.source}</p>
                        <p><strong>Thời gian:</strong> ${story.generatedAt}</p>
                        <p><strong>Số chương:</strong> ${story.chapters.length}</p>
                        <p><strong>Tổng số từ:</strong> ${story.totalWords}</p>
                        
                        <div class="toggle-container" onclick="toggleStoryDetails('story-${index}')">
                            <span>📄 Mô tả truyện</span>
                            <span>▼</span>
                        </div>
                        <div id="story-${index}" style="display:none;">
                            <p>${story.description}</p>
                            
                            <div class="toggle-container" onclick="toggleStoryChapter('story-${index}-chapter')">
                                <span>🔍 Xem chương mẫu</span>
                                <span>▼</span>
                            </div>
                            <div id="story-${index}-chapter" style="display:none;">
                                <div class="story-content">
                                    <div class="chapter-title">${story.chapters[0].title}</div>
                                    ${story.chapters[0].content.substring(0, 500)}...
                                </div>
                            </div>
                        </div>
                    </div>
                `;
            });
            
            container.innerHTML = html;
        }

        function toggleStoryDetails(id) {
            const element = document.getElementById(id);
            if (element.style.display === 'none') {
                element.style.display = 'block';
            } else {
                element.style.display = 'none';
            }
        }

        function toggleStoryChapter(id) {
            const element = document.getElementById(id);
            if (element.style.display === 'none') {
                element.style.display = 'block';
            } else {
                element.style.display = 'none';
            }
        }

        async function saveGeneratedStoriesCache() {
            try {
                const content = {
                    stories: generatedStories,
                    timestamp: new Date().toISOString()
                };
                
                const contentString = JSON.stringify(content);
                const media = {
                    mimeType: 'application/json',
                    body: contentString
                };
                
                // Kiểm tra xem file đã tồn tại chưa
                const response = await gapi.client.drive.files.list({
                    q: `name='${STORY_CACHE_NAME}' and trashed=false`,
                    fields: 'files(id)'
                });
                
                if (response.result.files.length > 0) {
                    // Cập nhật file đã tồn tại
                    await gapi.client.drive.files.update({
                        fileId: response.result.files[0].id,
                        media: media
                    });
                } else {
                    // Tạo file mới
                    const metadata = {
                        name: STORY_CACHE_NAME,
                        mimeType: 'application/json'
                    };
                    
                    await gapi.client.drive.files.create({
                        resource: metadata,
                        media: media,
                        fields: 'id'
                    });
                }
            } catch (error) {
                console.error('Error saving generated stories cache:', error);
            }
        }

        async function loadGeneratedStoriesCache() {
            try {
                const response = await gapi.client.drive.files.list({
                    q: `name='${STORY_CACHE_NAME}' and trashed=false`,
                    fields: 'files(id)'
                });
                
                if (response.result.files.length > 0) {
                    const storiesResponse = await gapi.client.drive.files.get({
                        fileId: response.result.files[0].id,
                        alt: 'media'
                    });
                    
                    const storiesContent = JSON.parse(storiesResponse.body);
                    generatedStories = storiesContent.stories;
                    
                    displayGeneratedStories();
                    return true;
                }
            } catch (error) {
                console.error('Error loading generated stories cache:', error);
            }
            
            return false;
        }

        // Load stories from library
        async function loadStories() {
           try {
        const folderId = await findOrCreateFolder('QuanLyTruyen');
        const response = await gapi.client.drive.files.list({
            q: `'${folderId}' in parents and mimeType='application/vnd.google-apps.folder' and trashed=false`,
            fields: 'files(id, name)',
            pageSize: 100
        });

        const stories = response.result.files;
        const container = document.getElementById('storiesLibrary');
        if (stories.length === 0) {
            container.innerHTML = "<p>❌ Chưa có truyện nào.</p>";
            return;
        }

        let html = "<ul>";
        stories.forEach(story => {
            html += `<li>
                <button class="btn" onclick="openStory('${story.id}','${story.name}')">📖 ${story.name}</button>
            </li>`;
        });
        html += "</ul>";
        container.innerHTML = html;
    } catch (error) {
        console.error("Error loading stories:", error);
        alert("❌ Lỗi khi tải thư viện truyện");
    }
        }

        function displayStoriesLibrary(stories) {
            const container = document.getElementById('storiesLibrary');
            
            if (!stories || stories.length === 0) {
                container.innerHTML = '<p>Chưa có truyện nào trong thư viện.</p>';
                return;
            }
            
            let html = `<h4>📚 ${stories.length} truyện trong thư viện</h4>`;
            
            stories.forEach(story => {
                const createdDate = new Date(story.createdTime).toLocaleDateString('vi-VN');
                const modifiedDate = new Date(story.modifiedTime).toLocaleDateString('vi-VN');
                
                html += `
                    <div class="analysis-result-item">
                        <h4>📖 ${story.name}</h4>
                        <p><strong>Ngày tạo:</strong> ${createdDate}</p>
                        <p><strong>Chỉnh sửa lần cuối:</strong> ${modifiedDate}</p>
                        <button class="btn btn-secondary" onclick="openStory('${story.id}')">
                            📖 Mở truyện
                        </button>
                    </div>
                `;
            });
            
            container.innerHTML = html;
        }

        async function openStory(folderId) {
            try {
                // Lấy danh sách file trong thư mục truyện
                const response = await gapi.client.drive.files.list({
                    q: `'${folderId}' in parents and trashed=false`,
                    fields: 'files(id, name, mimeType)'
                });
                
                const files = response.result.files;
                let storyContent = '';
                
                // Tìm file mô tả và các chương
                for (const file of files) {
                    if (file.name === 'Mô tả.txt') {
                        const descResponse = await gapi.client.drive.files.get({
                            fileId: file.id,
                            alt: 'media'
                        });
                        storyContent += `<h4>${descResponse.body}</h4>`;
                    } else if (file.name.startsWith('Chương') && file.name.endsWith('.txt')) {
                        const chapterResponse = await gapi.client.drive.files.get({
                            fileId: file.id,
                            alt: 'media'
                        });
                        storyContent += `<div class="story-content">${chapterResponse.body}</div>`;
                        break; // Chỉ hiển thị chương đầu tiên
                    }
                }
                
                // Hiển thị nội dung truyện
                const container = document.getElementById('storiesLibrary');
                container.innerHTML = `
                    <button class="btn" onclick="loadStories()">← Quay lại thư viện</button>
                    <div class="story-content">${storyContent}</div>
                `;
                
            } catch (error) {
                console.error('Error opening story:', error);
                updateStatus('❌ Lỗi khi mở truyện: ' + error.message);
            }
        }

        // Utility functions
        function updateStatus(message) {
            const statusElement = document.getElementById('statusInfo');
            if (statusElement) {
                statusElement.innerHTML = `<p>${message}</p>`;
            }
        }

        function updateDetailedStatus(message) {
            const detailedStatus = document.getElementById('detailedStatus');
            if (detailedStatus) {
                detailedStatus.textContent = message;
            }
        }

        function updateProgress(percentage) {
            const progressBar = document.getElementById('progressBar');
            if (progressBar) {
                progressBar.style.width = percentage + '%';
            }
        }

        function updateWriteStatus(message) {
            const writeStatus = document.getElementById('writeStatus');
            if (writeStatus) {
                writeStatus.textContent = message;
            }
        }

        function updateWriteDetailedStatus(message) {
            const writeDetailedStatus = document.getElementById('writeDetailedStatus');
            if (writeDetailedStatus) {
                writeDetailedStatus.textContent = message;
            }
        }

        function updateWriteProgress(percentage) {
            const writeProgressBar = document.getElementById('writeProgressBar');
            if (writeProgressBar) {
                writeProgressBar.style.width = percentage + '%';
            }
        }

        function clearCache() {
            if (confirm('Bạn có chắc muốn xóa tất cả dữ liệu tạm? Hành động này không thể hoàn tác.')) {
                localStorage.clear();
                updateStatus('🗑️ Đã xóa dữ liệu tạm');
                
                // Cũng xóa cache trên Google Drive
                deleteDriveCache();
            }
        }

        async function deleteDriveCache() {
            try {
                const cacheFiles = [CACHE_FILE_NAME, ANALYSIS_CACHE_NAME, STORY_CACHE_NAME];
                
                for (const fileName of cacheFiles) {
                    const response = await gapi.client.drive.files.list({
                        q: `name='${fileName}' and trashed=false`,
                        fields: 'files(id)'
                    });
                    
                    if (response.result.files.length > 0) {
                        await gapi.client.drive.files.delete({
                            fileId: response.result.files[0].id
                        });
                    }
                }
                
                updateStatus('🗑️ Đã xóa cache trên Google Drive');
            } catch (error) {
                console.error('Error deleting drive cache:', error);
            }
        }

        // Event listeners
        document.getElementById('sensitivityLevel').addEventListener('input', function() {
            document.getElementById('sensitivityValue').textContent = this.value;
        });

        // Initialize the app
        window.onload = function() {
            // Initialize Google APIs
            gapiLoaded();
            gisLoaded();
            
            // Try to load cached data
            setTimeout(() => {
                if (gapi_inited && gsi_inited) {
                    loadScanCache();
                    loadAnalysisData();
                    loadGeneratedStoriesCache();
                }
            }, 2000);
             showLoggedOutState(); // Khóa hết chức năng khi chưa login
             setupML5();
        };
        
        async function downloadScanCache() {
    if (!scanCache || !scanCache.files || scanCache.files.length === 0) {
        alert("Chưa có dữ liệu cache để tải xuống!");
        return;
    }

    try {
        const content = JSON.stringify(scanCache, null, 2);
        const blob = new Blob([content], { type: 'application/json' });
        const url = URL.createObjectURL(blob);

        const a = document.createElement('a');
        a.href = url;
        a.download = 'scan_cache_QuanLyTruyen.json';
        document.body.appendChild(a);
        a.click();

        setTimeout(() => {
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
        }, 100);

        updateStatus('✅ Đã tải xuống file cache danh sách quét');
    } catch (error) {
        console.error('Error downloading scan cache:', error);
        updateStatus('❌ Lỗi khi tải cache');
    }
}
// ==================== 📖 Trình đọc truyện từ Google Drive ====================
let currentChapters = [];
let currentIndex = 0;

async function openStory(storyId, storyName) {
    document.getElementById('readerTitle').innerText = "📖 " + storyName;
    document.getElementById('readerContainer').style.display = "block";
    
    const response = await gapi.client.drive.files.list({
        q: `'${storyId}' in parents and trashed=false and name contains 'Chương'`,
        fields: 'files(id, name)',
        orderBy: 'name'
    });

    currentChapters = response.result.files.sort((a,b) => a.name.localeCompare(b.name));
    currentIndex = 0;
    await loadChapter(currentIndex);
}

async function loadChapter(index) {
    if (index < 0 || index >= currentChapters.length) return;
    const fileId = currentChapters[index].id;
    const response = await gapi.client.drive.files.get({
        fileId: fileId,
        alt: 'media'
    });
    document.getElementById('readerContent').innerText = response.body;
}

async function nextChapter() {
    if (currentIndex < currentChapters.length - 1) {
        currentIndex++;
        await loadChapter(currentIndex);
    } else {
        alert("✅ Bạn đã đọc hết truyện!");
    }
}

async function prevChapter() {
    if (currentIndex > 0) {
        currentIndex--;
        await loadChapter(currentIndex);
    }
}
let textGenerator;

function setupML5() {
  // Load model charRNN (Shakespeare sample, bạn có thể train riêng sau)
  textGenerator = ml5.charRNN(
    "https://storage.googleapis.com/ml5-models/charRNN/shakespeare/",
    modelReady
  );
}

function modelReady() {
  console.log("✅ ml5.js model sẵn sàng để sinh văn bản!");
}
    </script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/ml5/0.12.2/ml5.min.js"></script>

</body>
</html>
