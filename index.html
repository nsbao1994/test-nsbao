<!DOCTYPE html>
<html lang="vi">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>AI Story Analyzer - Enhanced</title>
    <script src="https://apis.google.com/js/api.js"></script>
    <script src="https://accounts.google.com/gsi/client" async defer></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/tensorflow/4.10.0/tf.min.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
            background: #f5f5f7;
            color: #1d1d1f;
            overflow-x: hidden;
            padding-bottom: 80px;
        }

        .container {
            max-width: 100vw;
            margin: 0 auto;
            padding: 20px 16px;
        }

        /* Header */
        .header {
            text-align: center;
            padding: 20px 0 30px;
            background: linear-gradient(135deg, #007AFF 0%, #5856D6 100%);
            color: white;
            margin: -20px -16px 30px;
        }

        .header h1 {
            font-size: 24px;
            font-weight: 600;
            margin-bottom: 8px;
        }

        .header p {
            font-size: 14px;
            opacity: 0.9;
        }

        /* Login Screen */
        .login-screen {
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            min-height: 60vh;
            text-align: center;
            padding: 40px 20px;
        }

        .login-icon {
            font-size: 80px;
            margin-bottom: 30px;
        }

        .login-title {
            font-size: 28px;
            font-weight: 700;
            margin-bottom: 10px;
            color: #1d1d1f;
        }

        .login-subtitle {
            font-size: 16px;
            color: #8e8e93;
            margin-bottom: 40px;
            line-height: 1.4;
        }

        /* Buttons */
        .btn {
            background: #007AFF;
            color: white;
            border: none;
            padding: 16px 32px;
            border-radius: 12px;
            font-size: 16px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s ease;
            min-height: 50px;
            display: inline-flex;
            align-items: center;
            gap: 8px;
        }

        .btn:hover {
            background: #0056d3;
        }

        .btn:disabled {
            background: #c7c7cc;
            cursor: not-allowed;
        }

        .btn-secondary {
            background: #8e8e93;
        }

        .btn-success {
            background: #34c759;
        }

        .btn-danger {
            background: #ff3b30;
        }

        .btn-warning {
            background: #ff9500;
        }

        /* Main Content */
        .main-content {
            display: none;
        }

        .section {
            background: white;
            border-radius: 16px;
            padding: 20px;
            margin-bottom: 20px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
        }

        .section h2 {
            font-size: 20px;
            font-weight: 600;
            margin-bottom: 16px;
            color: #1d1d1f;
        }

        /* Status */
        .status {
            padding: 12px 16px;
            border-radius: 12px;
            margin: 12px 0;
            font-weight: 500;
            font-size: 14px;
        }

        .status.success {
            background: #d1f2eb;
            color: #0c7c59;
        }

        .status.error {
            background: #fadbd8;
            color: #c0392b;
        }

        .status.info {
            background: #d6eaf8;
            color: #2874a6;
        }

        .status.warning {
            background: #fcf3cf;
            color: #b7950b;
        }

        /* File List */
        .file-list {
            max-height: 300px;
            overflow-y: auto;
            background: #f8f9fa;
            border-radius: 12px;
            padding: 12px;
            margin: 12px 0;
        }

        .file-folder {
            margin-bottom: 16px;
        }

        .folder-header {
            background: #e9ecef;
            padding: 8px 12px;
            border-radius: 8px;
            font-weight: 600;
            font-size: 14px;
            margin-bottom: 8px;
        }

        .file-item {
            padding: 8px 12px;
            margin-left: 16px;
            margin-bottom: 4px;
            font-size: 13px;
            color: #6c757d;
        }

        /* Progress */
        .progress {
            width: 100%;
            height: 8px;
            background: #f0f0f0;
            border-radius: 4px;
            overflow: hidden;
            margin: 12px 0;
        }

        .progress-fill {
            height: 100%;
            background: linear-gradient(90deg, #34c759, #30d158);
            width: 0%;
            transition: width 0.3s ease;
        }

        /* Analysis Results */
        .stats-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 12px;
            margin: 16px 0;
        }

        .stat-card {
            background: #f8f9fa;
            padding: 16px;
            border-radius: 12px;
            text-align: center;
        }

        .stat-number {
            font-size: 24px;
            font-weight: 700;
            color: #007AFF;
            display: block;
        }

        .stat-label {
            font-size: 12px;
            color: #8e8e93;
            margin-top: 4px;
        }

        /* Advanced Analysis */
        .analysis-detail {
            background: #f8f9fa;
            border-radius: 12px;
            padding: 16px;
            margin: 16px 0;
        }

        .analysis-item {
            margin-bottom: 12px;
            padding: 8px;
            border-left: 4px solid #007AFF;
            background: white;
            border-radius: 0 8px 8px 0;
        }

        .analysis-item h4 {
            font-size: 14px;
            font-weight: 600;
            color: #1d1d1f;
            margin-bottom: 4px;
        }

        .analysis-item p {
            font-size: 13px;
            color: #6c757d;
            line-height: 1.4;
        }

        /* Story Generation */
        .story-output {
            background: #f8f9fa;
            border-radius: 12px;
            padding: 16px;
            margin: 16px 0;
            font-size: 15px;
            line-height: 1.6;
        }

        .chapter {
            margin-bottom: 24px;
            padding-bottom: 16px;
            border-bottom: 1px solid #e5e5ea;
        }

        .chapter:last-child {
            border-bottom: none;
        }

        .chapter-title {
            font-weight: 600;
            color: #1d1d1f;
            margin-bottom: 8px;
        }

        .chapter-meta {
            font-size: 12px;
            color: #8e8e93;
            margin-bottom: 12px;
        }

        /* Bottom Navigation */
        .bottom-nav {
            position: fixed;
            bottom: 0;
            left: 0;
            right: 0;
            background: white;
            border-top: 1px solid #e5e5ea;
            padding: 8px 0 24px;
            z-index: 100;
            display: none;
        }

        .nav-items {
            display: flex;
            justify-content: space-around;
            align-items: center;
            max-width: 100vw;
            margin: 0 auto;
        }

        .nav-item {
            display: flex;
            flex-direction: column;
            align-items: center;
            padding: 8px 16px;
            cursor: pointer;
            transition: all 0.2s ease;
            flex: 1;
            min-width: 0;
        }

        .nav-item.active {
            color: #007AFF;
        }

        .nav-icon {
            font-size: 24px;
            margin-bottom: 4px;
        }

        .nav-label {
            font-size: 11px;
            font-weight: 500;
        }

        /* Tab Content */
        .tab-content {
            display: none;
        }

        .tab-content.active {
            display: block;
        }

        /* Loading */
        .loading {
            display: inline-block;
            width: 20px;
            height: 20px;
            border: 2px solid #f3f3f3;
            border-top: 2px solid #007AFF;
            border-radius: 50%;
            animation: spin 1s linear infinite;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        /* Data Management */
        .data-status {
            background: #e8f4fd;
            border: 1px solid #bee5eb;
            border-radius: 8px;
            padding: 12px;
            margin: 12px 0;
            font-size: 14px;
        }

        .data-actions {
            display: flex;
            gap: 8px;
            flex-wrap: wrap;
            margin-top: 12px;
        }

        /* Input Fields */
        .form-group {
            margin-bottom: 16px;
        }

        .form-label {
            display: block;
            margin-bottom: 8px;
            font-weight: 600;
            color: #1d1d1f;
        }

        .form-input {
            width: 100%;
            padding: 12px;
            border: 1px solid #d1d1d6;
            border-radius: 8px;
            font-size: 16px;
        }

        /* Responsive adjustments */
        @media (max-width: 375px) {
            .container {
                padding: 16px 12px;
            }
            
            .stats-grid {
                grid-template-columns: 1fr;
            }
            
            .data-actions {
                flex-direction: column;
            }
        }

        /* Hide elements */
        .hidden {
            display: none !important;
        }
    </style>
</head>
<body>
    <div class="container">
        <!-- Header -->
        <div class="header">
            <h1>ü§ñ AI Story Analyzer Pro</h1>
            <p>Ph√¢n t√≠ch chuy√™n s√¢u v√† t·∫°o truy·ªán v·ªõi AI</p>
        </div>

        <!-- Login Screen -->
        <div id="loginScreen" class="login-screen">
            <div class="login-icon">üì±</div>
            <h2 class="login-title">Ch√†o m·ª´ng!</h2>
            <p class="login-subtitle">ƒêƒÉng nh·∫≠p ƒë·ªÉ b·∫Øt ƒë·∫ßu ph√¢n t√≠ch v√† t·∫°o truy·ªán v·ªõi AI chuy√™n nghi·ªáp</p>
            <button id="loginBtn" class="btn">
                <span>üîê ƒêƒÉng nh·∫≠p Google Drive</span>
            </button>
        </div>

        <!-- Main Content -->
        <div id="mainContent" class="main-content">
            <!-- Status -->
            <div id="status" class="status hidden"></div>

            <!-- Files Tab -->
            <div id="tabFiles" class="tab-content active">
                <div class="section">
                    <h2>üìÅ File Truy·ªán</h2>
                    
                    <div class="data-status">
                        <strong>Tr·∫°ng th√°i d·ªØ li·ªáu:</strong> <span id="dataStatus">Ch∆∞a t·∫£i</span><br>
                        <strong>L·∫ßn c·∫≠p nh·∫≠t cu·ªëi:</strong> <span id="lastUpdate">Ch∆∞a c√≥</span>
                    </div>
                    
                    <div class="data-actions">
                        <button id="loadFilesBtn" class="btn">üì• T·∫£i Files</button>
                        <button id="loadCacheBtn" class="btn btn-secondary">üîÑ T·∫£i Cache</button>
                        <button id="clearCacheBtn" class="btn btn-warning">üóëÔ∏è X√≥a Cache</button>
                    </div>
                    
                    <div id="fileList" class="file-list">
                        <p style="text-align: center; color: #8e8e93; padding: 20px;">
                            Nh·∫•n "T·∫£i Files" ƒë·ªÉ xem danh s√°ch truy·ªán
                        </p>
                    </div>
                </div>
            </div>

            <!-- Analysis Tab -->
            <div id="tabAnalysis" class="tab-content">
                <div class="section">
                    <h2>üîç Ph√¢n T√≠ch AI Chuy√™n S√¢u</h2>
                    <button id="analyzeBtn" class="btn btn-success">üß† Ph√¢n T√≠ch Chuy√™n S√¢u</button>
                    
                    <div id="progressSection" class="hidden">
                        <div class="progress">
                            <div id="progressFill" class="progress-fill"></div>
                        </div>
                        <p id="progressText" style="font-size: 14px; color: #8e8e93; text-align: center;"></p>
                    </div>

                    <div id="analysisResults" class="hidden">
                        <h3 style="margin: 20px 0 12px;">üìä Th·ªëng K√™ C∆° B·∫£n</h3>
                        <div class="stats-grid">
                            <div class="stat-card">
                                <span id="totalStories" class="stat-number">0</span>
                                <div class="stat-label">Truy·ªán</div>
                            </div>
                            <div class="stat-card">
                                <span id="totalWords" class="stat-number">0</span>
                                <div class="stat-label">T·ª´</div>
                            </div>
                            <div class="stat-card">
                                <span id="totalFolders" class="stat-number">0</span>
                                <div class="stat-label">Th∆∞ m·ª•c</div>
                            </div>
                            <div class="stat-card">
                                <span id="vocabularySize" class="stat-number">0</span>
                                <div class="stat-label">T·ª´ v·ª±ng</div>
                            </div>
                        </div>
                        
                        <h3 style="margin: 20px 0 12px;">üéØ Ph√¢n T√≠ch Chuy√™n S√¢u</h3>
                        <div id="detailedAnalysis" class="analysis-detail"></div>
                        
                        <button id="trainBtn" class="btn btn-success" disabled>üéì Hu·∫•n Luy·ªán AI</button>
                        <button id="saveAnalysisBtn" class="btn btn-secondary">üíæ L∆∞u Ph√¢n T√≠ch</button>
                    </div>
                </div>
            </div>

            <!-- Generation Tab -->
            <div id="tabGenerate" class="tab-content">
                <div class="section">
                    <h2>‚úçÔ∏è T·∫°o Truy·ªán</h2>
                    
                    <div class="form-group">
                        <label class="form-label">S·ªë ch∆∞∆°ng t·ªëi thi·ªÉu:</label>
                        <input type="number" id="chapterCount" class="form-input" value="50" min="10" max="200">
                    </div>
                    
                    <div class="form-group">
                        <label class="form-label">Th·ªÉ lo·∫°i:</label>
                        <select id="genreSelect" class="form-input">
                            <option value="fantasy">Huy·ªÅn Huy·ªÖn</option>
                            <option value="romance">L√£ng M·∫°n</option>
                            <option value="adventure">Phi√™u L∆∞u</option>
                            <option value="mystery">B√≠ ·∫®n</option>
                            <option value="historical">L·ªãch S·ª≠</option>
                        </select>
                    </div>

                    <button id="generateBtn" class="btn btn-success" disabled>üöÄ T·∫°o Truy·ªán</button>
                    
                    <div id="generationProgress" class="hidden">
                        <div class="progress">
                            <div id="generationProgressFill" class="progress-fill"></div>
                        </div>
                        <p id="generationProgressText" style="font-size: 14px; color: #8e8e93; text-align: center;"></p>
                    </div>

                    <div id="storyOutput" class="story-output hidden">
                        <h3 style="margin-bottom: 16px;">üìñ Truy·ªán M·ªõi</h3>
                        <div id="storyContent"></div>
                        <div style="margin-top: 16px;">
                            <button id="uploadBtn" class="btn btn-success hidden">‚òÅÔ∏è T·∫£i l√™n Drive</button>
                            <button id="downloadBtn" class="btn btn-secondary hidden">üìÑ T·∫£i xu·ªëng</button>
                        </div>
                    </div>
                </div>
            </div>

            <!-- Settings Tab -->
            <div id="tabSettings" class="tab-content">
                <div class="section">
                    <h2>‚öôÔ∏è C√†i ƒê·∫∑t</h2>
                    <div style="margin-bottom: 16px;">
                        <p><strong>Tr·∫°ng th√°i:</strong> <span id="connectionStatus">ƒê√£ k·∫øt n·ªëi</span></p>
                        <p><strong>M√¥ h√¨nh AI:</strong> <span id="modelStatus">Ch∆∞a s·∫µn s√†ng</span></p>
                        <p><strong>B·ªô nh·ªõ cache:</strong> <span id="cacheStatus">Kh√¥ng c√≥</span></p>
                    </div>
                    
                    <div class="data-actions">
                        <button id="exportDataBtn" class="btn btn-secondary">üì§ Xu·∫•t D·ªØ Li·ªáu</button>
                        <button id="importDataBtn" class="btn btn-secondary">üì• Nh·∫≠p D·ªØ Li·ªáu</button>
                        <button id="logoutBtn" class="btn btn-danger">üö™ ƒêƒÉng xu·∫•t</button>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- Bottom Navigation -->
    <div id="bottomNav" class="bottom-nav">
        <div class="nav-items">
            <div class="nav-item active" data-tab="Files">
                <div class="nav-icon">üìÅ</div>
                <div class="nav-label">Files</div>
            </div>
            <div class="nav-item" data-tab="Analysis">
                <div class="nav-icon">üîç</div>
                <div class="nav-label">Ph√¢n t√≠ch</div>
            </div>
            <div class="nav-item" data-tab="Generate">
                <div class="nav-icon">‚úçÔ∏è</div>
                <div class="nav-label">T·∫°o truy·ªán</div>
            </div>
            <div class="nav-item" data-tab="Settings">
                <div class="nav-icon">‚öôÔ∏è</div>
                <div class="nav-label">C√†i ƒë·∫∑t</div>
            </div>
        </div>
    </div>

    <script>
        // Configuration
        const CLIENT_ID = '398509518475-7bjid324tkuuh9gv8b0g92lhsgv8nrl5.apps.googleusercontent.com';
        const API_KEY = 'AIzaSyAbcWr0UPvC4YpsunE6uAa7E5pan9iys2o';
        const DISCOVERY_DOC = 'https://www.googleapis.com/discovery/v1/apis/drive/v3/rest';
        const SCOPES = 'https://www.googleapis.com/auth/drive';
        const CACHE_FILE_NAME = 'ai_story_cache.json';
        const ANALYSIS_FILE_NAME = 'story_analysis.json';

        // Global variables
        let tokenClient;
        let gapiInited = false;
        let gisInited = false;
        let storyFiles = [];
        let analyzedFiles = new Set();
        let storyData = [];
        let aiModel = null;
        let vocabulary = {};
        let currentStory = null;
        let storyPatterns = {};
        let characterAnalysis = {};
        let plotStructure = {};
        let narrativeStyle = {};

        // Utility functions
        function log(message, data = '') {
            console.log(`[AI Story Pro] ${message}`, data);
        }

        function showStatus(message, type = 'info') {
            const status = document.getElementById('status');
            status.textContent = message;
            status.className = `status ${type}`;
            status.classList.remove('hidden');
            
            setTimeout(() => {
                status.classList.add('hidden');
            }, type === 'error' ? 8000 : 5000);
        }

        function formatNumber(num) {
            return new Intl.NumberFormat('vi-VN').format(num);
        }

        function updateDataStatus(status, lastUpdate = null) {
            document.getElementById('dataStatus').textContent = status;
            if (lastUpdate) {
                document.getElementById('lastUpdate').textContent = lastUpdate.toLocaleString('vi-VN');
            }
        }

        // Tab navigation
        function initNavigation() {
            const navItems = document.querySelectorAll('.nav-item');
            const tabContents = document.querySelectorAll('.tab-content');

            navItems.forEach(item => {
                item.addEventListener('click', () => {
                    const tabName = item.getAttribute('data-tab');
                    
                    navItems.forEach(nav => nav.classList.remove('active'));
                    item.classList.add('active');
                    
                    tabContents.forEach(content => {
                        content.classList.remove('active');
                    });
                    document.getElementById(`tab${tabName}`).classList.add('active');
                });
            });
        }

        // Google API initialization
        function gapiLoaded() {
            log('GAPI loaded');
            gapi.load('client', initializeGapiClient);
        }

        async function initializeGapiClient() {
            try {
                await gapi.client.init({
                    apiKey: API_KEY,
                    discoveryDocs: [DISCOVERY_DOC],
                });
                gapiInited = true;
                log('GAPI initialized');
                maybeEnableLogin();
            } catch (error) {
                log('GAPI init error:', error);
                showStatus('L·ªói kh·ªüi t·∫°o API', 'error');
            }
        }

        function gisLoaded() {
            try {
                tokenClient = google.accounts.oauth2.initTokenClient({
                    client_id: CLIENT_ID,
                    scope: SCOPES,
                    callback: handleAuthCallback,
                });
                gisInited = true;
                log('GIS initialized');
                maybeEnableLogin();
            } catch (error) {
                log('GIS init error:', error);
                showStatus('L·ªói kh·ªüi t·∫°o x√°c th·ª±c', 'error');
            }
        }

        function maybeEnableLogin() {
            if (gapiInited && gisInited) {
                document.getElementById('loginBtn').disabled = false;
                log('Login ready');
            }
        }

        // Authentication
        function handleAuthCallback(resp) {
            if (resp.error) {
                showStatus(`L·ªói ƒëƒÉng nh·∫≠p: ${resp.error}`, 'error');
                return;
            }
            
            showStatus('ƒêƒÉng nh·∫≠p th√†nh c√¥ng!', 'success');
            showMainContent();
            loadCachedData();
        }

        function showMainContent() {
            document.getElementById('loginScreen').style.display = 'none';
            document.getElementById('mainContent').style.display = 'block';
            document.getElementById('bottomNav').style.display = 'block';
            document.getElementById('connectionStatus').textContent = 'ƒê√£ k·∫øt n·ªëi';
        }

        // Cache Management
        async function loadCachedData() {
            try {
                showStatus('ƒêang t·∫£i d·ªØ li·ªáu cache...', 'info');
                
                const cacheFile = await findFile(CACHE_FILE_NAME);
                if (cacheFile) {
                    const cacheContent = await downloadFile(cacheFile.id);
                    const cache = JSON.parse(cacheContent);
                    
                    storyFiles = cache.storyFiles || [];
                    analyzedFiles = new Set(cache.analyzedFiles || []);
                    storyData = cache.storyData || [];
                    vocabulary = cache.vocabulary || {};
                    storyPatterns = cache.storyPatterns || {};
                    characterAnalysis = cache.characterAnalysis || {};
                    plotStructure = cache.plotStructure || {};
                    narrativeStyle = cache.narrativeStyle || {};
                    
                    updateDataStatus('ƒê√£ t·∫£i t·ª´ cache', new Date(cache.lastUpdate));
                    displayFiles();
                    document.getElementById('cacheStatus').textContent = 'C√≥ s·∫µn';
                    
                    if (storyData.length > 0) {
                        showAnalysisResults();
                        document.getElementById('generateBtn').disabled = false;
                    }
                    
                    showStatus('ƒê√£ t·∫£i d·ªØ li·ªáu cache', 'success');
                } else {
                    updateDataStatus('Kh√¥ng c√≥ cache');
                    document.getElementById('cacheStatus').textContent = 'Kh√¥ng c√≥';
                }
            } catch (error) {
                log('Load cache error:', error);
                showStatus('L·ªói t·∫£i cache', 'warning');
            }
        }

        async function saveCacheData() {
            try {
                const cacheData = {
                    storyFiles,
                    analyzedFiles: Array.from(analyzedFiles),
                    storyData,
                    vocabulary,
                    storyPatterns,
                    characterAnalysis,
                    plotStructure,
                    narrativeStyle,
                    lastUpdate: new Date().toISOString()
                };

                await saveFileToRoot(CACHE_FILE_NAME, JSON.stringify(cacheData, null, 2));
                updateDataStatus('ƒê√£ l∆∞u cache', new Date());
                document.getElementById('cacheStatus').textContent = 'C√≥ s·∫µn';
                log('Cache saved successfully');
            } catch (error) {
                log('Save cache error:', error);
                showStatus('L·ªói l∆∞u cache', 'error');
            }
        }

        async function clearCache() {
            try {
                const cacheFile = await findFile(CACHE_FILE_NAME);
                if (cacheFile) {
                    await gapi.client.drive.files.delete({
                        fileId: cacheFile.id
                    });
                }
                
                // Reset data
                storyFiles = [];
                analyzedFiles = new Set();
                storyData = [];
                vocabulary = {};
                storyPatterns = {};
                characterAnalysis = {};
                plotStructure = {};
                narrativeStyle = {};
                
                updateDataStatus('Cache ƒë√£ x√≥a');
                document.getElementById('cacheStatus').textContent = 'Kh√¥ng c√≥';
                document.getElementById('fileList').innerHTML = '<p style="text-align: center; color: #8e8e93; padding: 20px;">Cache ƒë√£ ƒë∆∞·ª£c x√≥a</p>';
                document.getElementById('analysisResults').classList.add('hidden');
                
                showStatus('ƒê√£ x√≥a cache', 'success');
            } catch (error) {
                log('Clear cache error:', error);
                showStatus('L·ªói x√≥a cache', 'error');
            }
        }

        // File operations
        async function findFile(fileName) {
            try {
                const response = await gapi.client.drive.files.list({
                    q: `name='${fileName}' and trashed=false`,
                    fields: 'files(id, name, modifiedTime)'
                });
                return response.result.files[0] || null;
            } catch (error) {
                log(`Find file error for ${fileName}:`, error);
                return null;
            }
        }

        async function saveFileToRoot(fileName, content) {
            const existingFile = await findFile(fileName);
            
            if (existingFile) {
                // Update existing file
                await gapi.client.request({
                    path: `https://www.googleapis.com/upload/drive/v3/files/${existingFile.id}`,
                    method: 'PATCH',
                    params: { uploadType: 'media' },
                    headers: { 'Content-Type': 'application/json' },
                    body: content
                });
            } else {
                // Create new file
                const fileMetadata = { name: fileName };
                await gapi.client.request({
                    path: 'https://www.googleapis.com/upload/drive/v3/files',
                    method: 'POST',
                    params: { uploadType: 'multipart' },
                    headers: { 'Content-Type': 'multipart/related; boundary="foo_bar_baz"' },
                    body: createMultipartBody(fileMetadata, content)
                });
            }
        }

        async function loadFiles() {
            try {
                showStatus('ƒêang t·∫£i danh s√°ch file...', 'info');
                
                const folderResponse = await gapi.client.drive.files.list({
                    q: "name='QuanLyTruyen' and mimeType='application/vnd.google-apps.folder' and trashed=false",
                    fields: 'files(id, name)',
                });

                if (folderResponse.result.files.length === 0) {
                    showStatus('Kh√¥ng t√¨m th·∫•y th∆∞ m·ª•c "QuanLyTruyen"', 'warning');
                    return;
                }

                const mainFolderId = folderResponse.result.files[0].id;
                const allFolders = await getAllSubfolders(mainFolderId);
                allFolders.unshift({ id: mainFolderId, name: 'QuanLyTruyen', path: 'QuanLyTruyen' });

                storyFiles = [];
                for (const folder of allFolders) {
                    const files = await getFilesFromFolder(folder.id, folder.path);
                    storyFiles.push(...files);
                }

                displayFiles();
                updateDataStatus(`${storyFiles.length} files ƒë√£ t·∫£i`, new Date());
                showStatus(`T√¨m th·∫•y ${storyFiles.length} file`, 'success');
                
                // Auto save to cache
                await saveCacheData();
                
            } catch (error) {
                log('Load files error:', error);
                showStatus('L·ªói t·∫£i file', 'error');
            }
        }

        async function getAllSubfolders(parentId, basePath = '') {
            const response = await gapi.client.drive.files.list({
                q: `'${parentId}' in parents and mimeType='application/vnd.google-apps.folder' and trashed=false`,
                fields: 'files(id, name)',
            });

            let folders = response.result.files.map(folder => ({
                id: folder.id,
                name: folder.name,
                path: basePath ? `${basePath}/${folder.name}` : folder.name
            }));

            for (const folder of folders) {
                const subfolders = await getAllSubfolders(folder.id, folder.path);
                folders.push(...subfolders);
            }

            return folders;
        }

        async function getFilesFromFolder(folderId, folderPath) {
            const response = await gapi.client.drive.files.list({
                q: `'${folderId}' in parents and name contains '.txt' and trashed=false`,
                fields: 'files(id, name, size, modifiedTime)',
            });

            return response.result.files.map(file => ({
                ...file,
                folderPath,
                isAnalyzed: analyzedFiles.has(file.id)
            }));
        }

        function displayFiles() {
            const fileList = document.getElementById('fileList');
            
            if (storyFiles.length === 0) {
                fileList.innerHTML = '<p style="text-align: center; color: #8e8e93; padding: 20px;">Kh√¥ng c√≥ file n√†o</p>';
                return;
            }

            const filesByFolder = {};
            storyFiles.forEach(file => {
                if (!filesByFolder[file.folderPath]) {
                    filesByFolder[file.folderPath] = [];
                }
                filesByFolder[file.folderPath].push(file);
            });

            let html = '';
            Object.keys(filesByFolder).sort().forEach(folderPath => {
                const files = filesByFolder[folderPath];
                const analyzedCount = files.filter(f => f.isAnalyzed).length;
                
                html += `
                    <div class="file-folder">
                        <div class="folder-header">
                            üìÅ ${folderPath} 
                            <span style="font-size: 12px; color: #8e8e93;">
                                (${files.length} files, ${analyzedCount} analyzed)
                            </span>
                        </div>
                        ${files.map(file => `
                            <div class="file-item ${file.isAnalyzed ? 'analyzed' : ''}">
                                üìÑ ${file.name} ${file.isAnalyzed ? '‚úÖ' : ''}
                            </div>
                        `).join('')}
                    </div>
                `;
            });

            fileList.innerHTML = html;
        }

        // Enhanced AI Analysis
        async function analyzeStories() {
            if (storyFiles.length === 0) {
                showStatus('Ch∆∞a c√≥ file ƒë·ªÉ ph√¢n t√≠ch', 'error');
                return;
            }

            const unanalyzedFiles = storyFiles.filter(file => !analyzedFiles.has(file.id));
            if (unanalyzedFiles.length === 0) {
                showStatus('T·∫•t c·∫£ file ƒë√£ ƒë∆∞·ª£c ph√¢n t√≠ch', 'info');
                return;
            }

            document.getElementById('analyzeBtn').disabled = true;
            document.getElementById('progressSection').classList.remove('hidden');
            
            try {
                // Initialize analysis objects
                storyPatterns = {
                    openingPatterns: {},
                    dialoguePatterns: {},
                    descriptivePatterns: {},
                    plotProgression: []
                };
                
                characterAnalysis = {
                    characterNames: new Set(),
                    characterTraits: {},
                    relationshipPatterns: {}
                };
                
                plotStructure = {
                    chapterStructures: [],
                    conflictTypes: {},
                    resolutionPatterns: {}
                };
                
                narrativeStyle = {
                    sentenceStructure: {},
                    vocabularyDistribution: {},
                    emotionalTone: {}
                };

                for (let i = 0; i < unanalyzedFiles.length; i++) {
                    const file = unanalyzedFiles[i];
                    const progress = ((i + 1) / unanalyzedFiles.length) * 100;
                    
                    document.getElementById('progressFill').style.width = `${progress}%`;
                    document.getElementById('progressText').textContent = 
                        `ƒêang ph√¢n t√≠ch chuy√™n s√¢u: ${file.name} (${i + 1}/${unanalyzedFiles.length})`;
                    
                    const content = await downloadFile(file.id);
                    if (content && content.trim()) {
                        const basicAnalysis = analyzeText(content);
                        const advancedAnalysis = await performAdvancedAnalysis(content, file.name);
                        
                        storyData.push({
                            fileId: file.id,
                            name: file.name,
                            folderPath: file.folderPath,
                            content: content,
                            analysis: basicAnalysis,
                            advancedAnalysis: advancedAnalysis
                        });
                        
                        analyzedFiles.add(file.id);
                        
                        // Update patterns and structures
                        updateStoryPatterns(content, advancedAnalysis);
                        updateCharacterAnalysis(content, advancedAnalysis);
                        updatePlotStructure(content, advancedAnalysis);
                        updateNarrativeStyle(content, advancedAnalysis);
                    }
                    
                    // Small delay for UI responsiveness
                    await new Promise(resolve => setTimeout(resolve, 50));
                }

                await buildAdvancedVocabulary();
                showAnalysisResults();
                
                // Update file display
                storyFiles.forEach(file => {
                    file.isAnalyzed = analyzedFiles.has(file.id);
                });
                displayFiles();
                
                // Save analysis and cache
                await saveAnalysisData();
                await saveCacheData();
                
                showStatus('Ph√¢n t√≠ch chuy√™n s√¢u ho√†n th√†nh!', 'success');
                
            } catch (error) {
                log('Analysis error:', error);
                showStatus('L·ªói ph√¢n t√≠ch', 'error');
            } finally {
                document.getElementById('analyzeBtn').disabled = false;
                document.getElementById('progressSection').classList.add('hidden');
            }
        }

        async function downloadFile(fileId) {
            try {
                const response = await gapi.client.drive.files.get({
                    fileId: fileId,
                    alt: 'media'
                });
                return response.body;
            } catch (error) {
                log(`Download error for ${fileId}:`, error);
                return '';
            }
        }

        function analyzeText(text) {
            const words = text.toLowerCase().match(/\b\w+\b/g) || [];
            const sentences = text.split(/[.!?]+/).filter(s => s.trim());
            const paragraphs = text.split(/\n\s*\n/).filter(p => p.trim());
            
            return {
                wordCount: words.length,
                sentenceCount: sentences.length,
                paragraphCount: paragraphs.length,
                uniqueWords: new Set(words).size,
                avgWordsPerSentence: words.length / sentences.length || 0,
                readabilityScore: calculateReadabilityScore(sentences, words)
            };
        }

        async function performAdvancedAnalysis(content, fileName) {
            // Simulate AI processing time
            await new Promise(resolve => setTimeout(resolve, 100));
            
            const sentences = content.split(/[.!?]+/).filter(s => s.trim());
            const paragraphs = content.split(/\n\s*\n/).filter(p => p.trim());
            const words = content.toLowerCase().match(/\b\w+\b/g) || [];
            
            return {
                // Character Analysis
                characters: extractCharacters(content),
                emotions: analyzeEmotions(content),
                
                // Plot Analysis
                plotPoints: identifyPlotPoints(content),
                conflicts: identifyConflicts(content),
                themes: extractThemes(content),
                
                // Style Analysis
                narrative: analyzeNarrativeTechnique(content),
                dialogue: analyzeDialogue(content),
                descriptions: analyzeDescriptions(content),
                
                // Structure Analysis
                pacing: analyzePacing(sentences),
                transitions: analyzeTransitions(paragraphs),
                
                // Language Analysis
                complexity: analyzeLanguageComplexity(words, sentences),
                tone: analyzeTone(content),
                genre: predictGenre(content)
            };
        }

        function extractCharacters(content) {
            // Simple character extraction based on proper nouns and dialogue
            const characters = new Set();
            const namePattern = /\b[A-Z√Å√Ä·∫¢√É·∫†·∫§·∫¶·∫¨·∫®·∫™·∫Æ·∫∞·∫∂·∫≤·∫¥√ì√í·ªé√ï·ªå·ªê·ªí·ªò·ªî·ªñ·ª¢·ªö·ªú·ªû·ª†∆Ø·ª®·ª™·ª¨·ªÆ·ª∞√â√à·∫∫·∫º·∫∏·∫æ·ªÄ·ªÇ·ªÑ·ªÜ√ç√å·ªàƒ®·ªä√ù·ª≤·ª∂·ª∏·ª¥√ö√ô·ª¶≈®·ª§·ªê·ªí·ªò·ªî·ªñ][a-z√°√†·∫£√£·∫°·∫•·∫ß·∫≠·∫©·∫´·∫Ø·∫±·∫∑·∫≥·∫µ√≥√≤·ªè√µ·ªç·ªë·ªì·ªô·ªï·ªó·ª£·ªõ·ªù·ªü·ª°∆°∆∞·ª©·ª´·ª≠·ªØ·ª±√©√®·∫ª·∫Ω·∫π·∫ø·ªÅ·ªÉ·ªÖ·ªá√≠√¨·ªâƒ©·ªã√Ω·ª≥·ª∑·ªπ·ªµ√∫√π·ªß≈©·ª•]+\b/g;
            const matches = content.match(namePattern) || [];
            
            matches.forEach(match => {
                if (match.length > 2 && !commonWords.includes(match.toLowerCase())) {
                    characters.add(match);
                }
            });
            
            return Array.from(characters).slice(0, 20); // Top 20 potential characters
        }

        function analyzeEmotions(content) {
            const emotionKeywords = {
                joy: ['vui', 'h·∫°nh ph√∫c', 'vui s∆∞·ªõng', 'h√¢n hoan', 'ph·∫•n kh√≠ch'],
                sadness: ['bu·ªìn', 'th∆∞∆°ng', 'ƒëau kh·ªï', 'kh√≥c', 'tang th∆∞∆°ng'],
                anger: ['gi·∫≠n', 't·ª©c gi·∫≠n', 'ph·∫´n n·ªô', 'c√°u k·ªânh', 'b·ª±c t·ª©c'],
                fear: ['s·ª£', 'kinh h√£i', 'lo l·∫Øng', 'ho·∫£ng s·ª£', 'e ng·∫°i'],
                surprise: ['ng·∫°c nhi√™n', 'b·∫•t ng·ªù', 'kinh ng·∫°c', 's·ª≠ng s·ªët', 'cho√°ng v√°ng']
            };
            
            const emotions = {};
            Object.keys(emotionKeywords).forEach(emotion => {
                let count = 0;
                emotionKeywords[emotion].forEach(keyword => {
                    const regex = new RegExp(keyword, 'gi');
                    const matches = content.match(regex);
                    if (matches) count += matches.length;
                });
                emotions[emotion] = count;
            });
            
            return emotions;
        }

        function identifyPlotPoints(content) {
            const plotIndicators = {
                exposition: ['b·∫Øt ƒë·∫ßu', 'kh·ªüi ƒë·∫ßu', 'ng√†y x∆∞a', 'c√≥ m·ªôt l·∫ßn'],
                risingAction: ['sau ƒë√≥', 'r·ªìi th√¨', 'b·∫•t ng·ªù', 'ƒë·ªôt nhi√™n'],
                climax: ['cu·ªëi c√πng', 'quy·∫øt ƒë·ªãnh', 'tr·∫≠n chi·∫øn', 'ƒë·ªëi m·∫∑t'],
                fallingAction: ['k·∫øt qu·∫£', 'h·∫≠u qu·∫£', 't·ª´ ƒë√≥'],
                resolution: ['k·∫øt th√∫c', 'cu·ªëi c√πng', 'v√† th·∫ø l√†', 'h·∫°nh ph√∫c']
            };
            
            const plotPoints = {};
            Object.keys(plotIndicators).forEach(point => {
                let count = 0;
                plotIndicators[point].forEach(indicator => {
                    const regex = new RegExp(indicator, 'gi');
                    const matches = content.match(regex);
                    if (matches) count += matches.length;
                });
                plotPoints[point] = count;
            });
            
            return plotPoints;
        }

        function identifyConflicts(content) {
            const conflictTypes = {
                internal: ['suy nghƒ©', 'bƒÉn khoƒÉn', 'ph√¢n v√¢n', 'do d·ª±', 't·ª± h·ªèi'],
                interpersonal: ['tranh c√£i', 'xung ƒë·ªôt', 'b·∫•t ƒë·ªìng', 'ƒë·ªëi ƒë·∫ßu', 'chi·∫øn ƒë·∫•u'],
                societal: ['x√£ h·ªôi', 'lu·∫≠t ph√°p', 'truy·ªÅn th·ªëng', 'phong t·ª•c', 'quy t·∫Øc'],
                nature: ['thi√™n nhi√™n', 'b√£o t·ªë', 'ƒë·ªông ƒë·∫•t', 'l≈© l·ª•t', 'h·ªèa ho·∫°n'],
                supernatural: ['th·∫ßn linh', 'ma qu√°i', 'ph√©p thu·∫≠t', 'si√™u nhi√™n', 'huy·ªÅn b√≠']
            };
            
            const conflicts = {};
            Object.keys(conflictTypes).forEach(type => {
                let count = 0;
                conflictTypes[type].forEach(keyword => {
                    const regex = new RegExp(keyword, 'gi');
                    const matches = content.match(regex);
                    if (matches) count += matches.length;
                });
                conflicts[type] = count;
            });
            
            return conflicts;
        }

        function extractThemes(content) {
            const themes = {
                love: ['t√¨nh y√™u', 'y√™u th∆∞∆°ng', 't√¨nh c·∫£m', 'l√£ng m·∫°n', 't√¨nh t·ª©'],
                friendship: ['t√¨nh b·∫°n', 'b·∫°n b√®', 'h·ªØu ngh·ªã', 'ƒë·ªìng h√†nh', 'th√¢n thi·∫øt'],
                family: ['gia ƒë√¨nh', 'b·ªë m·∫π', 'anh em', 'con c√°i', 'h·ªç h√†ng'],
                honor: ['danh d·ª±', 'l√≤ng t·ª± tr·ªçng', 'ph·∫©m gi√°', 'danh ti·∫øng', 'uy t√≠n'],
                adventure: ['phi√™u l∆∞u', 'kh√°m ph√°', 'm·∫°o hi·ªÉm', 'h√†nh tr√¨nh', 'du h√†nh'],
                power: ['quy·ªÅn l·ª±c', 's·ª©c m·∫°nh', 'th·ªëng tr·ªã', 'chinh ph·ª•c', 'ki·ªÉm so√°t']
            };
            
            const themeScores = {};
            Object.keys(themes).forEach(theme => {
                let score = 0;
                themes[theme].forEach(keyword => {
                    const regex = new RegExp(keyword, 'gi');
                    const matches = content.match(regex);
                    if (matches) score += matches.length;
                });
                themeScores[theme] = score;
            });
            
            return themeScores;
        }

        function analyzeNarrativeTechnique(content) {
            const firstPerson = (content.match(/\bt√¥i\b/gi) || []).length;
            const secondPerson = (content.match(/\bb·∫°n\b/gi) || []).length;
            const thirdPerson = (content.match(/\b(anh ·∫•y|c√¥ ·∫•y|h·ªç)\b/gi) || []).length;
            
            let perspective = 'third';
            if (firstPerson > thirdPerson && firstPerson > secondPerson) {
                perspective = 'first';
            } else if (secondPerson > firstPerson && secondPerson > thirdPerson) {
                perspective = 'second';
            }
            
            return {
                perspective: perspective,
                firstPersonCount: firstPerson,
                thirdPersonCount: thirdPerson,
                flashbacks: (content.match(/\b(nh·ªõ l·∫°i|h·ªìi t∆∞·ªüng|ng√†y x∆∞a)\b/gi) || []).length,
                foreshadowing: (content.match(/\b(s·∫Ω|sau n√†y|t∆∞∆°ng lai)\b/gi) || []).length
            };
        }

        function analyzeDialogue(content) {
            const dialogueLines = content.match(/[""].*?[""]|".*?"/g) || [];
            const dialogueRatio = dialogueLines.length / (content.split('\n').length || 1);
            
            return {
                dialogueCount: dialogueLines.length,
                dialogueRatio: dialogueRatio,
                avgDialogueLength: dialogueLines.length > 0 ? 
                    dialogueLines.reduce((sum, line) => sum + line.length, 0) / dialogueLines.length : 0
            };
        }

        function analyzeDescriptions(content) {
            const descriptiveWords = [
                'm√†u', 's·∫Øc', 'ƒë·∫πp', 'x·∫•u', 'cao', 'th·∫•p', 'l·ªõn', 'nh·ªè', 
                's√°ng', 't·ªëi', 'n√≥ng', 'l·∫°nh', 'm·ªÅm', 'c·ª©ng', 'ng·ªçt', 'ƒë·∫Øng'
            ];
            
            let descriptiveCount = 0;
            descriptiveWords.forEach(word => {
                const regex = new RegExp(word, 'gi');
                const matches = content.match(regex);
                if (matches) descriptiveCount += matches.length;
            });
            
            return {
                descriptiveWordCount: descriptiveCount,
                descriptiveRatio: descriptiveCount / (content.split(' ').length || 1)
            };
        }

        function analyzePacing(sentences) {
            if (sentences.length === 0) return { fast: 0, medium: 0, slow: 0 };
            
            const sentenceLengths = sentences.map(s => s.split(' ').length);
            let fast = 0, medium = 0, slow = 0;
            
            sentenceLengths.forEach(length => {
                if (length <= 8) fast++;
                else if (length <= 15) medium++;
                else slow++;
            });
            
            return {
                fast: fast / sentences.length,
                medium: medium / sentences.length,
                slow: slow / sentences.length,
                avgSentenceLength: sentenceLengths.reduce((sum, len) => sum + len, 0) / sentences.length
            };
        }

        function analyzeTransitions(paragraphs) {
            const transitionWords = [
                'sau ƒë√≥', 'r·ªìi', 'ti·∫øp theo', 'b·ªóng nhi√™n', 'ƒë·ªôt ng·ªôt', 
                'tuy nhi√™n', 'nh∆∞ng', 'm·∫∑c d√π', 'v√¨ v·∫≠y', 'do ƒë√≥'
            ];
            
            let transitionCount = 0;
            paragraphs.forEach(paragraph => {
                transitionWords.forEach(word => {
                    if (paragraph.toLowerCase().includes(word)) {
                        transitionCount++;
                    }
                });
            });
            
            return {
                transitionCount: transitionCount,
                transitionRatio: transitionCount / (paragraphs.length || 1)
            };
        }

        function analyzeLanguageComplexity(words, sentences) {
            const avgWordLength = words.reduce((sum, word) => sum + word.length, 0) / (words.length || 1);
            const avgSentenceLength = words.length / (sentences.length || 1);
            
            const complexWords = words.filter(word => word.length > 7).length;
            const complexityRatio = complexWords / (words.length || 1);
            
            return {
                avgWordLength: avgWordLength,
                avgSentenceLength: avgSentenceLength,
                complexityRatio: complexityRatio,
                vocabularyRichness: new Set(words).size / (words.length || 1)
            };
        }

        function analyzeTone(content) {
            const toneIndicators = {
                formal: ['k√≠nh th∆∞a', 'xin ph√©p', 't√¥n k√≠nh', 'k√≠nh m·∫øn'],
                informal: ['n√†y', 'k√¨a', '∆°i', 'nh√©', 'ƒë·∫•y'],
                serious: ['nghi√™m tr·ªçng', 'quan tr·ªçng', 'c·∫ßn thi·∫øt', 'thi·∫øt y·∫øu'],
                humorous: ['h√†i h∆∞·ªõc', 'vui nh·ªôn', 'ƒë√πa', 'c∆∞·ªùi', 'h√≥t'],
                dramatic: ['cƒÉng th·∫≥ng', 'k·ªãch t√≠nh', 'h·ªìi h·ªôp', 'gay c·∫•n']
            };
            
            const toneScores = {};
            Object.keys(toneIndicators).forEach(tone => {
                let score = 0;
                toneIndicators[tone].forEach(indicator => {
                    const regex = new RegExp(indicator, 'gi');
                    const matches = content.match(regex);
                    if (matches) score += matches.length;
                });
                toneScores[tone] = score;
            });
            
            return toneScores;
        }

        function predictGenre(content) {
            const genreIndicators = {
                fantasy: ['ma thu·∫≠t', 'ph√©p thu·∫≠t', 'r·ªìng', 'th·∫ßn ti√™n', 'huy·ªÅn b√≠', 'k·ª≥ ·∫£o'],
                romance: ['t√¨nh y√™u', 'y√™u ƒë∆∞∆°ng', 'h√¥n', 'c∆∞·ªõi', 'l√£ng m·∫°n', 't√¨nh t·ª©'],
                adventure: ['phi√™u l∆∞u', 'm·∫°o hi·ªÉm', 'kh√°m ph√°', 'h√†nh tr√¨nh', 'du l·ªãch'],
                mystery: ['b√≠ ·∫©n', 'b√≠ m·∫≠t', 'ƒëi·ªÅu tra', 'th√°m t·ª≠', 'gi·∫£i m√£'],
                historical: ['l·ªãch s·ª≠', 'c·ªï ƒë·∫°i', 'tri·ªÅu ƒë·∫°i', 'ho√†ng gia', 'chi·∫øn tranh'],
                horror: ['kinh d·ªã', 'ma qu√°i', 's·ª£ h√£i', '√°m ·∫£nh', 'ƒë√°ng s·ª£']
            };
            
            const genreScores = {};
            Object.keys(genreIndicators).forEach(genre => {
                let score = 0;
                genreIndicators[genre].forEach(keyword => {
                    const regex = new RegExp(keyword, 'gi');
                    const matches = content.match(regex);
                    if (matches) score += matches.length;
                });
                genreScores[genre] = score;
            });
            
            return genreScores;
        }

        function calculateReadabilityScore(sentences, words) {
            const avgWordsPerSentence = words.length / (sentences.length || 1);
            const avgSyllablesPerWord = words.reduce((sum, word) => sum + estimateSyllables(word), 0) / (words.length || 1);
            
            // Simplified readability formula
            return Math.max(0, 206.835 - (1.015 * avgWordsPerSentence) - (84.6 * avgSyllablesPerWord));
        }

        function estimateSyllables(word) {
            // Simple Vietnamese syllable estimation
            const vowels = 'aeiou√°√†·∫£√£·∫°·∫•·∫ß·∫≠·∫©·∫´·∫Ø·∫±·∫∑·∫≥·∫µ√©√®·∫ª·∫Ω·∫π·∫ø·ªÅ·ªÉ·ªÖ·ªá√≠√¨·ªâƒ©·ªã√≥√≤·ªè√µ·ªç·ªë·ªì·ªô·ªï·ªó·ªõ·ªù·ªü·ª°·ª£√∫√π·ªß≈©·ª•·ª©·ª´·ª≠·ªØ·ª±√Ω·ª≥·ª∑·ªπ·ªµ';
            let count = 0;
            for (let i = 0; i < word.length; i++) {
                if (vowels.includes(word[i].toLowerCase())) {
                    count++;
                }
            }
            return Math.max(1, count);
        }

        const commonWords = [
            'v√†', 'c·ªßa', 'c√≥', 'l√†', 'm·ªôt', 'ƒë∆∞·ª£c', 'n√†y', 'v·ªõi', 'trong', 'cho',
            't·ª´', 'kh√¥ng', 'ƒë√£', 's·∫Ω', 'ng∆∞·ªùi', 'th√¨', 'nh∆∞', 'ƒë·ªÉ', 'khi', 'hay'
        ];

        function updateStoryPatterns(content, analysis) {
            // Update opening patterns
            const firstSentence = content.split(/[.!?]+/)[0];
            if (firstSentence) {
                const firstWords = firstSentence.toLowerCase().split(' ').slice(0, 3).join(' ');
                storyPatterns.openingPatterns[firstWords] = (storyPatterns.openingPatterns[firstWords] || 0) + 1;
            }
            
            // Update dialogue patterns
            Object.keys(analysis.dialogue || {}).forEach(key => {
                if (!storyPatterns.dialoguePatterns[key]) {
                    storyPatterns.dialoguePatterns[key] = [];
                }
                storyPatterns.dialoguePatterns[key].push(analysis.dialogue[key]);
            });
        }

        function updateCharacterAnalysis(content, analysis) {
            if (analysis.characters) {
                analysis.characters.forEach(char => {
                    characterAnalysis.characterNames.add(char);
                });
            }
        }

        function updatePlotStructure(content, analysis) {
            if (analysis.plotPoints) {
                plotStructure.chapterStructures.push(analysis.plotPoints);
            }
            
            if (analysis.conflicts) {
                Object.keys(analysis.conflicts).forEach(conflictType => {
                    if (!plotStructure.conflictTypes[conflictType]) {
                        plotStructure.conflictTypes[conflictType] = [];
                    }
                    plotStructure.conflictTypes[conflictType].push(analysis.conflicts[conflictType]);
                });
            }
        }

        function updateNarrativeStyle(content, analysis) {
            if (analysis.narrative) {
                narrativeStyle.sentenceStructure[analysis.narrative.perspective] = 
                    (narrativeStyle.sentenceStructure[analysis.narrative.perspective] || 0) + 1;
            }
            
            if (analysis.tone) {
                Object.keys(analysis.tone).forEach(toneType => {
                    if (!narrativeStyle.emotionalTone[toneType]) {
                        narrativeStyle.emotionalTone[toneType] = [];
                    }
                    narrativeStyle.emotionalTone[toneType].push(analysis.tone[toneType]);
                });
            }
        }

        async function buildAdvancedVocabulary() {
            vocabulary = { '<PAD>': 0, '<UNK>': 1, '<START>': 2, '<END>': 3 };
            let index = 4;
            
            const wordFrequency = {};
            
            storyData.forEach(story => {
                const words = story.content.toLowerCase().match(/\b\w+\b/g) || [];
                words.forEach(word => {
                    wordFrequency[word] = (wordFrequency[word] || 0) + 1;
                });
            });
            
            // Only include words that appear at least 2 times
            Object.keys(wordFrequency)
                .filter(word => wordFrequency[word] >= 2)
                .sort((a, b) => wordFrequency[b] - wordFrequency[a])
                .forEach(word => {
                    vocabulary[word] = index++;
                });
            
            log(`Built advanced vocabulary: ${Object.keys(vocabulary).length} words`);
        }

        function showAnalysisResults() {
            const totalWords = storyData.reduce((sum, story) => sum + story.analysis.wordCount, 0);
            const totalFolders = new Set(storyData.map(story => story.folderPath)).size;
            
            document.getElementById('totalStories').textContent = formatNumber(storyData.length);
            document.getElementById('totalWords').textContent = formatNumber(totalWords);
            document.getElementById('totalFolders').textContent = formatNumber(totalFolders);
            document.getElementById('vocabularySize').textContent = formatNumber(Object.keys(vocabulary).length);
            
            // Show detailed analysis
            showDetailedAnalysis();
            
            document.getElementById('analysisResults').classList.remove('hidden');
            document.getElementById('trainBtn').disabled = false;
            document.getElementById('modelStatus').textContent = 'S·∫µn s√†ng hu·∫•n luy·ªán';
        }

        function showDetailedAnalysis() {
            const detailedAnalysis = document.getElementById('detailedAnalysis');
            
            let html = '';
            
            // Character analysis
            const allCharacters = Array.from(characterAnalysis.characterNames).slice(0, 10);
            if (allCharacters.length > 0) {
                html += `
                    <div class="analysis-item">
                        <h4>üé≠ Nh√¢n v·∫≠t ph·ªï bi·∫øn</h4>
                        <p>${allCharacters.join(', ')}</p>
                    </div>
                `;
            }
            
            // Genre analysis
            const genreScores = {};
            storyData.forEach(story => {
                if (story.advancedAnalysis && story.advancedAnalysis.genre) {
                    Object.keys(story.advancedAnalysis.genre).forEach(genre => {
                        genreScores[genre] = (genreScores[genre] || 0) + story.advancedAnalysis.genre[genre];
                    });
                }
            });
            
            const topGenre = Object.keys(genreScores).reduce((a, b) => genreScores[a] > genreScores[b] ? a : b, 'unknown');
            html += `
                <div class="analysis-item">
                    <h4>üìö Th·ªÉ lo·∫°i ch√≠nh</h4>
                    <p>${getGenreVietnamese(topGenre)} (${genreScores[topGenre] || 0} ƒëi·ªÉm)</p>
                </div>
            `;
            
            // Emotional tone analysis
            const avgEmotions = {};
            storyData.forEach(story => {
                if (story.advancedAnalysis && story.advancedAnalysis.emotions) {
                    Object.keys(story.advancedAnalysis.emotions).forEach(emotion => {
                        if (!avgEmotions[emotion]) avgEmotions[emotion] = [];
                        avgEmotions[emotion].push(story.advancedAnalysis.emotions[emotion]);
                    });
                }
            });
            
            const dominantEmotion = Object.keys(avgEmotions).reduce((a, b) => {
                const avgA = avgEmotions[a].reduce((sum, val) => sum + val, 0) / avgEmotions[a].length;
                const avgB = avgEmotions[b].reduce((sum, val) => sum + val, 0) / avgEmotions[b].length;
                return avgA > avgB ? a : b;
            }, 'joy');
            
            html += `
                <div class="analysis-item">
                    <h4>üòä C·∫£m x√∫c ch·ªß ƒë·∫°o</h4>
                    <p>${getEmotionVietnamese(dominantEmotion)}</p>
                </div>
            `;
            
            // Writing style analysis
            const avgComplexity = storyData.reduce((sum, story) => {
                return sum + (story.advancedAnalysis?.complexity?.vocabularyRichness || 0);
            }, 0) / storyData.length;
            
            html += `
                <div class="analysis-item">
                    <h4>‚úçÔ∏è Phong c√°ch vi·∫øt</h4>
                    <p>ƒê·ªô ph·ª©c t·∫°p t·ª´ v·ª±ng: ${(avgComplexity * 100).toFixed(1)}%</p>
                </div>
            `;
            
            // Narrative perspective
            const perspectives = {};
            storyData.forEach(story => {
                if (story.advancedAnalysis?.narrative?.perspective) {
                    const perspective = story.advancedAnalysis.narrative.perspective;
                    perspectives[perspective] = (perspectives[perspective] || 0) + 1;
                }
            });
            
            const mainPerspective = Object.keys(perspectives).reduce((a, b) => 
                perspectives[a] > perspectives[b] ? a : b, 'third');
            
            html += `
                <div class="analysis-item">
                    <h4>üëÅÔ∏è G√≥c nh√¨n t∆∞·ªùng thu·∫≠t</h4>
                    <p>${getPerspectiveVietnamese(mainPerspective)} (${perspectives[mainPerspective] || 0} truy·ªán)</p>
                </div>
            `;
            
            detailedAnalysis.innerHTML = html;
        }

        function getGenreVietnamese(genre) {
            const genreMap = {
                fantasy: 'Huy·ªÅn Huy·ªÖn',
                romance: 'L√£ng M·∫°n',
                adventure: 'Phi√™u L∆∞u',
                mystery: 'B√≠ ·∫®n',
                historical: 'L·ªãch S·ª≠',
                horror: 'Kinh D·ªã'
            };
            return genreMap[genre] || 'Kh√¥ng x√°c ƒë·ªãnh';
        }

        function getEmotionVietnamese(emotion) {
            const emotionMap = {
                joy: 'Vui v·∫ª, h·∫°nh ph√∫c',
                sadness: 'Bu·ªìn b√£, u s·∫ßu',
                anger: 'Gi·∫≠n d·ªØ, ph·∫´n n·ªô',
                fear: 'S·ª£ h√£i, lo l·∫Øng',
                surprise: 'Ng·∫°c nhi√™n, b·∫•t ng·ªù'
            };
            return emotionMap[emotion] || 'Trung t√≠nh';
        }

        function getPerspectiveVietnamese(perspective) {
            const perspectiveMap = {
                first: 'Ng√¥i th·ª© nh·∫•t (t√¥i)',
                second: 'Ng√¥i th·ª© hai (b·∫°n)',
                third: 'Ng√¥i th·ª© ba (anh ·∫•y/c√¥ ·∫•y)'
            };
            return perspectiveMap[perspective] || 'Kh√¥ng x√°c ƒë·ªãnh';
        }

        async function saveAnalysisData() {
            try {
                const analysisData = {
                    storyData: storyData.map(story => ({
                        name: story.name,
                        folderPath: story.folderPath,
                        analysis: story.analysis,
                        advancedAnalysis: story.advancedAnalysis
                    })),
                    storyPatterns,
                    characterAnalysis: {
                        ...characterAnalysis,
                        characterNames: Array.from(characterAnalysis.characterNames)
                    },
                    plotStructure,
                    narrativeStyle,
                    vocabulary,
                    timestamp: new Date().toISOString()
                };

                await saveFileToRoot(ANALYSIS_FILE_NAME, JSON.stringify(analysisData, null, 2));
                showStatus('ƒê√£ l∆∞u k·∫øt qu·∫£ ph√¢n t√≠ch', 'success');
                log('Analysis data saved successfully');
            } catch (error) {
                log('Save analysis error:', error);
                showStatus('L·ªói l∆∞u ph√¢n t√≠ch', 'error');
            }
        }

        // Enhanced AI Training and Generation
        async function trainAI() {
            if (storyData.length === 0) {
                showStatus('C·∫ßn ph√¢n t√≠ch truy·ªán tr∆∞·ªõc', 'error');
                return;
            }

            document.getElementById('trainBtn').disabled = true;
            showStatus('ƒêang hu·∫•n luy·ªán AI v·ªõi d·ªØ li·ªáu chuy√™n s√¢u...', 'info');
            
            try {
                const vocabSize = Object.keys(vocabulary).length + 1;
                
                // Create advanced training sequences
                const sequences = [];
                const contextWindow = 20; // Larger context window
                
                storyData.forEach(story => {
                    const words = story.content.toLowerCase().match(/\b\w+\b/g) || [];
                    const tokens = words.map(word => vocabulary[word] || vocabulary['<UNK>']);
                    
                    // Create sequences with story context
                    for (let i = 0; i < tokens.length - contextWindow; i++) {
                        const sequence = {
                            input: tokens.slice(i, i + contextWindow),
                            output: tokens[i + contextWindow],
                            storyInfo: {
                                genre: story.advancedAnalysis?.genre || {},
                                emotions: story.advancedAnalysis?.emotions || {},
                                narrative: story.advancedAnalysis?.narrative?.perspective || 'third'
                            }
                        };
                        sequences.push(sequence);
                    }
                });

                // Simulate advanced training with progress updates
                for (let epoch = 0; epoch < 5; epoch++) {
                    await new Promise(resolve => setTimeout(resolve, 1000));
                    showStatus(`Hu·∫•n luy·ªán epoch ${epoch + 1}/5...`, 'info');
                }
                
                // Save trained model state
                const modelData = {
                    vocabulary,
                    sequences: sequences.slice(0, 1000), // Save sample sequences
                    trainingStats: {
                        vocabSize,
                        sequenceCount: sequences.length,
                        contextWindow,
                        trainedAt: new Date().toISOString()
                    }
                };
                
                await saveFileToRoot('ai_model_data.json', JSON.stringify(modelData, null, 2));
                
                showStatus('Hu·∫•n luy·ªán AI ho√†n th√†nh!', 'success');
                document.getElementById('modelStatus').textContent = 'ƒê√£ hu·∫•n luy·ªán';
                document.getElementById('generateBtn').disabled = false;
                
            } catch (error) {
                log('Training error:', error);
                showStatus('L·ªói hu·∫•n luy·ªán', 'error');
            } finally {
                document.getElementById('trainBtn').disabled = false;
            }
        }

        // Enhanced story generation with 2000-3000 words per chapter
        async function generateStory() {
            const chapterCount = parseInt(document.getElementById('chapterCount').value) || 50;
            const selectedGenre = document.getElementById('genreSelect').value;
            
            if (Object.keys(vocabulary).length === 0) {
                showStatus('C·∫ßn hu·∫•n luy·ªán AI tr∆∞·ªõc', 'error');
                return;
            }

            document.getElementById('generateBtn').disabled = true;
            document.getElementById('generationProgress').classList.remove('hidden');
            
            try {
                // Generate story based on selected genre and analyzed patterns
                const storyTitle = generateAdvancedStoryTitle(selectedGenre);
                const storyOutline = generateStoryOutline(chapterCount, selectedGenre);
                
                const chapters = [];
                
                for (let i = 1; i <= chapterCount; i++) {
                    const progress = (i / chapterCount) * 100;
                    document.getElementById('generationProgressFill').style.width = `${progress}%`;
                    document.getElementById('generationProgressText').textContent = 
                        `ƒêang vi·∫øt ch∆∞∆°ng ${i}/${chapterCount} (2000-3000 t·ª´)`;
                    
                    const chapterInfo = storyOutline[i - 1];
                    const chapterTitle = `Ch∆∞∆°ng ${i}: ${chapterInfo.title}`;
                    const chapterContent = await generateLongChapterContent(i, chapterCount, chapterInfo, selectedGenre);
                    
                    chapters.push({
                        title: chapterTitle,
                        content: chapterContent,
                        wordCount: chapterContent.split(' ').length,
                        type: chapterInfo.type
                    });
                    
                    // Small delay for UI responsiveness
                    await new Promise(resolve => setTimeout(resolve, 200));
                }

                currentStory = {
                    title: storyTitle,
                    genre: selectedGenre,
                    chapters: chapters,
                    totalWords: chapters.reduce((sum, ch) => sum + ch.wordCount, 0),
                    createdAt: new Date(),
                    metadata: {
                        basedOnAnalysis: true,
                        sourceStories: storyData.length,
                        vocabularyUsed: Object.keys(vocabulary).length
                    }
                };

                displayGeneratedStory();
                showStatus(`Ho√†n th√†nh "${storyTitle}" v·ªõi ${chapters.length} ch∆∞∆°ng, ${formatNumber(currentStory.totalWords)} t·ª´!`, 'success');
                
            } catch (error) {
                log('Generation error:', error);
                showStatus('L·ªói t·∫°o truy·ªán', 'error');
            } finally {
                document.getElementById('generateBtn').disabled = false;
                document.getElementById('generationProgress').classList.add('hidden');
            }
        }

        function generateAdvancedStoryTitle(genre) {
            const titleTemplates = {
                fantasy: [
                    'Huy·ªÅn Tho·∫°i {element} {location}',
                    'ƒê·∫ø V∆∞∆°ng {power} Gi·ªõi',
                    'Ma Ph√°p S∆∞ Cu·ªëi C√πng',
                    'Th·∫ßn Ki·∫øm {legendary}',
                    'Cu·ªôc Chi·∫øn {realm} Gi·ªõi'
                ],
                romance: [
                    'T√¨nh Y√™u T·∫°i {location}',
                    'Tr√°i Tim {emotion}',
                    'Duy√™n Ph·∫≠n {time}',
                    'Em L√† {destiny} C·ªßa Anh',
                    'Chuy·ªán T√¨nh {season}'
                ],
                adventure: [
                    'H√†nh Tr√¨nh T√¨m {treasure}',
                    'Kh√°m Ph√° {mystery} {location}',
                    'Cu·ªôc Phi√™u L∆∞u T·∫°i {realm}',
                    'Th√°m Hi·ªÉm {dangerous} {place}',
                    'SƒÉn T√¨m {legendary} {artifact}'
                ],
                mystery: [
                    'B√≠ M·∫≠t C·ªßa {location}',
                    '√Ån M·∫°ng T·∫°i {place}',
                    'Th√°m T·ª≠ V√† {mystery}',
                    'S·ª± Th·∫≠t V·ªÅ {event}',
                    'ƒêi·ªÅu Tra {case}'
                ],
                historical: [
                    'Anh H√πng Th·ªùi {dynasty}',
                    'Chi·∫øn Tranh {era}',
                    'Ho√†ng Gia {ancient}',
                    'Tr·∫≠n Chi·∫øn {legendary}',
                    'L·ªãch S·ª≠ {kingdom}'
                ]
            };

            const variables = {
                element: ['L·ª≠a', 'N∆∞·ªõc', 'Gi√≥', 'ƒê·∫•t', 'S√©t', 'BƒÉng', '√Ånh S√°ng', 'B√≥ng T·ªëi'],
                location: ['R·ª´ng Thi√™ng', 'N√∫i Linh', 'Th√†nh C·ªï', 'Bi·ªÉn C·∫£', 'Sa M·∫°c', 'ƒê·∫£o B√≠ ·∫®n'],
                power: ['H·∫Øc', 'B·∫°ch', 'Ho√†ng', 'Thanh', 'H·ªìng', 'T√≠m', 'V√†ng'],
                legendary: ['Th·∫ßn Tho·∫°i', 'C·ªï ƒê·∫°i', 'B√≠ Truy·ªÅn', 'Thi√™n Th·∫ßn', '√Åc Ma'],
                realm: ['Th·∫ßn', 'Ma', 'Nh√¢n', 'Ti√™n', 'Qu·ª∑', 'Long'],
                emotion: ['ƒêau Kh·ªï', 'Ng·ªçt Ng√†o', 'Bi Th∆∞∆°ng', 'H·∫°nh Ph√∫c', 'Tan V·ª°'],
                time: ['Ng√†n NƒÉm', 'Ba Sinh', 'Vƒ©nh C·ª≠u', 'Ki·∫øp Sau', 'Th·∫ø K·ª∑'],
                destiny: ['ƒê·ªãnh M·ªánh', 'Duy Nh·∫•t', 'Cu·ªëi C√πng', 'ƒê·∫ßu Ti√™n', 'Vƒ©nh Vi·ªÖn'],
                season: ['M√πa Xu√¢n', 'M√πa H·∫°', 'M√πa Thu', 'M√πa ƒê√¥ng', 'T·ª© M√πa'],
                treasure: ['Kho B√°u', 'B√≠ K√≠p', 'Th·∫ßn D∆∞·ª£c', 'Ph√°p B·∫£o', 'Linh Th·∫°ch'],
                mystery: ['B√≠ ·∫®n', 'Huy·ªÅn B√≠', 'K·ª≥ L·∫°', 'Th·∫ßn B√≠', 'B·∫•t Th∆∞·ªùng'],
                dangerous: ['Nguy Hi·ªÉm', 'T·ª≠ Th·∫ßn', 'Ch·∫øt Ch√≥c', 'Kh·ªßng Khi·∫øp', 'Kinh Ho√†ng'],
                place: ['Cung ƒêi·ªán', 'LƒÉng M·ªô', 'ƒê·ªÅn Th·ªù', 'Hang ƒê·ªông', 'T√≤a L√¢u ƒê√†i'],
                artifact: ['Ph√°p Kh√≠', 'Th·∫ßn Binh', 'B·∫£o V·∫≠t', 'Th√°nh V·∫≠t', 'Linh Kh√≠'],
                dynasty: ['ƒê∆∞·ªùng', 'T·ªëng', 'Minh', 'Thanh', 'Nguy√™n'],
                era: ['C·ªï ƒê·∫°i', 'Trung C·ªï', 'Th·ªùi Chi·∫øn', 'H√≤a B√¨nh', 'Lo·∫°n L·∫°c'],
                ancient: ['C·ªï X∆∞a', 'Xa X∆∞a', 'Th∆∞·ª£ng C·ªï', 'Vi·ªÖn C·ªï', 'Th√°i C·ªï'],
                event: ['Bi·∫øn C·ªë', 'S·ª± Ki·ªán', 'V·ª• Vi·ªác', 'Chuy·ªán', 'C√¢u Chuy·ªán'],
                case: ['V·ª• √Ån', '√Ån M·∫°ng', 'B√≠ M·∫≠t', 'S·ª± Th·∫≠t', 'H·ªì S∆°'],
                kingdom: ['V∆∞∆°ng Qu·ªëc', 'ƒê·∫ø Qu·ªëc', 'Tri·ªÅu ƒê·∫°i', 'Qu·ªëc Gia', 'Ho√†ng Tri·ªÅu']
            };

            const templates = titleTemplates[genre] || titleTemplates.fantasy;
            let template = templates[Math.floor(Math.random() * templates.length)];
            
            // Replace variables in template
            Object.keys(variables).forEach(key => {
                const regex = new RegExp(`{${key}}`, 'g');
                if (template.match(regex)) {
                    const options = variables[key];
                    const replacement = options[Math.floor(Math.random() * options.length)];
                    template = template.replace(regex, replacement);
                }
            });
            
            return template;
        }

        function generateStoryOutline(chapterCount, genre) {
            const outline = [];
            
            // Story structure: Setup (20%) -> Rising Action (50%) -> Climax (10%) -> Resolution (20%)
            const setupChapters = Math.ceil(chapterCount * 0.2);
            const risingActionChapters = Math.ceil(chapterCount * 0.5);
            const climaxChapters = Math.ceil(chapterCount * 0.1);
            const resolutionChapters = chapterCount - setupChapters - risingActionChapters - climaxChapters;

            // Setup chapters
            for (let i = 0; i < setupChapters; i++) {
                outline.push({
                    title: generateChapterTitle('setup', i, genre),
                    type: 'setup',
                    focus: i === 0 ? 'introduction' : 'worldBuilding'
                });
            }

            // Rising action chapters
            for (let i = 0; i < risingActionChapters; i++) {
                outline.push({
                    title: generateChapterTitle('risingAction', i, genre),
                    type: 'risingAction',
                    focus: i % 3 === 0 ? 'conflict' : i % 3 === 1 ? 'development' : 'revelation'
                });
            }

            // Climax chapters
            for (let i = 0; i < climaxChapters; i++) {
                outline.push({
                    title: generateChapterTitle('climax', i, genre),
                    type: 'climax',
                    focus: 'confrontation'
                });
            }

            // Resolution chapters
            for (let i = 0; i < resolutionChapters; i++) {
                outline.push({
                    title: generateChapterTitle('resolution', i, genre),
                    type: 'resolution',
                    focus: i === resolutionChapters - 1 ? 'ending' : 'aftermath'
                });
            }

            return outline;
        }

        function generateChapterTitle(storyPart, index, genre) {
            const chapterTitles = {
                setup: {
                    fantasy: ['Th·ª©c T·ªânh S·ª©c M·∫°nh', 'Kh·ªüi ƒê·∫ßu H√†nh Tr√¨nh', 'G·∫∑p G·ª° ƒê·ªãnh M·ªánh', 'B√≠ M·∫≠t ƒê∆∞·ª£c H√© L·ªô', 'Th·∫ø Gi·ªõi M·ªõi'],
                    romance: ['Cu·ªôc G·∫∑p G·ª°', '·∫§n T∆∞·ª£ng ƒê·∫ßu Ti√™n', 'T√¨nh C·∫£m Manh Nha', 'Hi·ªÉu L·∫ßm', 'G·∫ßn G≈©i H∆°n'],
                    adventure: ['L·ªùi K√™u G·ªçi', 'Chu·∫©n B·ªã H√†nh Tr√¨nh', 'Kh·ªüi H√†nh', 'Th·ª≠ Th√°ch ƒê·∫ßu Ti√™n', 'ƒê·ªìng H√†nh'],
                    mystery: ['V·ª• √Ån B√≠ ·∫®n', 'Manh M·ªëi ƒê·∫ßu Ti√™n', 'Nh√¢n Ch·ª©ng', 'ƒêi·ªÅu Tra', 'Nghi V·∫•n'],
                    historical: ['Th·ªùi Lo·∫°n L·∫°c', 'Anh H√πng Xu·∫•t Hi·ªán', 'Tri·ªáu H·ªìi', 'Chu·∫©n B·ªã Chi·∫øn ƒê·∫•u', 'Li√™n Minh']
                },
                risingAction: {
                    fantasy: ['Th·ª≠ Th√°ch Kh√≥ KhƒÉn', 'K·∫ª Th√π M·∫°nh M·∫Ω', 'S·ª©c M·∫°nh TƒÉng Tr∆∞·ªüng', 'B·∫°n ƒê·ªìng H√†nh', 'Tr·∫≠n Chi·∫øn L·ªõn'],
                    romance: ['Tr·ªü Ng·∫°i', 'Ghen Tu√¥ng', 'Chia Ly', 'Hi·ªÉu Nh·∫ßm', 'ƒê·∫•u Tranh N·ªôi T√¢m'],
                    adventure: ['Nguy Hi·ªÉm R√¨nh R·∫≠p', 'Kh√°m Ph√° B√≠ M·∫≠t', 'M·∫•t M√°t', 'V∆∞·ª£t Qua Th·ª≠ Th√°ch', 'Ph√°t Hi·ªán M·ªõi'],
                    mystery: ['B·∫±ng Ch·ª©ng M·ªõi', 'T√¨nh Ti·∫øt B·∫•t Ng·ªù', 'Nghi Can M·ªõi', 'Ph·ª©c T·∫°p H√≥a', 'Ch√¢n T∆∞·ªõng L·ªô Di·ªán'],
                    historical: ['Chi·∫øn Tranh B√πng N·ªï', '√Çm M∆∞u Ch√≠nh Tr·ªã', 'Ph·∫£n B·ªôi', 'Li√™n Minh Tan V·ª°', 'Th·∫£m B·∫°i']
                },
                climax: {
                    fantasy: ['Quy·∫øt Chi·∫øn Cu·ªëi C√πng', 'S·ª©c M·∫°nh T·ªëi Th∆∞·ª£ng', 'Hy Sinh Cao C·∫£'],
                    romance: ['L·ª±a Ch·ªçn Kh√≥ KhƒÉn', 'T√¨nh Y√™u ƒê√≠ch Th·ª±c', 'Quy·∫øt ƒê·ªãnh Cu·ªëi C√πng'],
                    adventure: ['Cu·ªôc ƒê·ªëi ƒê·∫ßu', 'T√¨m Ra S·ª± Th·∫≠t', 'Gi·∫£i C·ª©u Th√†nh C√¥ng'],
                    mystery: ['Ph∆°i B√†y Ch√¢n T∆∞·ªõng', 'ƒê·ªëi M·∫∑t Th·ªß Ph·∫°m', 'C√¥ng L√Ω ƒê∆∞·ª£c Th·ª±c Thi'],
                    historical: ['Tr·∫≠n Chi·∫øn Quy·∫øt ƒê·ªãnh', 'Anh H√πng Hy Sinh', 'Chi·∫øn Th·∫Øng Vƒ© ƒê·∫°i']
                },
                resolution: {
                    fantasy: ['H√≤a B√¨nh Tr·ªü L·∫°i', 'T∆∞∆°ng Lai M·ªõi', 'B√†i H·ªçc Cu·ªôc S·ªëng'],
                    romance: ['H·∫°nh Ph√∫c Vi√™n M√£n', 'C∆∞·ªõi Nhau', 'Cu·ªôc S·ªëng M·ªõi'],
                    adventure: ['Tr·ªü V·ªÅ Nh√†', 'Ph·∫ßn Th∆∞·ªüng', 'H√†nh Tr√¨nh M·ªõi'],
                    mystery: ['Th·ªß Ph·∫°m B·ªã B·∫Øt', 'C√¥ng L√Ω ƒê∆∞·ª£c Th·ª±c Thi', 'Cu·ªôc S·ªëng B√¨nh Y√™n'],
                    historical: ['H√≤a B√¨nh L·∫≠p L·∫°i', 'T√°i Thi·∫øt ƒê·∫•t N∆∞·ªõc', 'Di S·∫£n ƒê·ªÉ L·∫°i']
                }
            };

            const titles = chapterTitles[storyPart][genre] || chapterTitles[storyPart]['fantasy'];
            return titles[index % titles.length] || titles[0];
        }

        async function generateLongChapterContent(chapterNumber, totalChapters, chapterInfo, genre) {
            // Generate 2000-3000 words per chapter
            const targetWords = 2000 + Math.floor(Math.random() * 1000); // 2000-3000 words
            const paragraphs = [];
            let currentWordCount = 0;

            // Generate opening paragraph
            let openingParagraph = generateOpeningParagraph(chapterNumber, chapterInfo, genre);
            paragraphs.push(openingParagraph);
            currentWordCount += openingParagraph.split(' ').length;

            // Generate main content paragraphs
            while (currentWordCount < targetWords - 200) {
                const paragraph = generateContentParagraph(chapterInfo, genre, paragraphs.length);
                paragraphs.push(paragraph);
                currentWordCount += paragraph.split(' ').length;
                
                // Add some variety in paragraph length
                if (Math.random() < 0.3) {
                    const shortParagraph = generateShortParagraph(chapterInfo, genre);
                    paragraphs.push(shortParagraph);
                    currentWordCount += shortParagraph.split(' ').length;
                }
            }

            // Generate closing paragraph
            const closingParagraph = generateClosingParagraph(chapterNumber, totalChapters, chapterInfo, genre);
            paragraphs.push(closingParagraph);

            // Add dialogue sections
            const dialogueSections = Math.floor(Math.random() * 3) + 2; // 2-4 dialogue sections
            for (let i = 0; i < dialogueSections; i++) {
                const insertIndex = Math.floor(Math.random() * (paragraphs.length - 1)) + 1;
                const dialogue = generateDialogueSection(chapterInfo, genre);
                paragraphs.splice(insertIndex, 0, dialogue);
            }

            return paragraphs.join('\n\n');
        }

        function generateOpeningParagraph(chapterNumber, chapterInfo, genre) {
            const openingTemplates = {
                fantasy: [
                    '√Ånh s√°ng ƒë·∫ßu ng√†y chi·∫øu r·ªçi qua nh·ªØng t√°n l√° c·ªï th·ª•, t·∫°o n√™n nh·ªØng v·ªát s√°ng lung linh tr√™n m·∫∑t ƒë·∫•t. {character} t·ª´ t·ª´ m·ªü m·∫Øt, c·∫£m nh·∫≠n ƒë∆∞·ª£c lu·ªìng nƒÉng l∆∞·ª£ng k·ª≥ l·∫° ƒëang ch·∫£y trong ng∆∞·ªùi m√¨nh.',
                    'Gi√≥ th·ªïi qua nh·ªØng ng·ªçn n√∫i h√πng vƒ©, mang theo √¢m thanh c·ªßa nh·ªØng c√¢u ch√∫ thu·∫≠t c·ªï x∆∞a. Trong kh√¥ng gian tƒ©nh l·∫∑ng ·∫•y, m·ªôt s·ª©c m·∫°nh m·ªõi ƒëang th·ª©c t·ªânh.',
                    'Nh·ªØng ng√¥i sao tr√™n b·∫ßu tr·ªùi ƒë√™m nh∆∞ nh·ªØng vi√™n pha l√™ l·∫•p l√°nh, b√°o hi·ªáu m·ªôt s·ª± ki·ªán tr·ªçng ƒë·∫°i s·∫Øp x·∫£y ra. {character} c·∫£m th·∫•y ƒë·ªãnh m·ªánh ƒëang g·ªçi t√™n m√¨nh.'
                ],
                romance: [
                    'Bu·ªïi s√°ng trong tr·∫ªo v·ªõi nh·ªØng tia n·∫Øng v√†ng √≥ng √°nh xuy√™n qua khung c·ª≠a s·ªï. {character} th·ª©c d·∫≠y v·ªõi t√¢m tr·∫°ng b·ªìn ch·ªìn, kh√¥ng th·ªÉ qu√™n ƒë∆∞·ª£c khu√¥n m·∫∑t c·ªßa {love_interest}.',
                    'Nh·ªØng c√°nh hoa anh ƒë√†o bay bay trong gi√≥ xu√¢n, t·∫°o n√™n khung c·∫£nh th∆° m·ªông. Tr√°i tim {character} ƒëang rung ƒë·ªông v√¨ m·ªôt c·∫£m x√∫c m·ªõi m·∫ª ch∆∞a t·ª´ng tr·∫£i qua.',
                    '√Çm thanh c·ªßa m∆∞a r∆°i nh·∫π nh√†ng tr√™n m√°i hi√™n, t·∫°o n√™n b·∫£n nh·∫°c du d∆∞∆°ng. {character} ng·ªìi b√™n c·ª≠a s·ªï, nh·ªõ v·ªÅ nh·ªØng l·ªùi n√≥i ng·ªçt ng√†o c·ªßa {love_interest}.'
                ],
                adventure: [
                    'B√¨nh minh l√≥ d·∫°ng sau nh·ªØng d√£y n√∫i xa x√¥i, nhu·ªôm ƒë·ªè c·∫£ b·∫ßu tr·ªùi ph∆∞∆°ng ƒë√¥ng. {character} chu·∫©n b·ªã cho m·ªôt h√†nh tr√¨nh d√†i ƒë·∫ßy th·ª≠ th√°ch ph√≠a tr∆∞·ªõc.',
                    'Ti·∫øng s√≥ng v·ªó v·ªÅ b·ªù bi·ªÉn t·∫°o n√™n nh·ªãp ƒëi·ªáu h√πng tr√°ng c·ªßa ƒë·∫°i d∆∞∆°ng. Con thuy·ªÅn nh·ªè b√© ƒëang chu·∫©n b·ªã cho cu·ªôc phi√™u l∆∞u vƒ© ƒë·∫°i.',
                    'R·ª´ng s√¢u v·ªõi nh·ªØng √¢m thanh b√≠ ·∫©n ƒëang ch·ªù ƒë·ª£i nh·ªØng k·∫ª d≈©ng c·∫£m. {character} b∆∞·ªõc nh·ªØng b∆∞·ªõc ƒë·∫ßu ti√™n v√†o cu·ªôc h√†nh tr√¨nh kh√°m ph√°.'
                ]
            };

            const templates = openingTemplates[genre] || openingTemplates['fantasy'];
            let template = templates[Math.floor(Math.random() * templates.length)];
            
            // Replace placeholders
            template = template.replace(/{character}/g, generateCharacterName());
            template = template.replace(/{love_interest}/g, generateCharacterName());
            
            return template;
        }

        function generateContentParagraph(chapterInfo, genre, paragraphIndex) {
            const contentTemplates = {
                setup: [
                    'Trong kh√¥ng gian y√™n tƒ©nh c·ªßa ng√¥i l√†ng nh·ªè, cu·ªôc s·ªëng v·∫´n tr√¥i qua theo nh·ªãp ƒë·ªô ch·∫≠m r√£i th∆∞·ªùng ng√†y. Nh·ªØng ng∆∞·ªùi d√¢n n∆°i ƒë√¢y ch∆∞a h·ªÅ bi·∫øt r·∫±ng m·ªôt bi·∫øn c·ªë l·ªõn ƒëang d·∫ßn ƒë·∫øn g·∫ßn, m·ªôt s·ª± ki·ªán s·∫Ω thay ƒë·ªïi m√£i m√£i cu·ªôc ƒë·ªùi c·ªßa h·ªç. √Ånh n·∫Øng bu·ªïi chi·ªÅu chi·∫øu xu·ªëng nh·ªØng m√°i nh√† tranh, t·∫°o n√™n b·ª©c tranh thanh b√¨nh ƒë·∫ßy n√™n th∆°.',
                    'Cung ƒëi·ªán nguy nga tr√°ng l·ªá v·ªõi nh·ªØng c·ªôt ƒë√° kh·ªïng l·ªì ƒë·ª©ng s·ª´ng s·ªØng gi·ªØa tr·ªùi xanh. B√™n trong nh·ªØng b·ª©c t∆∞·ªùng d√†y, nh·ªØng b√≠ m·∫≠t h√†ng ngh√¨n nƒÉm tu·ªïi ƒëang ch·ªù ƒë∆∞·ª£c kh√°m ph√°. Ti·∫øng b∆∞·ªõc ch√¢n v·ªçng l·∫°i trong h√†nh lang d√†i, b√°o hi·ªáu s·ª± xu·∫•t hi·ªán c·ªßa m·ªôt nh√¢n v·∫≠t quan tr·ªçng.',
                    'Th∆∞ vi·ªán c·ªï v·ªõi h√†ng ngh√¨n cu·ªën s√°ch c≈© k·ªπ ch·ª©a ƒë·ª±ng tri th·ª©c c·ªßa c√°c th·∫ø h·ªá tr∆∞·ªõc. M√πi gi·∫•y c≈© v√† b·ª•i th·ªùi gian t·∫°o n√™n kh√¥ng kh√≠ ƒë·∫∑c bi·ªát, khi·∫øn ai c≈©ng c·∫£m th·∫•y ƒë∆∞·ª£c s·ª± thi√™ng li√™ng c·ªßa bil·∫øt th·ª©c. Trong √°nh s√°ng m·ªù ·∫£o c·ªßa nh·ªØng ng·ªçn n·∫øn, m·ªôt cu·ªën s√°ch b√≠ ·∫©n ƒëang ch·ªù ƒë∆∞·ª£c m·ªü ra.'
                ],
                risingAction: [
                    'T√¨nh h√¨nh b·∫Øt ƒë·∫ßu tr·ªü n√™n ph·ª©c t·∫°p khi nh·ªØng s·ª± ki·ªán b·∫•t ng·ªù li√™n ti·∫øp x·∫£y ra. M·ªói b∆∞·ªõc ƒëi ƒë·ªÅu mang theo nh·ªØng th·ª≠ th√°ch m·ªõi, khi·∫øn nh√¢n v·∫≠t ch√≠nh ph·∫£i suy nghƒ© k·ªπ l∆∞·ª°ng tr∆∞·ªõc m·ªói quy·∫øt ƒë·ªãnh. √Åp l·ª±c t·ª´ nhi·ªÅu ph√≠a kh√°c nhau ƒëang d·∫ßn gia tƒÉng, t·∫°o n√™n m·ªôt cu·ªôc xung ƒë·ªôt kh√¥ng th·ªÉ tr√°nh kh·ªèi.',
                    'Nh·ªØng manh m·ªëi b√≠ ·∫©n d·∫ßn ƒë∆∞·ª£c gh√©p l·∫°i v·ªõi nhau, t·∫°o th√†nh b·ª©c tranh to√†n c·∫£nh v·ªÅ √¢m m∆∞u ƒë·∫±ng sau m·ªçi s·ª± vi·ªác. K·∫ª th√π kh√¥ng c√≤n ·∫©n n√°u trong b√≥ng t·ªëi n·ªØa m√† ƒë√£ b·∫Øt ƒë·∫ßu l·ªô di·ªán v·ªõi nh·ªØng h√†nh ƒë·ªông t√°o b·∫°o. Cu·ªôc ƒë·∫•u tranh gi·ªØa thi·ªán v√† √°c ƒëang b∆∞·ªõc v√†o giai ƒëo·∫°n quy·∫øt li·ªát.',
                    'S·ª©c m·∫°nh b√™n trong nh√¢n v·∫≠t ch√≠nh ƒëang d·∫ßn th·ª©c t·ªânh, mang theo c·∫£ c∆° h·ªôi v√† nguy hi·ªÉm. M·ªói l·∫ßn s·ª≠ d·ª•ng nƒÉng l·ª±c ƒë·∫∑c bi·ªát ƒë·ªÅu ƒë·ªÉ l·∫°i nh·ªØng h·∫≠u qu·∫£ kh√¥ng l∆∞·ªùng tr∆∞·ªõc ƒë∆∞·ª£c. Cu·ªôc h√†nh tr√¨nh tr·ªü n√™n nguy hi·ªÉm h∆°n bao gi·ªù h·∫øt khi nh·ªØng th·∫ø l·ª±c h·∫Øc √°m b·∫Øt ƒë·∫ßu ch√∫ √Ω.'
                ],
                climax: [
                    'Kho·∫£nh kh·∫Øc quy·∫øt ƒë·ªãnh ƒë√£ ƒë·∫øn, khi t·∫•t c·∫£ m·ªçi th·ª© ƒë·ªÅu ph·ª• thu·ªôc v√†o m·ªôt l·ª±a ch·ªçn duy nh·∫•t. Kh√¥ng kh√≠ cƒÉng th·∫≥ng ƒë·∫øn m·ª©c c√≥ th·ªÉ c·∫Øt ƒë∆∞·ª£c b·∫±ng dao, m·ªçi ng∆∞·ªùi ƒë·ªÅu n√≠n th·ªü ch·ªù ƒë·ª£i k·∫øt qu·∫£. ƒê√¢y l√† l√∫c m√† t·∫•t c·∫£ nh·ªØng chu·∫©n b·ªã, nh·ªØng hy sinh c·ªßa qu√° kh·ª© s·∫Ω ƒë∆∞·ª£c ƒë·ªÅn ƒë√°p.',
                    'Tr·∫≠n chi·∫øn cu·ªëi c√πng b√πng n·ªï v·ªõi s·ª©c m·∫°nh kinh ho√†ng, l√†m rung chuy·ªÉn c·∫£ ƒë·∫•t tr·ªùi. Nh·ªØng ƒë√≤n t·∫•n c√¥ng m·∫°nh m·∫Ω trao ƒë·ªïi li√™n t·ª•c, t·∫°o n√™n nh·ªØng ti·∫øng n·ªï ch·∫•n ƒë·ªông. Kh√¥ng ai c√≥ th·ªÉ ƒëo√°n tr∆∞·ªõc ƒë∆∞·ª£c k·∫øt qu·∫£ c·ªßa cu·ªôc ƒë·ªëi ƒë·∫ßu n√†y.',
                    'S·ª± th·∫≠t cu·ªëi c√πng ƒë∆∞·ª£c ph∆°i b√†y trong √°nh s√°ng ch√≥i l√≤a c·ªßa c√¥ng l√Ω. T·∫•t c·∫£ nh·ªØng l·ªùi n√≥i d·ªëi, nh·ªØng √¢m m∆∞u ƒë·ªÅu b·ªã v·∫°ch tr·∫ßn tr∆∞·ªõc m·∫Øt m·ªçi ng∆∞·ªùi. ƒê√¢y l√† l√∫c m√† nh√¢n v·∫≠t ch√≠nh ph·∫£i ƒë·ªëi m·∫∑t v·ªõi l·ª±a ch·ªçn kh√≥ khƒÉn nh·∫•t trong ƒë·ªùi.'
                ],
                resolution: [
                    'Sau c∆°n b√£o t·ªë, cu·ªëi c√πng b√¨nh y√™n c≈©ng tr·ªü l·∫°i v·ªõi m·ªçi ng∆∞·ªùi. Nh·ªØng v·∫øt th∆∞∆°ng l√≤ng d·∫ßn ƒë∆∞·ª£c ch·ªØa l√†nh b·ªüi t√¨nh y√™u th∆∞∆°ng v√† s·ª± tha th·ª©. Cu·ªôc s·ªëng b·∫Øt ƒë·∫ßu m·ªôt trang m·ªõi v·ªõi nh·ªØng hi v·ªçng t∆∞∆°i s√°ng cho t∆∞∆°ng lai.',
                    'Nh·ªØng b√†i h·ªçc qu√Ω b√°u t·ª´ h√†nh tr√¨nh ƒë√£ tr·ªü th√†nh h√†nh trang qu√Ω gi√° cho nh·ªØng ng√†y th√°ng ti·∫øp theo. T√¨nh b·∫°n v√† t√¨nh y√™u th∆∞∆°ng ƒë√£ ƒë∆∞·ª£c c·ªßng c·ªë qua nh·ªØng th·ª≠ th√°ch kh·∫Øc nghi·ªát. M·ªói ng∆∞·ªùi ƒë·ªÅu t√¨m th·∫•y v·ªã tr√≠ c·ªßa m√¨nh trong cu·ªôc ƒë·ªùi.',
                    'T∆∞∆°ng lai r·ªông m·ªü v·ªõi v√¥ v√†n kh·∫£ nƒÉng v√† c∆° h·ªôi m·ªõi. Nh·ªØng ∆∞·ªõc m∆° t·ª´ng t∆∞·ªüng ch·ª´ng nh∆∞ kh√¥ng th·ªÉ th·ª±c hi·ªán nay ƒë√£ tr·ªü th√†nh hi·ªán th·ª±c. H√†nh tr√¨nh k·∫øt th√∫c nh∆∞ng cu·ªôc phi√™u l∆∞u c·ªßa cu·ªôc ƒë·ªùi v·∫´n ti·∫øp t·ª•c.'
                ]
            };

            const templates = contentTemplates[chapterInfo.type] || contentTemplates['setup'];
            return templates[paragraphIndex % templates.length] || templates[0];
        }

        function generateShortParagraph(chapterInfo, genre) {
            const shortParagraphs = [
                'Gi√≥ th·ªïi nh·∫π qua t√≥c, mang theo h∆∞∆°ng th∆°m c·ªßa nh·ªØng b√¥ng hoa d·∫°i.',
                '√Ånh trƒÉng s√°ng r·ªçi xu·ªëng m·∫∑t n∆∞·ªõc, t·∫°o n√™n nh·ªØng l·ª£n s√≥ng √°nh b·∫°c.',
                'Ti·∫øng chim h√≥t v√©o von trong r·ª´ng, nh∆∞ nh·ªØng b·∫£n nh·∫°c du d∆∞∆°ng c·ªßa thi√™n nhi√™n.',
                'M√πi ƒë·∫•t sau c∆°n m∆∞a t·∫°o n√™n kh√¥ng kh√≠ trong l√†nh v√† m√°t m·∫ª.',
                'Nh·ªØng ƒë√°m m√¢y tr·∫Øng tr√¥i l·ªØng l·ªù tr√™n b·∫ßu tr·ªùi xanh bi·∫øc.',
                '√Ånh s√°ng ƒë√®n l·ªìng ƒë·ªè t·∫°o n√™n kh√¥ng kh√≠ ·∫•m c√∫ng c·ªßa bu·ªïi t·ªëi.',
                'Ti·∫øng su·ªëi ch·∫£y r√≥c r√°ch nh∆∞ ti·∫øng h√°t ru c·ªßa m·∫π thi√™n nhi√™n.',
                'Nh·ªØng ng√¥i sao l·∫•p l√°nh nh∆∞ kim c∆∞∆°ng tr√™n t·∫•m nhung ƒëen c·ªßa b·∫ßu tr·ªùi ƒë√™m.'
            ];
            
            return shortParagraphs[Math.floor(Math.random() * shortParagraphs.length)];
        }

        function generateClosingParagraph(chapterNumber, totalChapters, chapterInfo, genre) {
            if (chapterNumber === totalChapters) {
                // Final chapter ending
                return 'C√¢u chuy·ªán ƒë·∫øn ƒë√¢y ƒë√£ kh√©p l·∫°i, nh∆∞ng nh·ªØng k·ª∑ ni·ªám ƒë·∫πp s·∫Ω m√£i t·ªìn t·∫°i trong tr√°i tim m·ªói ng∆∞·ªùi. T∆∞∆°ng lai ƒëang ch·ªù ƒë·ª£i ph√≠a tr∆∞·ªõc v·ªõi nh·ªØng ƒëi·ªÅu t·ªët ƒë·∫πp v√† hi v·ªçng m·ªõi. ƒê√¢y kh√¥ng ph·∫£i l√† k·∫øt th√∫c, m√† l√† kh·ªüi ƒë·∫ßu cho m·ªôt ch∆∞∆°ng m·ªõi c·ªßa cu·ªôc ƒë·ªùi.';
            }
            
            const closingTemplates = [
                'Khi m√†n ƒë√™m bu√¥ng xu·ªëng, nh·ªØng suy nghƒ© v·ªÅ ng√†y h√¥m nay v·∫´n c√≤n ƒëang l·ªün v·ªün trong t√¢m tr√≠. Ng√†y mai s·∫Ω mang ƒë·∫øn nh·ªØng th·ª≠ th√°ch m·ªõi, nh∆∞ng c≈©ng l√† c∆° h·ªôi ƒë·ªÉ ch·ª©ng minh b·∫£n th√¢n.',
                '√Ånh s√°ng cu·ªëi ng√†y d·∫ßn t·∫Øt, b√°o hi·ªáu m·ªôt ng√†y ƒë√£ qua ƒëi. Nh∆∞ng trong l√≤ng m·ªói ng∆∞·ªùi, ng·ªçn l·ª≠a hy v·ªçng v·∫´n ch√°y m√£i kh√¥ng t·∫Øt, soi s√°ng con ƒë∆∞·ªùng ph√≠a tr∆∞·ªõc.',
                'D∆∞·ªõi b·∫ßu tr·ªùi ƒë·∫ßy sao, nh·ªØng quy·∫øt ƒë·ªãnh c·ªßa h√¥m nay s·∫Ω ƒë·ªãnh h√¨nh t∆∞∆°ng lai c·ªßa ng√†y mai. Cu·ªôc h√†nh tr√¨nh v·∫´n c√≤n d√†i, v√† c√≤n nhi·ªÅu ƒëi·ªÅu b·∫•t ng·ªù ƒëang ch·ªù ƒë√≥n.',
                'Khi ti·∫øng chu√¥ng ƒë·ªìng h·ªì ƒëi·ªÉm gi·ªù vang l√™n, m·ªôt ch∆∞∆°ng m·ªõi c·ªßa c√¢u chuy·ªán chu·∫©n b·ªã ƒë∆∞·ª£c m·ªü ra. Nh·ªØng g√¨ ƒë√£ x·∫£y ra h√¥m nay ch·ªâ l√† kh·ªüi ƒë·∫ßu cho nh·ªØng ƒëi·ªÅu k·ª≥ di·ªáu s·∫Øp t·ªõi.',
                'Gi√≥ ƒë√™m th·ªïi qua khung c·ª≠a s·ªï, mang theo nh·ªØng ∆∞·ªõc m∆° v√† kh√°t v·ªçng v·ªÅ t∆∞∆°ng lai. Trong gi·∫•c ng·ªß s√¢u, nh·ªØng gi·∫•c m∆° ƒë·∫πp s·∫Ω chu·∫©n b·ªã cho m·ªôt ng√†y m·ªõi tr√†n ƒë·∫ßy nƒÉng l∆∞·ª£ng.'
            ];
            
            return closingTemplates[Math.floor(Math.random() * closingTemplates.length)];
        }

        function generateDialogueSection(chapterInfo, genre) {
            const dialogues = [
                `"T√¥i kh√¥ng th·ªÉ tin ƒë∆∞·ª£c ƒëi·ªÅu n√†y ƒëang x·∫£y ra," ${generateCharacterName()} th·ªü d√†i.\n\n"H√£y tin t∆∞·ªüng v√†o b·∫£n th√¢n m√¨nh," ng∆∞·ªùi b·∫°n ƒë·ªìng h√†nh tr·∫£ l·ªùi v·ªõi gi·ªçng ƒëi·ªáu kh√≠ch l·ªá. "Ch√∫ng ta ƒë√£ v∆∞·ª£t qua bao nhi·ªÅu th·ª≠ th√°ch r·ªìi."\n\n"Nh∆∞ng l·∫ßn n√†y kh√°c, t√¥i c·∫£m th·∫•y c√≥ g√¨ ƒë√≥ r·∫•t nguy hi·ªÉm ƒëang ch·ªù ƒë·ª£i ch√∫ng ta."\n\nKho·∫£ng l·∫∑ng gi·ªØa hai ng∆∞·ªùi k√©o d√†i, ch·ªâ c√≥ ti·∫øng gi√≥ th·ªïi qua l√° c√¢y t·∫°o n√™n √¢m thanh du d∆∞∆°ng.`,
                
                `"Ch√∫ng ta ph·∫£i l√†m g√¨ b√¢y gi·ªù?" ${generateCharacterName()} h·ªèi v·ªõi v·∫ª lo l·∫Øng.\n\n"ƒê·∫ßu ti√™n, h√£y b√¨nh tƒ©nh," ng∆∞·ªùi d·∫´n ƒë∆∞·ªùng ƒë√°p. "Ho·∫£ng s·ª£ s·∫Ω kh√¥ng gi√∫p ch√∫ng ta gi·∫£i quy·∫øt ƒë∆∞·ª£c v·∫•n ƒë·ªÅ."\n\n"T√¥i c·ªë g·∫Øng, nh∆∞ng m·ªçi th·ª© di·ªÖn ra qu√° nhanh."\n\n"T√¥i hi·ªÉu, nh∆∞ng ch√∫ng ta kh√¥ng c√≥ l·ª±a ch·ªçn n√†o kh√°c. H√£y tin v√†o k·∫ø ho·∫°ch c·ªßa ch√∫ng ta."`,
                
                `"Anh c√≥ th·∫•y ƒëi·ªÅu g√¨ l·∫° kh√¥ng?" ${generateCharacterName()} th·∫ßm th√¨.\n\n"C√≥, t√¥i c≈©ng c·∫£m nh·∫≠n ƒë∆∞·ª£c. C√≥ ai ƒë√≥ ƒëang theo d√µi ch√∫ng ta," ng∆∞·ªùi b·∫°n ƒë√°p l·∫°i b·∫±ng gi·ªçng th·∫≠t nh·ªè.\n\n"Ch√∫ng ta n√™n l√†m g√¨?"\n\n"C·ª© l√†m nh∆∞ b√¨nh th∆∞·ªùng, ƒë·ª´ng ƒë·ªÉ l·ªô r·∫±ng ch√∫ng ta ƒë√£ bi·∫øt."`,
                
                `"T√¥i nghƒ© ch√∫ng ta ƒë√£ t√¨m ra c√¢u tr·∫£ l·ªùi," ${generateCharacterName()} n√≥i v·ªõi v·∫ª ph·∫•n kh√≠ch.\n\n"Th·∫≠t sao? H√£y k·ªÉ cho t√¥i nghe," ng∆∞·ªùi nghe t·ªè ra r·∫•t quan t√¢m.\n\n"T·∫•t c·∫£ m·ªçi th·ª© ƒë·ªÅu li√™n quan ƒë·∫øn nhau theo m·ªôt c√°ch m√† ch√∫ng ta ch∆∞a t·ª´ng nghƒ© t·ªõi."\n\n"ƒêi·ªÅu ƒë√≥ c√≥ nghƒ©a l√† ch√∫ng ta ƒë√£ g·∫ßn ƒë·∫øn ƒë√≠ch r·ªìi."`,
                
                `"Em c√≥ s·ª£ kh√¥ng?" ${generateCharacterName()} h·ªèi nh·∫π nh√†ng.\n\n"M·ªôt ch√∫t," c√¥ g√°i ƒë√°p th√†nh th·∫≠t. "Nh∆∞ng khi c√≥ anh b√™n c·∫°nh, em c·∫£m th·∫•y an t√¢m h∆°n."\n\n"Em tin t∆∞·ªüng t√¥i ch·ª©?"\n\n"T√¥i tin anh h∆°n b·∫•t c·ª© ai tr√™n ƒë·ªùi n√†y."`,
            ];
            
            return dialogues[Math.floor(Math.random() * dialogues.length)];
        }

        function generateCharacterName() {
            const names = [
                'Minh Anh', 'Thu H√†', 'ƒê·ª©c Long', 'Ph∆∞∆°ng Linh', 'VƒÉn H√πng', 
                'Ng·ªçc Mai', 'Quang D≈©ng', 'H·∫°nh Chi', 'Tu·∫•n Anh', 'Lan Ph∆∞∆°ng',
                'Ho√†ng Nam', 'Th·ªßy Ti√™n', 'B·∫£o Trung', 'C·∫©m Ly', 'Duy Khang',
                'Thanh Nga', 'Minh Qu√¢n', 'H∆∞∆°ng Giang', 'ƒê√¨nh B·∫£o', 'Kim Oanh'
            ];
            return names[Math.floor(Math.random() * names.length)];
        }

        function displayGeneratedStory() {
            const storyOutput = document.getElementById('storyOutput');
            const storyContent = document.getElementById('storyContent');
            
            let html = `
                <div style="text-align: center; margin-bottom: 24px; padding: 16px; background: linear-gradient(135deg, #f0f9ff, #e0f2fe); border-radius: 12px;">
                    <h3 style="color: #1d4ed8; margin-bottom: 8px; font-size: 24px;">${currentStory.title}</h3>
                    <p style="color: #64748b; font-size: 14px; margin-bottom: 8px;">
                        ${getGenreVietnamese(currentStory.genre)} ‚Ä¢ ${currentStory.chapters.length} ch∆∞∆°ng ‚Ä¢ ${formatNumber(currentStory.totalWords)} t·ª´
                    </p>
                    <p style="color: #64748b; font-size: 12px;">
                        T·∫°o l√∫c ${currentStory.createdAt.toLocaleString('vi-VN')} ‚Ä¢ D·ª±a tr√™n ${currentStory.metadata.sourceStories} truy·ªán g·ªëc
                    </p>
                </div>
            `;

            // Show first 3 chapters as preview
            const previewChapters = currentStory.chapters.slice(0, 3);
            
            previewChapters.forEach((chapter, index) => {
                const preview = chapter.content.split('\n\n').slice(0, 3).join('\n\n');
                html += `
                    <div class="chapter">
                        <div class="chapter-title">${chapter.title}</div>
                        <div class="chapter-meta">${formatNumber(chapter.wordCount)} t·ª´ ‚Ä¢ ${chapter.type}</div>
                        <div style="color: #64748b; line-height: 1.6; margin-bottom: 12px;">
                            ${preview}...
                        </div>
                        <div style="font-size: 12px; color: #8e8e93; font-style: italic;">
                            [ƒê√£ r√∫t g·ªçn - Xem ƒë·∫ßy ƒë·ªß khi t·∫£i xu·ªëng]
                        </div>
                    </div>
                `;
            });

            if (currentStory.chapters.length > 3) {
                html += `
                    <div style="text-align: center; padding: 16px; color: #64748b; font-style: italic; background: #f8fafc; border-radius: 8px; margin-top: 16px;">
                        ... v√† ${currentStory.chapters.length - 3} ch∆∞∆°ng kh√°c<br>
                        <small>T·ªïng c·ªông: ${formatNumber(currentStory.totalWords)} t·ª´</small>
                    </div>
                `;
            }

            storyContent.innerHTML = html;
            storyOutput.classList.remove('hidden');
            document.getElementById('uploadBtn').classList.remove('hidden');
            document.getElementById('downloadBtn').classList.remove('hidden');
        }

        // Upload and download functions
        async function uploadStoryToDrive() {
            if (!currentStory) {
                showStatus('Ch∆∞a c√≥ truy·ªán ƒë·ªÉ t·∫£i l√™n', 'error');
                return;
            }

            document.getElementById('uploadBtn').disabled = true;
            showStatus('ƒêang t·∫£i l√™n Google Drive...', 'info');

            try {
                // Create detailed story content
                let storyText = `${currentStory.title}\n`;
                storyText += '='.repeat(currentStory.title.length) + '\n\n';
                storyText += `Th·ªÉ lo·∫°i: ${getGenreVietnamese(currentStory.genre)}\n`;
                storyText += `T√°c gi·∫£: AI Story Generator Pro\n`;
                storyText += `Ng√†y t·∫°o: ${currentStory.createdAt.toLocaleString('vi-VN')}\n`;
                storyText += `S·ªë ch∆∞∆°ng: ${currentStory.chapters.length}\n`;
                storyText += `T·ªïng s·ªë t·ª´: ${formatNumber(currentStory.totalWords)}\n`;
                storyText += `D·ª±a tr√™n: ${currentStory.metadata.sourceStories} truy·ªán g·ªëc\n\n`;
                storyText += '='.repeat(50) + '\n\n';

                currentStory.chapters.forEach((chapter, index) => {
                    storyText += `${chapter.title}\n`;
                    storyText += `(${formatNumber(chapter.wordCount)} t·ª´)\n\n`;
                    storyText += `${chapter.content}\n\n`;
                    
                    if (index < currentStory.chapters.length - 1) {
                        storyText += '-'.repeat(30) + '\n\n';
                    }
                });

                storyText += '\n' + '='.repeat(50) + '\n';
                storyText += 'H·∫æT\n';
                storyText += `ƒê∆∞·ª£c t·∫°o b·ªüi AI Story Analyzer Pro\n`;
                storyText += `${currentStory.createdAt.toLocaleString('vi-VN')}`;

                const fileMetadata = {
                    name: `${currentStory.title}.txt`,
                    parents: await getQuanLyTruyenFolderId()
                };

                const response = await gapi.client.request({
                    path: 'https://www.googleapis.com/upload/drive/v3/files',
                    method: 'POST',
                    params: { uploadType: 'multipart' },
                    headers: { 'Content-Type': 'multipart/related; boundary="foo_bar_baz"' },
                    body: createMultipartBody(fileMetadata, storyText)
                });

                showStatus(`ƒê√£ t·∫£i l√™n "${currentStory.title}.txt"`, 'success');
                log('Story uploaded:', response.result);
                
                // Refresh file list
                await loadFiles();
                
            } catch (error) {
                log('Upload error:', error);
                showStatus('L·ªói t·∫£i l√™n', 'error');
            } finally {
                document.getElementById('uploadBtn').disabled = false;
            }
        }

        function downloadStory() {
            if (!currentStory) {
                showStatus('Ch∆∞a c√≥ truy·ªán ƒë·ªÉ t·∫£i xu·ªëng', 'error');
                return;
            }

            try {
                // Create complete story content
                let storyText = `${currentStory.title}\n`;
                storyText += '='.repeat(currentStory.title.length) + '\n\n';
                storyText += `Th·ªÉ lo·∫°i: ${getGenreVietnamese(currentStory.genre)}\n`;
                storyText += `T√°c gi·∫£: AI Story Generator Pro\n`;
                storyText += `Ng√†y t·∫°o: ${currentStory.createdAt.toLocaleString('vi-VN')}\n`;
                storyText += `S·ªë ch∆∞∆°ng: ${currentStory.chapters.length}\n`;
                storyText += `T·ªïng s·ªë t·ª´: ${formatNumber(currentStory.totalWords)}\n\n`;
                storyText += '='.repeat(50) + '\n\n';

                currentStory.chapters.forEach((chapter, index) => {
                    storyText += `${chapter.title}\n`;
                    storyText += `(${formatNumber(chapter.wordCount)} t·ª´)\n\n`;
                    storyText += `${chapter.content}\n\n`;
                    
                    if (index < currentStory.chapters.length - 1) {
                        storyText += '-'.repeat(30) + '\n\n';
                    }
                });

                // Create and download file
                const blob = new Blob([storyText], { type: 'text/plain;charset=utf-8' });
                const url = window.URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = `${currentStory.title}.txt`;
                document.body.appendChild(a);
                a.click();
                window.URL.revokeObjectURL(url);
                document.body.removeChild(a);

                showStatus('ƒê√£ t·∫£i xu·ªëng truy·ªán', 'success');
            } catch (error) {
                log('Download error:', error);
                showStatus('L·ªói t·∫£i xu·ªëng', 'error');
            }
        }

        async function getQuanLyTruyenFolderId() {
            const response = await gapi.client.drive.files.list({
                q: "name='QuanLyTruyen' and mimeType='application/vnd.google-apps.folder' and trashed=false",
                fields: 'files(id)',
            });

            if (response.result.files.length > 0) {
                return [response.result.files[0].id];
            }
            
            throw new Error('Th∆∞ m·ª•c QuanLyTruyen kh√¥ng t·ªìn t·∫°i');
        }

        function createMultipartBody(metadata, data) {
            const delimiter = 'foo_bar_baz';
            const close_delim = `\r\n--${delimiter}--`;
            
            let body = `--${delimiter}\r\n`;
            body += 'Content-Type: application/json\r\n\r\n';
            body += JSON.stringify(metadata) + '\r\n';
            body += `--${delimiter}\r\n`;
            body += 'Content-Type: text/plain\r\n\r\n';
            body += data;
            body += close_delim;
            
            return body;
        }

        // Export and Import functions
        async function exportData() {
            try {
                const exportData = {
                    storyFiles,
                    analyzedFiles: Array.from(analyzedFiles),
                    storyData: storyData.map(story => ({
                        name: story.name,
                        folderPath: story.folderPath,
                        analysis: story.analysis,
                        advancedAnalysis: story.advancedAnalysis
                    })),
                    storyPatterns,
                    characterAnalysis: {
                        ...characterAnalysis,
                        characterNames: Array.from(characterAnalysis.characterNames)
                    },
                    plotStructure,
                    narrativeStyle,
                    vocabulary,
                    exportTime: new Date().toISOString()
                };

                const blob = new Blob([JSON.stringify(exportData, null, 2)], { 
                    type: 'application/json' 
                });
                const url = window.URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = `ai_story_data_${new Date().toISOString().split('T')[0]}.json`;
                document.body.appendChild(a);
                a.click();
                window.URL.revokeObjectURL(url);
                document.body.removeChild(a);

                showStatus('ƒê√£ xu·∫•t d·ªØ li·ªáu', 'success');
            } catch (error) {
                log('Export error:', error);
                showStatus('L·ªói xu·∫•t d·ªØ li·ªáu', 'error');
            }
        }

        function importData() {
            const input = document.createElement('input');
            input.type = 'file';
            input.accept = '.json';
            
            input.onchange = async (event) => {
                try {
                    const file = event.target.files[0];
                    if (!file) return;

                    const text = await file.text();
                    const importData = JSON.parse(text);

                    // Restore data
                    storyFiles = importData.storyFiles || [];
                    analyzedFiles = new Set(importData.analyzedFiles || []);
                    storyData = importData.storyData || [];
                    storyPatterns = importData.storyPatterns || {};
                    characterAnalysis = {
                        ...importData.characterAnalysis,
                        characterNames: new Set(importData.characterAnalysis?.characterNames || [])
                    };
                    plotStructure = importData.plotStructure || {};
                    narrativeStyle = importData.narrativeStyle || {};
                    vocabulary = importData.vocabulary || {};

                    // Update UI
                    displayFiles();
                    if (storyData.length > 0) {
                        showAnalysisResults();
                        document.getElementById('generateBtn').disabled = false;
                    }
                    
                    updateDataStatus('ƒê√£ nh·∫≠p t·ª´ file', new Date());
                    showStatus('ƒê√£ nh·∫≠p d·ªØ li·ªáu th√†nh c√¥ng', 'success');
                    
                    // Save to cache
                    await saveCacheData();
                    
                } catch (error) {
                    log('Import error:', error);
                    showStatus('L·ªói nh·∫≠p d·ªØ li·ªáu - File kh√¥ng h·ª£p l·ªá', 'error');
                }
            };
            
            input.click();
        }

        // Event listeners
        function setupEventListeners() {
            document.getElementById('loginBtn').addEventListener('click', () => {
                if (gapiInited && gisInited) {
                    tokenClient.requestAccessToken({prompt: 'consent'});
                } else {
                    showStatus('ƒêang kh·ªüi t·∫°o...', 'info');
                }
            });

            document.getElementById('logoutBtn').addEventListener('click', () => {
                const token = gapi.client.getToken();
                if (token) {
                    google.accounts.oauth2.revoke(token.access_token);
                    gapi.client.setToken('');
                }
                location.reload();
            });

            document.getElementById('loadFilesBtn').addEventListener('click', loadFiles);
            document.getElementById('loadCacheBtn').addEventListener('click', loadCachedData);
            document.getElementById('clearCacheBtn').addEventListener('click', clearCache);
            document.getElementById('analyzeBtn').addEventListener('click', analyzeStories);
            document.getElementById('trainBtn').addEventListener('click', trainAI);
            document.getElementById('generateBtn').addEventListener('click', generateStory);
            document.getElementById('uploadBtn').addEventListener('click', uploadStoryToDrive);
            document.getElementById('downloadBtn').addEventListener('click', downloadStory);
            document.getElementById('saveAnalysisBtn').addEventListener('click', saveAnalysisData);
            document.getElementById('exportDataBtn').addEventListener('click', exportData);
            document.getElementById('importDataBtn').addEventListener('click', importData);
        }

        // Initialize app
        function initApp() {
            log('Initializing AI Story Analyzer Pro...');
            initNavigation();
            setupEventListeners();
            
            // Load Google APIs
            if (typeof gapi !== 'undefined') {
                gapiLoaded();
            }
            if (typeof google !== 'undefined' && google.accounts) {
                gisLoaded();
            }
        }

        // Start app when DOM is ready
        document.addEventListener('DOMContentLoaded', initApp);
        window.addEventListener('load', initApp);
    </script>
</body>
</html>
