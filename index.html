<!DOCTYPE html>
<html lang="vi">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Qu·∫£n l√Ω Truy·ªán - Google Drive Database</title>
    <script src="https://apis.google.com/js/api.js"></script>
    <script src="https://accounts.google.com/gsi/client"></script>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: linear-gradient(135deg, #1a1a2e 0%, #16213e 50%, #0f3460 100%);
            min-height: 100vh; 
            color: #ffffff;
            overflow-x: hidden;
        }
        .container {
            max-width: 100%;
            background: rgba(255, 255, 255, 0.05);
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.1);
            min-height: 100vh;
        }
        .header { 
            background: linear-gradient(45deg, #667eea, #764ba2); 
            color: white; 
            padding: 20px 15px;
            text-align: center; 
            position: sticky;
            top: 0;
            z-index: 100;
            backdrop-filter: blur(10px);
        }
        .header h1 { 
            font-size: 1.8em; 
            margin-bottom: 5px;
            font-weight: 700;
        }
        .header p {
            font-size: 0.9em;
            opacity: 0.9;
        }
        .main-content { 
            padding: 15px;
            padding-bottom: 80px;
        }
        .auth-section { 
            text-align: center; 
            margin-bottom: 20px;
            background: rgba(255, 255, 255, 0.05);
            padding: 20px;
            border-radius: 15px;
            border: 1px solid rgba(255, 255, 255, 0.1);
        }
        .btn {
            background: linear-gradient(45deg, #667eea, #764ba2);
            color: white; 
            border: none; 
            padding: 12px 20px;
            border-radius: 25px; 
            font-size: 14px; 
            cursor: pointer;
            transition: all 0.3s ease; 
            margin: 5px;
            min-height: 44px;
            display: inline-flex;
            align-items: center;
            justify-content: center;
            font-weight: 600;
            box-shadow: 0 4px 15px rgba(102, 126, 234, 0.3);
        }
        .btn:hover, .btn:active { 
            transform: translateY(-2px); 
            box-shadow: 0 6px 20px rgba(102, 126, 234, 0.4);
        }
        .btn:disabled { 
            opacity: 0.5; 
            cursor: not-allowed; 
            transform: none;
        }
        .btn.danger {
            background: linear-gradient(45deg, #ff6b6b, #ff5252);
            box-shadow: 0 4px 15px rgba(255, 107, 107, 0.3);
        }
        .btn.success {
            background: linear-gradient(45deg, #4ecdc4, #44a08d);
            box-shadow: 0 4px 15px rgba(78, 205, 196, 0.3);
        }
        .btn.info {
            background: linear-gradient(45deg, #45aaf2, #2d98da);
            box-shadow: 0 4px 15px rgba(69, 170, 242, 0.3);
        }
        .form-section {
            background: rgba(255, 255, 255, 0.05);
            padding: 20px; 
            border-radius: 15px; 
            margin-bottom: 20px;
            border: 1px solid rgba(255, 255, 255, 0.1);
            backdrop-filter: blur(10px);
        }
        .form-section h2 {
            margin-bottom: 20px;
            color: #ffffff;
            font-size: 1.3em;
        }
        .form-group { 
            margin-bottom: 20px; 
        }
        .form-group label { 
            display: block; 
            margin-bottom: 8px; 
            font-weight: 600; 
            color: #ffffff;
            font-size: 14px;
        }
        .form-group input, .form-group textarea, .form-group select {
            width: 100%; 
            padding: 15px; 
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 12px; 
            font-size: 16px; 
            transition: all 0.3s ease;
            background: rgba(255, 255, 255, 0.1);
            color: #ffffff;
            backdrop-filter: blur(5px);
        }
        .form-group input::placeholder,
        .form-group textarea::placeholder {
            color: rgba(255, 255, 255, 0.6);
        }
        .form-group input:focus,
        .form-group textarea:focus,
        .form-group select:focus {
            outline: none;
            border-color: #667eea;
            box-shadow: 0 0 0 3px rgba(102, 126, 234, 0.2);
            background: rgba(255, 255, 255, 0.15);
        }
        .form-group textarea { 
            min-height: 120px; 
            resize: vertical; 
        }
        .history-section {
            background: rgba(255, 255, 255, 0.05);
            border-radius: 15px; 
            overflow: hidden;
            margin-bottom: 20px;
            border: 1px solid rgba(255, 255, 255, 0.1);
        }
        .history-header { 
            background: linear-gradient(45deg, #667eea, #764ba2); 
            color: white; 
            padding: 15px; 
            text-align: center;
        }
        .history-header h2 {
            font-size: 1.2em;
        }
        .history-list { 
            max-height: 300px; 
            overflow-y: auto; 
        }
        .history-item { 
            padding: 15px; 
            border-bottom: 1px solid rgba(255, 255, 255, 0.1); 
            transition: background-color 0.3s ease;
        }
        .history-item:hover, .history-item:active { 
            background-color: rgba(255, 255, 255, 0.1); 
        }
        .story-title { 
            font-weight: 600; 
            color: #ffffff; 
            margin-bottom: 5px;
            font-size: 16px;
        }
        .story-chapter { 
            color: rgba(255, 255, 255, 0.7); 
            font-size: 14px; 
            margin-bottom: 5px; 
        }
        .story-date { 
            color: rgba(255, 255, 255, 0.5); 
            font-size: 12px; 
        }
        .status { 
            padding: 15px; 
            border-radius: 12px; 
            margin: 15px 0; 
            display: none;
            font-weight: 600;
        }
        .status.success { 
            background: rgba(78, 205, 196, 0.2); 
            color: #4ecdc4; 
            border: 1px solid rgba(78, 205, 196, 0.3);
        }
        .status.error { 
            background: rgba(255, 107, 107, 0.2); 
            color: #ff6b6b; 
            border: 1px solid rgba(255, 107, 107, 0.3);
        }
        .loading { 
            display: none; 
            text-align: center; 
            padding: 30px;
            background: rgba(255, 255, 255, 0.05);
            border-radius: 15px;
            margin: 20px 0;
        }
        .spinner {
            border: 3px solid rgba(255, 255, 255, 0.1); 
            border-top: 3px solid #667eea;
            border-radius: 50%; 
            width: 40px; 
            height: 40px;
            animation: spin 1s linear infinite; 
            margin: 0 auto 15px;
        }
        @keyframes spin { 
            0% { transform: rotate(0deg); } 
           100% { transform: rotate(360deg); } 
        }
        .grid { 
            display: flex;
            flex-direction: column;
            gap: 20px; 
            margin-top: 20px; 
        }
        
        /* AI Training Section */
        .ai-section {
            background: linear-gradient(135deg, rgba(102, 126, 234, 0.1), rgba(118, 75, 162, 0.1));
            border: 1px solid rgba(102, 126, 234, 0.3);
            padding: 20px;
            border-radius: 15px;
            margin-bottom: 20px;
        }
        .ai-section h2 {
            color: #667eea;
            margin-bottom: 15px;
            font-size: 1.3em;
        }
        .ai-stats {
            background: rgba(255, 255, 255, 0.05);
            padding: 15px;
            border-radius: 10px;
            margin: 15px 0;
        }
        .stat-item {
            display: flex;
            justify-content: space-between;
            margin: 10px 0;
            padding: 8px 0;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
        }
        .stat-item:last-child {
            border-bottom: none;
        }
        
        /* Progress Bar */
        .progress-bar {
            width: 100%;
            height: 6px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 3px;
            overflow: hidden;
            margin: 10px 0;
        }
        .progress-fill {
            height: 100%;
            background: linear-gradient(45deg, #667eea, #764ba2);
            transition: width 0.3s ease;
            width: 0%;
        }
        
        /* AI Generated Stories Section */
        .ai-generated-section {
            background: linear-gradient(135deg, rgba(78, 205, 196, 0.1), rgba(44, 160, 141, 0.1));
            border: 1px solid rgba(78, 205, 196, 0.3);
            padding: 20px;
            border-radius: 15px;
            margin-bottom: 20px;
        }
        .ai-generated-section h2 {
            color: #4ecdc4;
            margin-bottom: 15px;
            font-size: 1.3em;
        }
        .ai-story-controls {
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
            margin-bottom: 15px;
        }
        .ai-story-controls input {
            flex: 1;
            min-width: 150px;
            padding: 12px 15px;
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 25px;
            background: rgba(255, 255, 255, 0.1);
            color: #ffffff;
        }
        .ai-story-list {
            max-height: 300px;
            overflow-y: auto;
            background: rgba(255, 255, 255, 0.05);
            border-radius: 10px;
            padding: 10px;
        }
        .ai-story-item {
            padding: 12px;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
            cursor: pointer;
            transition: background-color 0.3s;
        }
        .ai-story-item:hover {
            background-color: rgba(255, 255, 255, 0.1);
        }
        .ai-story-title {
            font-weight: 600;
            margin-bottom: 5px;
        }
        .ai-story-info {
            font-size: 0.85em;
            color: rgba(255, 255, 255, 0.7);
        }
        
        /* Navigation Menu */
        .nav-menu {
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
            margin-bottom: 20px;
            background: rgba(255, 255, 255, 0.05);
            padding: 15px;
            border-radius: 15px;
            border: 1px solid rgba(255, 255, 255, 0.1);
        }
        .nav-menu button {
            flex: 1;
            min-width: 120px;
        }
        
        /* Content Sections */
        .content-section {
            display: none;
        }
        .content-section.active {
            display: block;
        }
        
        /* Modal for viewing chapters */
        .modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.7);
            z-index: 1000;
            overflow-y: auto;
            padding: 20px;
        }
        .modal-content {
            background: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%);
            margin: 40px auto;
            padding: 20px;
            border-radius: 15px;
            max-width: 800px;
            box-shadow: 0 5px 25px rgba(0, 0, 0, 0.5);
            position: relative;
        }
        .close-modal {
            position: absolute;
            top: 15px;
            right: 20px;
            font-size: 28px;
            font-weight: bold;
            cursor: pointer;
            color: #fff;
        }
        .chapter-list {
            max-height: 400px;
            overflow-y: auto;
            margin: 15px 0;
        }
        .chapter-item {
            padding: 12px;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
            cursor: pointer;
        }
        .chapter-item:hover {
            background-color: rgba(255, 255, 255, 0.1);
        }
        .chapter-content {
            margin-top: 20px;
            padding: 15px;
            background: rgba(255, 255, 255, 0.05);
            border-radius: 10px;
            max-height: 500px;
            overflow-y: auto;
            white-space: pre-wrap;
        }
        .chapter-actions {
            display: flex;
            gap: 10px;
            margin-top: 15px;
        }
        
        /* Th√™m style cho n√∫t vi·∫øt l·∫°i */
        .rewrite-btn {
            background: linear-gradient(45deg, #ff9a3d, #ff6b6b);
            margin-left: 10px;
            padding: 8px 15px;
            font-size: 12px;
        }
        
        .chapter-version {
            margin-top: 10px;
            padding: 10px;
            background: rgba(255, 255, 255, 0.05);
            border-radius: 8px;
            border-left: 3px solid #667eea;
        }
        
        .version-header {
            display: flex;
            justify-content: space-between;
            margin-bottom: 5px;
            font-size: 0.9em;
            color: rgba(255, 255, 255, 0.7);
        }

        /* Style cho ch·∫ø ƒë·ªô ch·ªçn ch·ªß ƒë·ªÅ */
        .theme-selector {
            margin-bottom: 20px;
        }
        .theme-buttons {
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
            margin-top: 10px;
        }
        .theme-btn {
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid rgba(255, 255, 255, 0.2);
            color: white;
            padding: 10px 15px;
            border-radius: 20px;
            cursor: pointer;
            transition: all 0.3s;
        }
        .theme-btn.active {
            background: linear-gradient(45deg, #667eea, #764ba2);
            border-color: rgba(102, 126, 234, 0.5);
        }
        
        /* Th√™m style cho c·∫£nh b√°o n·ªôi dung 18+ */
        .adult-warning {
            background: rgba(255, 107, 107, 0.2);
            border: 1px solid rgba(255, 107, 107, 0.5);
            color: #ff6b6b;
            padding: 15px;
            border-radius: 10px;
            margin: 15px 0;
            text-align: center;
            font-weight: bold;
        }
        
        .adult-toggle {
            display: flex;
            align-items: center;
            margin: 10px 0;
        }
        
        .adult-toggle label {
            margin-left: 10px;
            cursor: pointer;
        }
        
        .adult-content {
            display: none;
        }
        
        .adult-content.active {
            display: block;
        }

        /* ·∫®n n·ªôi dung nh·∫°y c·∫£m m·∫∑c ƒë·ªãnh */
        .sensitive-content {
            filter: blur(8px);
            transition: filter 0.3s ease;
            user-select: none;
        }
        
        .sensitive-content.revealed {
            filter: none;
            user-select: text;
        }
        
        .reveal-btn {
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid rgba(255, 255, 255, 0.3);
            color: white;
            padding: 8px 15px;
            border-radius: 20px;
            cursor: pointer;
            margin: 10px 0;
            font-size: 0.9em;
        }
        
        /* Mobile optimizations */
        @media (max-width: 768px) {
            .header h1 { font-size: 1.6em; }
            .main-content { padding: 10px; }
            .form-section, .history-section { margin-bottom: 15px; }
            .btn { font-size: 14px; padding: 10px 16px; }
            .modal-content { margin: 20px 10px; padding: 15px; }
            .nav-menu { flex-direction: column; }
        }
        
        /* Safe area for iPhone */
        @supports (padding: max(0px)) {
            .container {
                padding-top: max(20px, env(safe-area-inset-top));
                padding-bottom: max(20px, env(safe-area-inset-bottom));
                padding-left: max(10px, env(safe-area-inset-left));
                padding-right: max(10px, env(safe-area-inset-right));
            }
        }
        
        /* Scrollbar styling */
        ::-webkit-scrollbar { width: 6px; }
        ::-webkit-scrollbar-track { background: rgba(255, 255, 255, 0.1); }
        ::-webkit-scrollbar-thumb { background: rgba(102, 126, 234, 0.5); border-radius: 3px; }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>ü§ñ AI Truy·ªán Manager</h1>
            <p>Qu·∫£n l√Ω & Hu·∫•n luy·ªán AI v·ªõi Google Drive</p>
        </div>
        <div class="main-content">
            <div class="auth-section">
                <button id="authorizeButton" class="btn">üîê ƒêƒÉng nh·∫≠p Google Drive</button>
                <button id="signoutButton" class="btn danger" style="display: none;">üö™ ƒêƒÉng xu·∫•t</button>
                <div id="authStatus"></div>
            </div>
            
            <div class="loading" id="loading">
                <div class="spinner"></div>
                <p>ƒêang x·ª≠ l√Ω...</p>
            </div>
            
            <div class="status" id="status"></div>
            
            <div id="mainApp" style="display: none;">
                <!-- Navigation Menu -->
                <div class="nav-menu">
                    <button id="menuTraining" class="btn info active">üß† Hu·∫•n luy·ªán AI</button>
                    <button id="menuGeneration" class="btn success">üìñ AI T·∫°o Truy·ªán</button>
                    <button id="menuManagement" class="btn">‚úçÔ∏è Qu·∫£n l√Ω Truy·ªán</button>
                    <button id="menuHistory" class="btn">üìö L·ªãch s·ª≠ Truy·ªán</button>
                </div>
                
                <!-- AI Training Section -->
                <div id="trainingSection" class="content-section active">
                    <div class="ai-section">
                        <h2>üß† Hu·∫•n luy·ªán AI</h2>
                        <div class="ai-stats" id="aiStats">
                            <div class="stat-item">
                                <span>T·ªïng s·ªë file:</span>
                                <span id="totalFiles">0</span>
                            </div>
                            <div class="stat-item">
                                <span>ƒê√£ hu·∫•n luy·ªán:</span>
                                <span id="trainedFiles">0</span>
                            </div>
                            <div class="stat-item">
                                <span>T·ª´ v·ª±ng h·ªçc ƒë∆∞·ª£c:</span>
                                <span id="vocabularyCount">0</span>
                            </div>
                            <div class="stat-item">
                                <span>N·ªôi dung 18+:</span>
                                <span id="adultContentCount">0</span>
                            </div>
                        </div>
                        <div class="progress-bar">
                            <div class="progress-fill" id="progressFill"></div>
                        </div>
                        <button id="trainAiButton" class="btn success">üéØ B·∫Øt ƒë·∫ßu hu·∫•n luy·ªán AI</button>
                        <button id="resetAiButton" class="btn danger">üîÑ Reset AI</button>
                    </div>
                </div>
                
                <!-- AI Story Generation Section -->
                <div id="generationSection" class="content-section">
                    <div class="ai-generated-section">
                        <h2>üìñ AI T·∫°o Truy·ªán T·ª± ƒê·ªông</h2>
                        
                        <div class="theme-selector">
                            <label>Ch·ªçn ch·ªß ƒë·ªÅ:</label>
                            <div class="theme-buttons">
                                <button class="theme-btn active" data-theme="sad">üòî Bu·ªìn, Bi th·∫£m</button>
                                <button class="theme-btn" data-theme="romance">üíñ T√¨nh y√™u l√£ng m·∫°n</button>
                                <button class="theme-btn" data-theme="adult">üîû Ng∆∞·ªùi l·ªõn (18+)</button>
                                <button class="theme-btn" data-theme="explicit">üî• N·ªôi dung Explicit</button>
                                <button class="theme-btn" data-theme="mixed">üîÄ Pha tr·ªôn ng·∫´u nhi√™n</button>
                            </div>
                        </div>
                        
                        <div class="adult-warning" id="adultWarning" style="display: none;">
                            ‚ö†Ô∏è C·∫£nh b√°o: Ch·∫ø ƒë·ªô n√†y t·∫°o n·ªôi dung d√†nh cho ng∆∞·ªùi l·ªõn. B·∫°n ph·∫£i t·ª´ 18 tu·ªïi tr·ªü l√™n ƒë·ªÉ s·ª≠ d·ª•ng.
                        </div>
                        
                        <div class="adult-toggle" id="adultToggle" style="display: none;">
                            <input type="checkbox" id="adultConsent">
                            <label for="adultConsent">T√¥i x√°c nh·∫≠n ƒë√£ ƒë·ªß 18 tu·ªïi v√† ƒë·ªìng √Ω xem n·ªôi dung ng∆∞·ªùi l·ªõn</label>
                        </div>
                        
                        <div class="ai-story-controls">
                            <input type="number" id="chapterCount" placeholder="S·ªë ch∆∞∆°ng (100-150)" min="100" max="150" value="100">
                            <button id="generateStoryButton" class="btn success">üöÄ AI T·∫°o Truy·ªán M·ªõi</button>
                            <button id="viewAiStoriesButton" class="btn">üìö Xem Truy·ªán AI ƒê√£ T·∫°o</button>
                        </div>
                        <div class="progress-bar">
                            <div class="progress-fill" id="generationProgressFill"></div>
                        </div>
                        <div id="generationStatus"></div>
                    </div>
                </div>
                
                <!-- Story Management Section -->
                <div id="managementSection" class="content-section">
                    <div class="form-section">
                        <h2>‚úçÔ∏è Th√™m Truy·ªán / Ch∆∞∆°ng M·ªõi</h2>
                        <form id="storyForm">
                            <div class="form-group">
                                <label for="storyMode">Ch·∫ø ƒë·ªô:</label>
                                <select id="storyMode" onchange="toggleStoryMode()">
                                    <option value="new">T·∫°o truy·ªán m·ªõi</option>
                                    <option value="existing">Th√™m ch∆∞∆°ng v√†o truy·ªán c√≥ s·∫µn</option>
                                </select>
                            </div>
                            <div class="form-group" id="newStoryGroup">
                                <label for="storyTitle">T√™n Truy·ªán M·ªõi:</label>
                                <input type="text" id="storyTitle" placeholder="Nh·∫≠p t√™n truy·ªán m·ªõi...">
                            </div>
                            <div class="form-group" id="existingStoryGroup" style="display: none;">
                                <label for="existingStory">Ch·ªçn Truy·ªán C√≥ S·∫µn:</label>
                                <select id="existingStory"><option value="">-- Ch·ªçn truy·ªán --</option></select>
                            </div>
                            <div class="form-group">
                                <label for="chapterTitle">T√™n Ch∆∞∆°ng:</label>
                                <input type="text" id="chapterTitle" required placeholder="Nh·∫≠p t√™n ch∆∞∆°ng...">
                            </div>
                            <div class="form-group">
                                <label for="storyContent">N·ªôi dung:</label>
                                <textarea id="storyContent" required placeholder="Nh·∫≠p n·ªôi dung truy·ªán..."></textarea>
                            </div>
                            <button type="submit" class="btn">üíæ <span id="submitButtonText">L∆∞u Truy·ªán M·ªõi</span></button>
                        </form>
                    </div>
                </div>
                
                <!-- History Section -->
                <div id="historySection" class="content-section">
                    <div class="grid">
                        <div class="history-section">
                            <div class="history-header"><h2>üìñ L·ªãch s·ª≠ Truy·ªán</h2></div>
                            <div class="history-list" id="historyList"></div>
                        </div>
                        <div class="history-section">
                            <div class="history-header"><h2>üìÅ Th∆∞ m·ª•c Google Drive</h2></div>
                            <div class="history-list" id="folderList"></div>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- Modal for AI Generated Stories -->
    <div id="aiStoriesModal" class="modal">
        <div class="modal-content">
            <span class="close-modal" onclick="closeModal('aiStoriesModal')">&times;</span>
            <h2>üìö Truy·ªán ƒê∆∞·ª£c T·∫°o B·ªüi AI</h2>
            <div class="ai-story-list" id="aiStoryList">
                <!-- AI stories will be listed here -->
            </div>
        </div>
    </div>

    <!-- Modal for Viewing Chapters -->
    <div id="chaptersModal" class="modal">
        <div class="modal-content">
            <span class="close-modal" onclick="closeModal('chaptersModal')">&times;</span>
            <h2 id="chaptersModalTitle">Ch∆∞∆°ng Truy·ªán</h2>
            <div class="chapter-list" id="chapterList">
                <!-- Chapters will be listed here -->
            </div>
            <div class="chapter-content" id="chapterContent" style="display: none;">
                <!-- Chapter content will be displayed here -->
            </div>
            <div class="chapter-actions" id="chapterActions" style="display: none;">
                <button class="btn" onclick="editChapter()">‚úèÔ∏è S·ª≠a Ch∆∞∆°ng</button>
                <button class="btn rewrite-btn" onclick="rewriteChapter()">üîÑ Vi·∫øt L·∫°i</button>
                <button class="btn danger" onclick="deleteChapter()">üóëÔ∏è X√≥a Ch∆∞∆°ng</button>
                <button class="btn" onclick="saveChapterChanges()">üíæ L∆∞u Thay ƒê·ªïi</button>
                <button class="btn" onclick="cancelEdit()">‚ùå H·ªßy</button>
            </div>
            <div id="chapterVersions" style="display: none; margin-top: 20px;">
                <h3>Phi√™n b·∫£n kh√°c</h3>
                <div id="versionsList"></div>
            </div>
        </div>
    </div>

<script>
const CLIENT_ID = '199144324956-rsc4tttep6uq67poepa2nclieqi82avj.apps.googleusercontent.com';
const API_KEY = 'AIzaSyBGHB5FnrtMXliWtk3X6FZAl0CE2neNgZM';
const DISCOVERY_DOC = 'https://www.googleapis.com/discovery/v1/apis/drive/v3/rest';
const SCOPES = 'https://www.googleapis.com/auth/drive.file';

let tokenClient, gapi_inited = false, gis_inited = false, mainFolderId = null, storyHistory = [];
let aiKnowledge = { vocabulary: new Set(), stories: [], trainedFiles: 0, adultContent: 0 };
let aiGeneratedStories = [];
let currentEditingChapter = null;
let currentTheme = 'sad';

// T·ª´ v·ª±ng v√† c·∫•u tr√∫c c√¢u cho gi·ªçng bu·ªìn, bi th·∫£m
const sadVocabulary = {
    emotions: ['bu·ªìn', 'ƒëau kh·ªï', 'c√¥ ƒë∆°n', 'tuy·ªát v·ªçng', 'x√≥t xa', 'ƒëau ƒë·ªõn', 'l·∫ª loi', 
               'tr·ªëng v·∫Øng', 'th·∫•t v·ªçng', 'ch√°n n·∫£n', 's·∫ßu mu·ªôn', 'u u·∫•t', 'n·∫∑ng n·ªÅ', 'tan n√°t'],
    introspective: ['t√¥i c·∫£m th·∫•y', 't√¥i nh·∫≠n ra', 'trong l√≤ng t√¥i', 't√¢m tr√≠ t√¥i', 'k√Ω ·ª©c t√¥i',
                   'n·ªói nh·ªõ', 'n·ªói c√¥ ƒë∆°n', 'n·ªói ƒëau', 'c·∫£m gi√°c', 't·∫≠n s√¢u trong tim'],
    metaphors: ['b√≥ng t·ªëi', 'c∆°n m∆∞a', 'gi·ªçt n∆∞·ªõc m·∫Øt', 'v·∫øt s·∫πo', 'v√≤ng xo√°y', 'v·ª±c s√¢u',
               'm√†n ƒë√™m', 'b√£o t·ªë', 'tro t√†n', 'ho√†ng h√¥n', 'b√¨nh minh u t·ªëi'],
    verbs: ['kh√≥c', 'th·ªïn th·ª©c', 'ngh·∫πn ng√†o', 'th·ªü d√†i', 'l·∫∑ng im', 'tr·ªën ch·∫°y', 'ch√¨m ƒë·∫Øm',
           'v·ª° tan', 'mong manh', 'l·∫°c l·ªëi', 'qu√™n l√£ng', 'ch√¥n v√πi']
};

// T·ª´ v·ª±ng cho ch·ªß ƒë·ªÅ t√¨nh y√™u l√£ng m·∫°n
const romanceVocabulary = {
    emotions: ['y√™u', 'th∆∞∆°ng', 'say ƒë·∫Øm', 'ng·ªçt ng√†o', 'l√£ng m·∫°n', 'ƒëam m√™', 'rung ƒë·ªông', 
               'th·ªïn th·ª©c', 'h·∫°nh ph√∫c', '·∫•m √°p', 'ng√¢y ng·∫•t', 'say m√™', 'cu·ªìng nhi·ªát'],
    introspective: ['tr√°i tim t√¥i', 'c·∫£m x√∫c c·ªßa t√¥i', 't√¢m h·ªìn t√¥i', 't√¨nh y√™u', 'n·ªói nh·ªõ',
                   'kh√°t khao', '∆∞·ªõc mong', 'hy v·ªçng', 'c·∫£m gi√°c', 'x√∫c ƒë·ªông'],
    metaphors: ['√°nh trƒÉng', 'b·∫ßu tr·ªùi sao', 'c∆°n gi√≥', '√°nh n·∫Øng', 'b√¥ng hoa', 'd√≤ng s√¥ng',
               'ng·ªçn l·ª≠a', 'v·∫ßng trƒÉng', 'bi·ªÉn c·∫£', 'c√°nh ƒë·ªìng', 'c∆°n m∆∞a'],
    verbs: ['√¥m', 'h√¥n', 'n·∫Øm tay', 'th√¨ th·∫ßm', 'y√™u', 'say', 'm∆°', 'nh·ªõ', 'mong', 'ch·ªù',
           'ƒë·ª£i', 'trao', 'nh·∫≠n', 'chia s·∫ª']
};

// T·ª™ V·ª∞NG V√Ä C·∫§U TR√öC CHO N·ªòI DUNG 18+ - M·ªû R·ªòNG
const adultVocabulary = {
    emotions: ['d·ª•c v·ªçng', 'khao kh√°t', 'say ƒë·∫Øm', 'n√≥ng b·ªèng', 'cu·ªìng nhi·ªát', 'th√®m mu·ªën', 
               'ph·∫•n kh√≠ch', 'k√≠ch ƒë·ªông', 'm√£n nguy·ªán', 'th·ªèa m√£n', 'sung s∆∞·ªõng', 'ƒë√™ m√™',
               'b·ª©c b·ªëi', 'th√¥i th√∫c', 'ham mu·ªën', 'n·ªìng nhi·ªát', 'cu·ªìng d√¢m', 'kho√°i l·∫°c'],
    introspective: ['c∆° th·ªÉ t√¥i', 'c·∫£m gi√°c', 'ham mu·ªën', 'k√≠ch th√≠ch', 'd√¢ng tr√†o', 'c∆°n s√≥ng',
                   'ƒë·ªânh ƒëi·ªÉm', 'kho√°i c·∫£m', 'x√∫c gi√°c', 'c·∫£m nh·∫≠n', 'b·∫£n nƒÉng', 'd·ª•c t√≠nh',
                   'kho√°i c·∫£m', 'c·ª±c kho√°i', 'sung s∆∞·ªõng', 'k√≠ch d·ª•c'],
    metaphors: ['ng·ªçn l·ª≠a', 'c∆°n b√£o', 'bi·ªÉn c·∫£', 'v·ª±c s√¢u', '√°nh ch·ªõp', 'c∆°n l·ªëc',
               'd√≤ng th√°c', 'ngu·ªìn nƒÉng l∆∞·ª£ng', '√°nh s√°ng', 'b√≥ng t·ªëi', 'v·ª• n·ªï', 'b√£o t·ªë',
               'c∆°n ƒë·ªãa ch·∫•n', 'ng·ªçn n√∫i l·ª≠a', 'd√≤ng dung nham'],
    verbs: ['ch·∫°m', 'vu·ªët ve', 'h√¥n', 'c·∫Øn', '√¥m', 'si·∫øt ch·∫∑t', 'ƒÉn', 'u·ªëng', 'kh√°m ph√°',
           'th·ª≠ nghi·ªám', 'tr·∫£i nghi·ªám', 'th∆∞·ªüng th·ª©c', 'ƒëam m√™', 'cho√°ng ng·ª£p', 'x√¢m chi·∫øm',
           'th√¢m nh·∫≠p', 'c·ªç x√°t', 'm√¢n m√™', 'li·∫øm', 'h√∫t', 'nu·ªët', 'c∆∞·ª°ng ƒëo·∫°t', 'khi√™u kh√≠ch'],
    bodyParts: ['m√¥i', 'c·ªï', 'vai', 'ng·ª±c', 'b·ª•ng', 'ƒë√πi', 'h√¥ng', 'l∆∞ng', 'tay', 'ch√¢n',
               'v√∫', 'nh≈© hoa', 'eo', 'm√¥ng', 'v√πng k√≠n', 'c·∫≠u nh·ªè', 'c·ª≠a m√¨nh', 'l·ªìn', 'c·∫∑c',
               'd∆∞∆°ng v·∫≠t', '√¢m ƒë·∫°o', '√¢m h·ªô', 'ƒë·∫ßu v√∫', 'h·∫≠u m√¥n', 'b∆∞·ªõm'],
    sensations: ['·∫•m √°p', 'n√≥ng b·ªèng', 'l·∫°nh gi√°', 'm·ªÅm m·∫°i', 'm·ªãn m√†ng', 'th√¥ r√°p', '·∫©m ∆∞·ªõt', 'kh√¥ r√°o',
                'co th·∫Øt', 'r√πng m√¨nh', 'run r·∫©y', 'r·∫°o r·ª±c', 'ng·ª©a ng√°y', 'n√≥ng ran', 'l√¢ng l√¢ng',
                't√™ d·∫°i', 'ƒë√™ m√™', 'say ƒë·∫Øm', 'cu·ªìng lo·∫°n']
};

// T·ª™ V·ª∞NG CHO N·ªòI DUNG EXPLICIT - TH√äM M·ªöI
const explicitVocabulary = {
    emotions: ['d√¢m ƒë√£ng', 'th√¥ t·ª•c', 't·ª•c tƒ©u', 'd·ª•c t√≠nh', 'k√≠ch d·ª•c', 'kho√°i l·∫°c',
               'th·ªèa m√£n', 'sung s∆∞·ªõng', 'ƒë√™ m√™', 'cu·ªìng d√¢m', 'd√¢m d·ª•c', 'lƒÉng lo√†n'],
    introspective: ['c∆°n th√®m kh√°t', 'ham mu·ªën th·ªÉ x√°c', 'k√≠ch th√≠ch t√¨nh d·ª•c', 'kho√°i c·∫£m nh·ª•c d·ª•c',
                   'b·∫£n nƒÉng t√¨nh d·ª•c', 'c·∫£m gi√°c d√¢m ƒë√£ng', 'khao kh√°t x√°c th·ªãt'],
    metaphors: ['c∆°n l·ªëc d·ª•c v·ªçng', 'bi·ªÉn l·ª≠a ham mu·ªën', 'v·ª±c s√¢u kho√°i l·∫°c', 'b√£o t·ªë t√¨nh d·ª•c',
               'd√≤ng s√¥ng nh·ª•c d·ª•c', 'ng·ªçn n√∫i d·ª•c v·ªçng', 'c∆°n ƒë·ªãa ch·∫•n kho√°i c·∫£m'],
    verbs: ['ƒë·ªãt', 'l·ªìn', 'c·∫∑c', 'h√∫p', 'li·∫øm', 'b√∫', 'h√¥n', 'x√¢m chi·∫øm', 'th√¢m nh·∫≠p', 'c∆∞·ª°ng b·ª©c',
           'c·ªç x√°t', 'ma s√°t', 'xu·∫•t tinh', 'l√™n ƒë·ªânh', 'th·∫©m du', 't·ª± s∆∞·ªõng', 'kh·∫©u giao', 'giao h·ª£p',
           'l√†m t√¨nh', '√¢n √°i', 'ƒë·ª•', 'ch·ªãch', 'phang', 'ƒë√≥ng ƒëinh'],
    bodyParts: ['l·ªìn', 'c·∫∑c', 'd∆∞∆°ng v·∫≠t', '√¢m ƒë·∫°o', '√¢m h·ªô', 'h·∫≠u m√¥n', 'v√∫', 'ƒë·∫ßu v√∫', 'm√¥ng', 'h√°ng',
               'b∆∞·ªõm', 'c·∫≠u nh·ªè', 'c·ª≠a m√¨nh', 'b√¨u', 'd∆∞∆°ng v·∫≠t', '√¢m v·∫≠t', 'g√≤ mu', 'l√¥ng mu'],
    sensations: ['∆∞·ªõt √°t', 'co th·∫Øt', 'r√πng m√¨nh', 'r·∫°o r·ª±c', 'n√≥ng ran', 't√™ t√™', 'sung m√£n',
                'cƒÉng c·ª©ng', '·ª© ƒë·∫ßy', 'tr√†o ra', 'tu√¥n tr√†o', 'phun tr√†o', 'th·ªïn th·ª©c']
};

// C·∫•u tr√∫c c√¢u cho ƒë·ªôc tho·∫°i n·ªôi t√¢m
const sentencePatterns = {
    sad: [
        "T√¥i c·∫£m th·∫•y {emotion} khi {event}.",
        "Trong {moment}, {introspective} l·∫°i √πa v·ªÅ.",
        "{Emotion} {metaphor} c·ª© b√°m l·∫•y t√¥i.",
        "T√¥i {verb} trong {state} c·ªßa ch√≠nh m√¨nh.",
        "T·∫°i sao {question}? C√≥ l·∫Ω t√¥i s·∫Ω kh√¥ng bao gi·ªù bi·∫øt ƒë∆∞·ª£c.",
        "K√Ω ·ª©c v·ªÅ {memory} khi·∫øn t√¥i {emotion}.",
        "T√¥i t·ª± h·ªèi li·ªáu {thought} c√≥ c√≤n √Ω nghƒ©a g√¨ kh√¥ng.",
        "Tr√°i tim t√¥i nh∆∞ {metaphor} {emotion}.",
        "T√¥i mu·ªën {desire} nh∆∞ng ch·ªâ c√≥ th·ªÉ {reality}.",
        "M·ªói {time} tr√¥i qua, t√¥i l·∫°i c·∫£m th·∫•y {emotion} h∆°n."
    ],
    romance: [
        "T√¥i c·∫£m th·∫•y {emotion} khi ·ªü b√™n ng∆∞·ªùi ·∫•y.",
        "Trong {moment}, {introspective} tr√†o d√¢ng.",
        "{Emotion} {metaphor} bao tr√πm l·∫•y ch√∫ng t√¥i.",
        "T√¥i {verb} trong v√≤ng tay c·ªßa ng∆∞·ªùi ·∫•y.",
        "T·∫°i sao {question}? C√≥ l·∫Ω v√¨ t√¨nh y√™u qu√° l·ªõn.",
        "K√Ω ·ª©c v·ªÅ {memory} khi·∫øn t√¥i {emotion}.",
        "T√¥i t·ª± h·ªèi li·ªáu {thought} c√≥ ph·∫£i l√† ƒë·ªãnh m·ªánh.",
        "Tr√°i tim t√¥i nh∆∞ {metaphor} {emotion}.",
        "T√¥i mu·ªën {desire} c√πng ng∆∞·ªùi ·∫•y m√£i m√£i.",
        "M·ªói {time} tr√¥i qua, t√¨nh y√™u l·∫°i th√™m {emotion}."
    ],
    adult: [
        "C∆° th·ªÉ t√¥i {verb} v·ªõi {emotion} khi {event}.",
        "Trong {moment}, {introspective} tr√†o d√¢ng {emotion}.",
        "{Emotion} {metaphor} bao tr√πm l·∫•y ch√∫ng t√¥i.",
        "T√¥i {verb} {bodyPart} c·ªßa ng∆∞·ªùi ·∫•y v·ªõi {sensation} c·∫£m gi√°c.",
        "T·∫°i sao {question}? C√≥ l·∫Ω v√¨ {emotion} qu√° l·ªõn.",
        "C·∫£m gi√°c {sensation} ·ªü {bodyPart} khi·∫øn t√¥i {emotion}.",
        "T√¥i t·ª± h·ªèi li·ªáu {thought} c√≥ ph·∫£i l√† ƒëi·ªÅu t√¥i th·ª±c s·ª± mu·ªën.",
        "C∆° th·ªÉ t√¥i nh∆∞ {metaphor} {emotion}.",
        "T√¥i mu·ªën {desire} c√πng ng∆∞·ªùi ·∫•y m√£i m√£i.",
        "M·ªói {time} tr√¥i qua, {introspective} l·∫°i th√™m {emotion}."
    ],
    explicit: [
        "T√¥i {verb} {bodyPart} c·ªßa ng∆∞·ªùi ·∫•y m·ªôt c√°ch {emotion}.",
        "{BodyPart} c·ªßa ng∆∞·ªùi ·∫•y {verb} khi·∫øn t√¥i {sensation}.",
        "Ch√∫ng t√¥i {verb} trong {moment} v·ªõi {emotion}.",
        "T√¥i {verb} v√† {verb} {bodyPart} c·ªßa ng∆∞·ªùi ·∫•y.",
        "C·∫£m gi√°c {sensation} khi {verb} {bodyPart} th·∫≠t {emotion}.",
        "T√¥i {verb} kh√¥ng ng·ª´ng tr√™n {bodyPart} c·ªßa ng∆∞·ªùi ·∫•y.",
        "{BodyPart} c·ªßa t√¥i {verb} v·ªõi {sensation} c·∫£m gi√°c.",
        "Ch√∫ng t√¥i {verb} cho ƒë·∫øn khi {event}.",
        "T√¥i {verb} {bodyPart} c·ªßa ng∆∞·ªùi ·∫•y cho ƒë·∫øn khi {sensation}.",
        "{Emotion} {metaphor} tr√†n ng·∫≠p cƒÉn ph√≤ng khi ch√∫ng t√¥i {verb}."
    ]
};

// S·ª± ki·ªán v√† k√Ω ·ª©c cho c·ªët truy·ªán
const storyElements = {
    events: ["ng√†y ƒë√≥", "l·ªùi n√≥i d·ªëi", "s·ª± ra ƒëi", "l·ªùi h·ª©a", "√°nh m·∫Øt", "n·ª• c∆∞·ªùi", 
            "cu·ªôc g·∫∑p g·ª°", "bi·∫øn c·ªë", "quy·∫øt ƒë·ªãnh", "l·ªùi t·ª´ ch·ªëi", "ƒë√™m t√¢n h√¥n", "l·∫ßn ƒë·∫ßu ti√™n",
            "bu·ªïi t·ªëi ƒë·ªãnh m·ªánh", "kh√∫c quanh", "b∆∞·ªõc ngo·∫∑t", "s·ª± c·ªë", "tai n·∫°n", "s·ª± ki·ªán"],
    memories: ["ng∆∞·ªùi ·∫•y", "qu√° kh·ª©", "tu·ªïi th∆°", "gia ƒë√¨nh", "t√¨nh y√™u", "∆∞·ªõc m∆°",
              "ng√¥i nh√† c≈©", "con ƒë∆∞·ªùng", "khu v∆∞·ªùn", "b√†i h√°t", "k·ª∑ ni·ªám", "kho·∫£nh kh·∫Øc",
              "m·ªëi t√¨nh ƒë·∫ßu", "m·ªëi quan h·ªá", "cu·ªôc g·∫∑p g·ª°", "l·∫ßn ƒë·∫ßu"],
    thoughts: ["cu·ªôc ƒë·ªùi", "t∆∞∆°ng lai", "√Ω nghƒ©a", "s·ª± t·ªìn t·∫°i", "s·ªë ph·∫≠n", "h·∫°nh ph√∫c",
              "n·ªói ƒëau", "s·ª± th·∫≠t", "l·ª±a ch·ªçn", "con ng∆∞·ªùi th·∫≠t", "b·∫£n nƒÉng", "d·ª•c v·ªçng",
              "ham mu·ªën", "khao kh√°t", "ƒëam m√™"],
    desires: ["quay l·∫°i", "thay ƒë·ªïi", "qu√™n ƒëi", "y√™u th∆∞∆°ng", "tha th·ª©", "t√¨m th·∫•y",
             "gi·∫£i tho√°t", "b√¨nh y√™n", "hi·ªÉu ƒë∆∞·ª£c", "ch·∫•p nh·∫≠n", "s·ªü h·ªØu", "chi·∫øm ƒëo·∫°t",
             "th·ªèa m√£n", "chinh ph·ª•c", "kh√°m ph√°"],
    times: ["gi√¢y ph√∫t", "ph√∫t gi√¢y", "kho·∫£nh kh·∫Øc", "ng√†y", "ƒë√™m", "th√°ng nƒÉm", "m√πa",
           "bu·ªïi s√°ng", "bu·ªïi chi·ªÅu", "bu·ªïi t·ªëi", "ƒë√™m khuya", "r·∫°ng s√°ng"]
};

// Initialize Google API
async function initializeGapi() {
    await gapi.load('client', async () => {
        await gapi.client.init({ apiKey: API_KEY, discoveryDocs: [DISCOVERY_DOC] });
        gapi_inited = true; maybeEnableButtons();
    });
}

function initializeGis() {
    tokenClient = google.accounts.oauth2.initTokenClient({
        client_id: CLIENT_ID, scope: SCOPES, callback: ''
    });
    gis_inited = true; maybeEnableButtons();
}

function maybeEnableButtons() { 
    if (gapi_inited && gis_inited) {
        document.getElementById('authorizeButton').style.display = 'inline-block'; 
    }
}

function handleAuthClick() {
    tokenClient.callback = async (resp) => {
        if (resp.error !== undefined) { 
            showStatus('L·ªói ƒëƒÉng nh·∫≠p: ' + resp.error, 'error'); 
            return; 
        }
        document.getElementById('signoutButton').style.display = 'inline-block';
        document.getElementById('authorizeButton').style.display = 'none';
        document.getElementById('authStatus').innerHTML = '‚úÖ ƒê√£ ƒëƒÉng nh·∫≠p th√†nh c√¥ng!';
        await initializeApp();
    };
    if (gapi.client.getToken() === null) {
        tokenClient.requestAccessToken({prompt: 'consent'});
    } else {
        tokenClient.requestAccessToken({prompt: ''});
    }
}

function handleSignoutClick() {
    const token = gapi.client.getToken();
    if (token !== null) { 
        google.accounts.oauth2.revoke(token.access_token); 
        gapi.client.setToken(''); 
    }
    document.getElementById('authorizeButton').style.display = 'inline-block';
    document.getElementById('signoutButton').style.display = 'none';
    document.getElementById('authStatus').innerHTML = '';
    document.getElementById('mainApp').style.display = 'none';
}

async function initializeApp() {
    showLoading(true);
    await createMainFolder(); 
    await loadStoryHistory();
    await loadAiKnowledge();
    await loadAiGeneratedStories();
    updateAiStats();
    document.getElementById('mainApp').style.display = 'block';
    showStatus('Kh·ªüi t·∫°o ·ª©ng d·ª•ng th√†nh c√¥ng!', 'success');
    showLoading(false);
}

async function createMainFolder() {
    const folderName = 'QuanLyTruyen';
    const response = await gapi.client.drive.files.list({
        q: `name='${folderName}' and mimeType='application/vnd.google-apps.folder' and trashed=false`,
        fields: 'files(id, name)'
    });
    if (response.result.files.length > 0) {
        mainFolderId = response.result.files[0].id;
    } else {
        const folder = await gapi.client.drive.files.create({ 
            resource: {name: folderName, mimeType: 'application/vnd.google-apps.folder'}, 
            fields: 'id' 
        });
        mainFolderId = folder.result.id;
    }
    
    // Create AI Stories folder if it doesn't exist
    const aiFolderName = 'AI_Generated_Stories';
    const aiResponse = await gapi.client.drive.files.list({
        q: `name='${aiFolderName}' and mimeType='application/vnd.google-apps.folder' and '${mainFolderId}' in parents and trashed=false`,
        fields: 'files(id, name)'
    });
    if (aiResponse.result.files.length === 0) {
        const aiFolder = await gapi.client.drive.files.create({ 
            resource: {
                name: aiFolderName, 
                mimeType: 'application/vnd.google-apps.folder', 
                parents: [mainFolderId]
            }, 
            fields: 'id' 
        });
    }
}

async function createStoryFolder(storyTitle, isAiGenerated = false) {
    let parentId = mainFolderId;
    
    if (isAiGenerated) {
        // Find AI Stories folder
        const aiFolderName = 'AI_Generated_Stories';
        const response = await gapi.client.drive.files.list({
            q: `name='${aiFolderName}' and mimeType='application/vnd.google-apps.folder' and '${mainFolderId}' in parents and trashed=false`,
            fields: 'files(id, name)'
        });
        if (response.result.files.length > 0) {
            parentId = response.result.files[0].id;
        }
    }
    
    const folder = await gapi.client.drive.files.create({
        resource: { 
            name: storyTitle, 
            mimeType: 'application/vnd.google-apps.folder', 
            parents: [parentId] 
        }, 
        fields: 'id'
    });
    return folder.result.id;
}

async function saveStoryContent(storyTitle, chapterTitle, content, storyFolderId, isAiGenerated = false) {
    const fileMetadata = { 
        name: `${chapterTitle}.txt`, 
        parents: [storyFolderId],
        description: isAiGenerated ? "AI-Generated" : "User-Created"
    };
    
    await gapi.client.request({
        path: 'https://www.googleapis.com/upload/drive/v3/files', 
        method: 'POST',
        params: { uploadType: 'multipart' },
        headers: { 'Content-Type': 'multipart/related; boundary="foo_bar_baz"' },
        body: '--foo_bar_baz\r\nContent-Type: application/json; charset=UTF-8\r\n\r\n' +
              JSON.stringify(fileMetadata) + '\r\n--foo_bar_baz\r\nContent-Type: text/plain\r\n\r\n' +
              content + '\r\n--foo_bar_baz--'
    });
}

async function loadStoryHistory() {
    const response = await gapi.client.drive.files.list({
        q: `'${mainFolderId}' in parents and mimeType='application/vnd.google-apps.folder' and trashed=false`,
        fields: 'files(id, name, createdTime)', 
        orderBy: 'createdTime desc'
    });
    const folders = response.result.files; 
    storyHistory = [];
    
    for (let folder of folders) {
        // Skip AI Generated Stories folder
        if (folder.name === 'AI_Generated_Stories') continue;
        
        const filesResponse = await gapi.client.drive.files.list({
            q: `'${folder.id}' in parents and trashed=false`,
            fields: 'files(id, name, createdTime, description)'
        });
        storyHistory.push({ 
            storyTitle: folder.name, 
            folderId: folder.id, 
            createdTime: folder.createdTime, 
            chapters: filesResponse.result.files,
            isAiGenerated: false
        });
    }
    displayHistory(); 
    displayFolders();
}

async function loadAiGeneratedStories() {
    // Find AI Stories folder
    const aiFolderName = 'AI_Generated_Stories';
    const response = await gapi.client.drive.files.list({
        q: `name='${aiFolderName}' and mimeType='application/vnd.google-apps.folder' and '${mainFolderId}' in parents and trashed=false`,
        fields: 'files(id, name)'
    });
    
    if (response.result.files.length === 0) {
        aiGeneratedStories = [];
        return;
    }
    
    const aiFolderId = response.result.files[0].id;
    const aiFoldersResponse = await gapi.client.drive.files.list({
        q: `'${aiFolderId}' in parents and mimeType='application/vnd.google-apps.folder' and trashed=false`,
        fields: 'files(id, name, createdTime)', 
        orderBy: 'createdTime desc'
    });
    
    const aiFolders = aiFoldersResponse.result.files;
    aiGeneratedStories = [];
    
    for (let folder of aiFolders) {
        const filesResponse = await gapi.client.drive.files.list({
            q: `'${folder.id}' in parents and trashed=false`,
            fields: 'files(id, name, createdTime, description)'
        });
        aiGeneratedStories.push({ 
            storyTitle: folder.name, 
            folderId: folder.id, 
            createdTime: folder.createdTime, 
            chapters: filesResponse.result.files,
            isAiGenerated: true
        });
    }
}

// AI Training Functions
async function trainAI() {
    showLoading(true);
    showStatus('ƒêang b·∫Øt ƒë·∫ßu hu·∫•n luy·ªán AI...', 'success');
    
    const allFiles = [];
    for (let story of storyHistory) {
        for (let chapter of story.chapters) {
            if (chapter.name.endsWith('.txt')) {
                allFiles.push({...chapter, storyTitle: story.storyTitle});
            }
        }
    }
    
    document.getElementById('totalFiles').textContent = allFiles.length;
    let processedFiles = 0;
    
    for (let file of allFiles) {
        try {
            const response = await gapi.client.drive.files.get({
                fileId: file.id,
                alt: 'media'
            });
            
            const content = response.body;
            processContent(content, file.storyTitle, file.name);
            processedFiles++;
            
            // Update progress
            const progress = (processedFiles / allFiles.length) * 100;
            document.getElementById('progressFill').style.width = progress + '%';
            document.getElementById('trainedFiles').textContent = processedFiles;
            
            await new Promise(resolve => setTimeout(resolve, 100)); // Small delay
        } catch (error) {
            console.error('Error processing file:', file.name, error);
        }
    }
    
    aiKnowledge.trainedFiles = processedFiles;
    updateAiStats();
    saveAiKnowledge();
    showLoading(false);
    showStatus(`Hu·∫•n luy·ªán ho√†n th√†nh! ƒê√£ x·ª≠ l√Ω ${processedFiles} file.`, 'success');
}

// H√†m hu·∫•n luy·ªán AI - C·∫¢I TI·∫æN ƒê·ªÇ H·ªåC N·ªòI DUNG 18+ V√Ä EXPLICIT
function processContent(content, storyTitle, fileName) {
    // Ph√¢n t√≠ch n·ªôi dung ƒë·ªÉ h·ªçc c·∫•u tr√∫c c√¢u v√† t·ª´ v·ª±ng
    const sentences = content.split(/[.!?]+/).filter(s => s.length > 5);
    
    sentences.forEach(sentence => {
        // Th√™m t·ª´ v√†o t·ª´ ƒëi·ªÉn
        const words = sentence.toLowerCase()
            .replace(/[^\w\s√†√°·∫°·∫£√£√¢·∫ß·∫•·∫≠·∫©·∫´ƒÉ·∫±·∫Ø·∫∑·∫≥·∫µ√®√©·∫π·∫ª·∫Ω√™·ªÅ·∫ø·ªá·ªÉ·ªÖ√¨√≠·ªã·ªâƒ©√≤√≥·ªç·ªè√µ√¥·ªì·ªë·ªô·ªï·ªó∆°·ªù·ªõ·ª£·ªü·ª°√π√∫·ª•·ªß≈©∆∞·ª´·ª©·ª±·ª≠·ªØ·ª≥√Ω·ªµ·ª∑·ªπƒë]/g, '')
            .split(/\s+/);
        
        words.forEach(word => {
            if (word.length > 2) {
                aiKnowledge.vocabulary.add(word);
            }
        });
        
        // Ph√°t hi·ªán v√† l∆∞u ƒëo·∫°n h·ªôi tho·∫°i
        if (sentence.includes(':"') || sentence.includes(':"') || sentence.match(/["'].*?["']/)) {
            if (!aiKnowledge.dialogues) aiKnowledge.dialogues = [];
            const dialogueMatch = sentence.match(/["'](.*?)["']/);
            if (dialogueMatch) {
                aiKnowledge.dialogues.push(dialogueMatch[1]);
            }
        }
        
        // Ph√°t hi·ªán v√† l∆∞u ng·ªØ c·∫£nh
        if (sentence.match(/trong|khi|l√∫c|sau|tr∆∞·ªõc|v√†o|gi·ªØa/)) {
            if (!aiKnowledge.contexts) aiKnowledge.contexts = [];
            aiKnowledge.contexts.push(sentence);
        }
        
        // Ph√¢n lo·∫°i c√¢u theo c·∫£m x√∫c
        if (sentence.match(/bu·ªìn|ƒëau|kh·ªï|tuy·ªát v·ªçng|s·∫ßu|u u·∫•t/i)) {
            if (!aiKnowledge.sadSentences) aiKnowledge.sadSentences = [];
            aiKnowledge.sadSentences.push(sentence);
        }
        
        // Ph√°t hi·ªán ch·ªß ƒë·ªÅ t√¨nh y√™u
        if (sentence.match(/y√™u|th∆∞∆°ng|t√¨nh c·∫£m|tr√°i tim|h·∫°nh ph√∫c|ƒëam m√™/i)) {
            if (!aiKnowledge.romanceSentences) aiKnowledge.romanceSentences = [];
            aiKnowledge.romanceSentences.push(sentence);
        }
        
        // PH√ÅT HI·ªÜN N·ªòI DUNG 18+ - M·ªû R·ªòNG
        const adultKeywords = [
            'd·ª•c', 'khao kh√°t', 'ham mu·ªën', 'th√¢n m·∫≠t', 'g·ªëi chƒÉn', '√¢n √°i', 'k√≠ch d·ª•c', 
            'kho√°i c·∫£m', 'd√¢m', 'lo·∫°n', 'luy·∫øn', '·∫•u d√¢m', 'c∆° th·ªÉ', 'ch·∫°m', 'vu·ªët ve', 
            'h√¥n', 'c·∫Øn', '√¥m', 'si·∫øt ch·∫∑t', 'l·ªìn', 'c·∫∑c', 'ƒë·ªãt', 'ch·ªãch', 'phang', 'ƒë·ª•',
            'd∆∞∆°ng v·∫≠t', '√¢m ƒë·∫°o', '√¢m h·ªô', 'h·∫≠u m√¥n', 'v√∫', 'ƒë·∫ßu v√∫', 'm√¥ng', 'h√°ng'
        ];
        
        const explicitKeywords = [
            'ƒë·ªãt', 'l·ªìn', 'c·∫∑c', 'h√∫p', 'li·∫øm', 'b√∫', 'c∆∞·ª°ng b·ª©c', 'xu·∫•t tinh', 'l√™n ƒë·ªânh',
            'th·∫©m du', 't·ª± s∆∞·ªõng', 'kh·∫©u giao', 'giao h·ª£p', 'l√†m t√¨nh', '√¢n √°i', 'ƒë√≥ng ƒëinh',
            'd∆∞∆°ng v·∫≠t', '√¢m ƒë·∫°o', '√¢m h·ªô', 'h·∫≠u m√¥n', 'b∆∞·ªõm', 'c·∫≠u nh·ªè', 'c·ª≠a m√¨nh', 'b√¨u',
            '√¢m v·∫≠t', 'g√≤ mu', 'l√¥ng mu'
        ];
        
        // Ki·ªÉm tra n·ªôi dung explicit
        if (explicitKeywords.some(keyword => sentence.toLowerCase().includes(keyword))) {
            if (!aiKnowledge.explicitSentences) aiKnowledge.explicitSentences = [];
            aiKnowledge.explicitSentences.push(sentence);
            aiKnowledge.adultContent++;
            
            // ƒê√°nh d·∫•u truy·ªán c√≥ n·ªôi dung explicit
            if (!aiKnowledge.explicitStories) aiKnowledge.explicitStories = new Set();
            aiKnowledge.explicitStories.add(storyTitle);
        }
        // Ki·ªÉm tra n·ªôi dung 18+
        else if (adultKeywords.some(keyword => sentence.toLowerCase().includes(keyword))) {
            if (!aiKnowledge.adultSentences) aiKnowledge.adultSentences = [];
            aiKnowledge.adultSentences.push(sentence);
            aiKnowledge.adultContent++;
            
            // ƒê√°nh d·∫•u truy·ªán c√≥ n·ªôi dung nh·∫°y c·∫£m
            if (!aiKnowledge.adultStories) aiKnowledge.adultStories = new Set();
            aiKnowledge.adultStories.add(storyTitle);
        }
    });
    
    // L∆∞u th√¥ng tin truy·ªán
    if (!aiKnowledge.stories.includes(storyTitle)) {
        aiKnowledge.stories.push(storyTitle);
    }
    
    // Ph√¢n t√≠ch c·∫•u tr√∫c truy·ªán
    if (!aiKnowledge.storyStructures) aiKnowledge.storyStructures = {};
    if (!aiKnowledge.storyStructures[storyTitle]) {
        aiKnowledge.storyStructures[storyTitle] = {
            themes: [],
            characters: [],
            plotPoints: []
        };
    }
}

function updateAiStats() {
    document.getElementById('vocabularyCount').textContent = aiKnowledge.vocabulary.size;
    document.getElementById('adultContentCount').textContent = aiKnowledge.adultContent || 0;
}

async function saveAiKnowledge() {
    const knowledgeStr = JSON.stringify({
        vocabulary: Array.from(aiKnowledge.vocabulary),
        stories: aiKnowledge.stories,
        trainedFiles: aiKnowledge.trainedFiles,
        adultContent: aiKnowledge.adultContent || 0,
        dialogues: aiKnowledge.dialogues || [],
        contexts: aiKnowledge.contexts || [],
        sadSentences: aiKnowledge.sadSentences || [],
        romanceSentences: aiKnowledge.romanceSentences || [],
        adultSentences: aiKnowledge.adultSentences || [],
        explicitSentences: aiKnowledge.explicitSentences || [],
        adultStories: aiKnowledge.adultStories ? Array.from(aiKnowledge.adultStories) : [],
        explicitStories: aiKnowledge.explicitStories ? Array.from(aiKnowledge.explicitStories) : []
    });
    
    // Save to a file in the main folder
    const fileName = 'ai_knowledge.json';
    const response = await gapi.client.drive.files.list({
        q: `name='${fileName}' and '${mainFolderId}' in parents and trashed=false`,
        fields: 'files(id)'
    });
    
    if (response.result.files.length > 0) {
        // Update existing file
        const fileId = response.result.files[0].id;
        await gapi.client.request({
            path: `https://www.googleapis.com/upload/drive/v3/files/${fileId}`,
            method: 'PATCH',
            params: { uploadType: 'media' },
            body: knowledgeStr
        });
    } else {
        // Create new file
        const fileMetadata = { 
            name: fileName, 
            parents: [mainFolderId] 
        };
        
        await gapi.client.request({
            path: 'https://www.googleapis.com/upload/drive/v3/files', 
            method: 'POST',
            params: { uploadType: 'multipart' },
            headers: { 'Content-Type': 'multipart/related; boundary="foo_bar_baz"' },
            body: '--foo_bar_baz\r\nContent-Type: application/json; charset=UTF-8\r\n\r\n' +
                  JSON.stringify(fileMetadata) + '\r\n--foo_bar_baz\r\nContent-Type: application/json\r\n\r\n' +
                  knowledgeStr + '\r\n--foo_bar_baz--'
        });
    }
}

async function loadAiKnowledge() {
    const fileName = 'ai_knowledge.json';
    try {
        const response = await gapi.client.drive.files.list({
            q: `name='${fileName}' and '${mainFolderId}' in parents and trashed=false`,
            fields: 'files(id)'
        });
        
        if (response.result.files.length > 0) {
            const fileId = response.result.files[0].id;
            const fileResponse = await gapi.client.drive.files.get({
                fileId: fileId,
                alt: 'media'
            });
            
            const knowledge = JSON.parse(fileResponse.body);
            aiKnowledge.vocabulary = new Set(knowledge.vocabulary);
            aiKnowledge.stories = knowledge.stories;
            aiKnowledge.trainedFiles = knowledge.trainedFiles;
            aiKnowledge.adultContent = knowledge.adultContent || 0;
            aiKnowledge.dialogues = knowledge.dialogues || [];
            aiKnowledge.contexts = knowledge.contexts || [];
            aiKnowledge.sadSentences = knowledge.sadSentences || [];
            aiKnowledge.romanceSentences = knowledge.romanceSentences || [];
            aiKnowledge.adultSentences = knowledge.adultSentences || [];
            aiKnowledge.explicitSentences = knowledge.explicitSentences || [];
            aiKnowledge.adultStories = new Set(knowledge.adultStories || []);
            aiKnowledge.explicitStories = new Set(knowledge.explicitStories || []);
        }
    } catch (error) {
        console.error('Error loading AI knowledge:', error);
    }
}

function resetAI() {
    if (confirm('B·∫°n c√≥ ch·∫Øc ch·∫Øn mu·ªën reset to√†n b·ªô ki·∫øn th·ª©c c·ªßa AI?')) {
        aiKnowledge = { vocabulary: new Set(), stories: [], trainedFiles: 0, adultContent: 0 };
        updateAiStats();
        saveAiKnowledge();
        showStatus('ƒê√£ reset ki·∫øn th·ª©c c·ªßa AI!', 'success');
    }
}

// H√†m l·∫•y ng·∫´u nhi√™n ph·∫ßn t·ª≠ t·ª´ m·∫£ng
function getRandomElement(array) {
    return array[Math.floor(Math.random() * array.length)];
}

// H√†m t·∫°o n·ªôi dung ch∆∞∆°ng
function generateChapterContent(titleWords, theme = 'sad') {
    // X√°c ƒë·ªãnh ƒë·ªô d√†i ch∆∞∆°ng
    const minWords = 1500;
    const maxWords = 2000;
    const targetWords = minWords + Math.floor(Math.random() * (maxWords - minWords + 1));
    
    let content = "";
    let wordCount = 0;
    
    // T·∫°o ti√™u ƒë·ªÅ ch∆∞∆°ng
    const chapterIntro = generateChapterIntro(theme);
    content += chapterIntro + "\n\n";
    wordCount += chapterIntro.split(/\s+/).length;
    
    // T·∫°o n·ªôi dung ch√≠nh
    while (wordCount < targetWords) {
        const paragraph = generateParagraph(theme);
        content += paragraph + "\n\n";
        wordCount += paragraph.split(/\s+/).length;
    }
    
    return content;
}

// T·∫°o ƒëo·∫°n vƒÉn c√≥ √Ω nghƒ©a
function generateParagraph(theme) {
    const sentences = [];
    const sentenceCount = 3 + Math.floor(Math.random() * 4);
    
    for (let i = 0; i < sentenceCount; i++) {
        sentences.push(generateSentence(theme));
    }
    
    return sentences.join(" ");
}

// T·∫°o c√¢u c√≥ √Ω nghƒ©a - C·∫¢I TI·∫æN CHO N·ªòI DUNG 18+ V√Ä EXPLICIT
function generateSentence(theme) {
    let pattern, sentence;
    let vocabulary = sadVocabulary;
    let patterns = sentencePatterns.sad;
    
    if (theme === 'romance') {
        vocabulary = romanceVocabulary;
        patterns = sentencePatterns.romance;
    } else if (theme === 'adult') {
        vocabulary = adultVocabulary;
        patterns = sentencePatterns.adult;
    } else if (theme === 'explicit') {
        vocabulary = explicitVocabulary;
        patterns = sentencePatterns.explicit;
    } else if (theme === 'mixed') {
        // Randomly choose between themes for mixed theme
        const randomThemes = ['sad', 'romance', 'adult', 'explicit'];
        const randomTheme = randomThemes[Math.floor(Math.random() * randomThemes.length)];
        vocabulary = randomTheme === 'sad' ? sadVocabulary : 
                    randomTheme === 'romance' ? romanceVocabulary : 
                    randomTheme === 'adult' ? adultVocabulary : explicitVocabulary;
        patterns = randomTheme === 'sad' ? sentencePatterns.sad : 
                  randomTheme === 'romance' ? sentencePatterns.romance : 
                  randomTheme === 'adult' ? sentencePatterns.adult : sentencePatterns.explicit;
    }
    
    pattern = getRandomElement(patterns);
    sentence = pattern;
    
    // Thay th·∫ø c√°c placeholder
    sentence = sentence.replace(/{emotion}/gi, getRandomElement(vocabulary.emotions));
    sentence = sentence.replace(/{introspective}/gi, getRandomElement(vocabulary.introspective));
    sentence = sentence.replace(/{metaphor}/gi, getRandomElement(vocabulary.metaphors));
    sentence = sentence.replace(/{verb}/gi, getRandomElement(vocabulary.verbs));
    sentence = sentence.replace(/{event}/gi, getRandomElement(storyElements.events));
    sentence = sentence.replace(/{memory}/gi, getRandomElement(storyElements.memories));
    sentence = sentence.replace(/{thought}/gi, getRandomElement(storyElements.thoughts));
    sentence = sentence.replace(/{desire}/gi, getRandomElement(storyElements.desires));
    sentence = sentence.replace(/{reality}/gi, getRandomElement(vocabulary.verbs));
    sentence = sentence.replace(/{moment}/gi, getRandomElement(storyElements.times));
    sentence = sentence.replace(/{time}/gi, getRandomElement(storyElements.times));
    sentence = sentence.replace(/{state}/gi, getRandomElement(vocabulary.metaphors));
    sentence = sentence.replace(/{bodyPart}/gi, getRandomElement(vocabulary.bodyParts));
    sentence = sentence.replace(/{sensation}/gi, getRandomElement(vocabulary.sensations));
    sentence = sentence.replace(/{question}/gi, getRandomElement([
        "t√¥i l·∫°i khao kh√°t ƒëi·ªÅu n√†y",
        "m·ªçi th·ª© l·∫°i cu·ªën t√¥i v√†o",
        "t√¥i kh√¥ng th·ªÉ c∆∞·ª°ng l·∫°i ƒë∆∞·ª£c",
        "ng∆∞·ªùi ·∫•y l·∫°i khi·∫øn t√¥i say ƒë·∫Øm",
        "ham mu·ªën kh√¥ng bao gi·ªù ng·ª´ng l·∫°i",
        "t√¥i l·∫°i th√®m mu·ªën th·ªÉ x√°c ng∆∞·ªùi ·∫•y",
        "c∆° th·ªÉ t√¥i l·∫°i r·∫°o r·ª±c"
    ]));
    
    // ƒê·∫£m b·∫£o c√¢u b·∫Øt ƒë·∫ßu b·∫±ng ch·ªØ hoa v√† k·∫øt th√∫c b·∫±ng d·∫•u c√¢u
    if (!/[.!?]$/.test(sentence)) {
        sentence += ".";
    }
    
    return sentence.charAt(0).toUpperCase() + sentence.slice(1);
}

// T·∫°o ph·∫ßn m·ªü ƒë·∫ßu ch∆∞∆°ng - C·∫¢I TI·∫æN CHO N·ªòI DUNG 18+ V√Ä EXPLICIT
function generateChapterIntro(theme) {
    let intro;
    
    if (theme === 'romance') {
        const romanceIntros = [
            `T√¥i ng·ªìi ƒë√¢y, nh·ªõ v·ªÅ ng∆∞·ªùi ·∫•y v√† nh·ªØng k·ª∑ ni·ªám ƒë·∫πp.`,
            `T√¨nh y√™u ƒë·∫øn v·ªõi t√¥i nh∆∞ m·ªôt ph√©p m√†u.`,
            `Tr√°i tim t√¥i rung ƒë·ªông m·ªói khi nghƒ© v·ªÅ ng∆∞·ªùi ·∫•y.`,
            `T√¥i nh·ªõ l·∫°i ng√†y ƒë·∫ßu ti√™n ch√∫ng t√¥i g·∫∑p nhau.`,
            `T√¨nh y√™u c·ªßa ch√∫ng t√¥i nh∆∞ c√¢u chuy·ªán c·ªï t√≠ch.`,
            `M·ªói khi ·ªü b√™n ng∆∞·ªùi ·∫•y, t√¥i c·∫£m th·∫•y h·∫°nh ph√∫c tr√†n ƒë·∫ßy.`,
            `T√¥i bi·∫øt m√¨nh ƒë√£ y√™u t·ª´ c√°i nh√¨n ƒë·∫ßu ti√™n.`
        ];
        intro = getRandomElement(romanceIntros);
    } else if (theme === 'adult') {
        const adultIntros = [
            `ƒê√™m ƒë√≥, m·ªçi th·ª© b·∫Øt ƒë·∫ßu thay ƒë·ªïi gi·ªØa ch√∫ng t√¥i.`,
            `T√¥i kh√¥ng th·ªÉ ng·ª´ng nghƒ© v·ªÅ kho·∫£nh kh·∫Øc th√¢n m·∫≠t ·∫•y.`,
            `C∆° th·ªÉ t√¥i khao kh√°t s·ª± ch·∫°m v√†o t·ª´ ng∆∞·ªùi ·∫•y.`,
            `M·ªói l·∫ßn g·∫ßn nhau, c·∫£m gi√°c l·∫°i tr√†o d√¢ng m√£nh li·ªát.`,
            `T√¥i nh·ªõ l·∫°i ƒë√™m ƒë·∫ßu ti√™n ch√∫ng t√¥i ·ªü b√™n nhau.`,
            `Kh√¥ng g√¨ c√≥ th·ªÉ ngƒÉn ƒë∆∞·ª£c ham mu·ªën c·ªßa ch√∫ng t√¥i.`,
            `Kho·∫£nh kh·∫Øc ·∫•y in s√¢u trong t√¢m tr√≠ t√¥i kh√¥ng th·ªÉ phai m·ªù.`
        ];
        intro = getRandomElement(adultIntros);
    } else if (theme === 'explicit') {
        const explicitIntros = [
            `ƒê√™m ·∫•y, ch√∫ng t√¥i kh√¥ng th·ªÉ k√¨m n√©n ƒë∆∞·ª£c d·ª•c v·ªçng.`,
            `C∆° th·ªÉ t√¥i run l√™n v√¨ khao kh√°t ƒë∆∞·ª£c ch·∫°m v√†o ng∆∞·ªùi ·∫•y.`,
            `T√¥i mu·ªën chi·∫øm ƒëo·∫°t ng∆∞·ªùi ·∫•y ngay l·∫≠p t·ª©c.`,
            `Kh√¥ng gian ng·∫≠p tr√†n h∆°i th·ªü n·ªìng n√†n c·ªßa d·ª•c v·ªçng.`,
            `√Ånh m·∫Øt ng∆∞·ªùi ·∫•y khi·∫øn t√¥i kh√¥ng th·ªÉ ki·ªÅm ch·∫ø.`,
            `M·ªçi ranh gi·ªõi ƒë·ªÅu b·ªã x√≥a nh√≤a b·ªüi ham mu·ªën.`,
            `Ch√∫ng t√¥i lao v√†o nhau nh∆∞ nh·ªØng con th√∫ ƒë√≥i kh√°t.`
        ];
        intro = getRandomElement(explicitIntros);
    } else {
        const sadIntros = [
            `T√¥i ng·ªìi ƒë√¢y, m·ªôt m√¨nh v·ªõi nh·ªØng suy nghƒ© v·ªÅ ${getRandomElement(storyElements.memories)}.`,
            `K√Ω ·ª©c v·ªÅ ${getRandomElement(storyElements.memories)} l·∫°i √πa v·ªÅ trong t√¢m tr√≠ t√¥i.`,
            `C√≥ nh·ªØng ƒëi·ªÅu t√¥i ch∆∞a t·ª´ng k·ªÉ v·ªõi ai v·ªÅ ${getRandomElement(storyElements.memories)}.`,
            `ƒê√£ bao l√¢u r·ªìi k·ªÉ t·ª´ ng√†y ${getRandomElement(storyElements.memories)} tr·ªü th√†nh n·ªói √°m ·∫£nh c·ªßa t√¥i?`,
            `T√¥i nh·ªõ l·∫°i ${getRandomElement(storyElements.memories)} nh∆∞ th·ªÉ n√≥ v·ª´a m·ªõi x·∫£y ra ng√†y h√¥m qua.`,
            `Trong im l·∫∑ng c·ªßa ƒë√™m khuya, t√¥i nghƒ© v·ªÅ ${getRandomElement(storyElements.memories)}.`,
            `ƒê√¥i khi t√¥i t·ª± h·ªèi, li·ªáu ${getRandomElement(storyElements.memories)} c√≥ ƒë√°ng ƒë·ªÉ t√¥i ƒëau kh·ªï?`
        ];
        intro = getRandomElement(sadIntros);
    }
    
    return intro;
}

// H√†m vi·∫øt l·∫°i ch∆∞∆°ng
async function rewriteChapter() {
    if (!currentEditingChapter) return;
    
    showLoading(true);
    const chapterContent = document.getElementById('chapterContent');
    
    try {
        // T·∫°o phi√™n b·∫£n m·ªõi c·ªßa ch∆∞∆°ng v·ªõi c√πng ch·ªß ƒë·ªÅ
        const newContent = generateChapterContent(Array.from(aiKnowledge.vocabulary), currentTheme);
        
        // L∆∞u phi√™n b·∫£n m·ªõi d∆∞·ªõi d·∫°ng file m·ªõi
        const originalName = currentEditingChapter.name.replace('.txt', '');
        const newFileName = `${originalName}_v${Date.now()}.txt`;
        
        // L·∫•y folderId t·ª´ chapter ƒëang xem
        const response = await gapi.client.drive.files.get({
            fileId: currentEditingChapter.id,
            fields: 'parents'
        });
        
        const folderId = response.result.parents[0];
        
        // L∆∞u phi√™n b·∫£n m·ªõi
        await saveStoryContent("", newFileName, newContent, folderId, true);
        
        // Hi·ªÉn th·ªã n·ªôi dung m·ªõi
        chapterContent.textContent = newContent;
        
        // T·∫£i l·∫°i l·ªãch s·ª≠ ƒë·ªÉ c·∫≠p nh·∫≠t
        await loadStoryHistory();
        await loadAiGeneratedStories();
        
        showStatus('ƒê√£ t·∫°o phi√™n b·∫£n m·ªõi c·ªßa ch∆∞∆°ng!', 'success');
    } catch (error) {
        console.error('Error rewriting chapter:', error);
        showStatus('C√≥ l·ªói khi vi·∫øt l·∫°i ch∆∞∆°ng!', 'error');
    }
    showLoading(false);
}

// H√†m xem c√°c phi√™n b·∫£n c·ªßa ch∆∞∆°ng
async function viewChapterVersions(chapterId, folderId) {
    const versionsList = document.getElementById('versionsList');
    versionsList.innerHTML = '';
    
    try {
        // T√¨m t·∫•t c·∫£ c√°c file trong folder c√≥ t√™n b·∫Øt ƒë·∫ßu gi·ªëng chapterId
        const chapterName = currentEditingChapter.name.replace('.txt', '').split('_v')[0];
        const response = await gapi.client.drive.files.list({
            q: `'${folderId}' in parents and name contains '${chapterName}' and trashed=false`,
            fields: 'files(id, name, createdTime, description)'
        });
        
        const versions = response.result.files;
        if (versions.length > 1) {
            document.getElementById('chapterVersions').style.display = 'block';
            
            versions.forEach(version => {
                if (version.id !== chapterId) { // B·ªè qua phi√™n b·∫£n hi·ªán t·∫°i
                    const versionEl = document.createElement('div');
                    versionEl.className = 'chapter-version';
                    versionEl.innerHTML = `
                        <div class="version-header">
                            <span>${version.name}</span>
                            <span>${new Date(version.createdTime).toLocaleDateString('vi-VN')}</span>
                        </div>
                        <button class="btn" onclick="loadVersion('${version.id}')">Xem phi√™n b·∫£n n√†y</button>
                    `;
                    versionsList.appendChild(versionEl);
                }
            });
        }
    } catch (error) {
        console.error('Error loading versions:', error);
    }
}

// H√†m t·∫£i phi√™n b·∫£n ch∆∞∆°ng
async function loadVersion(versionId) {
    try {
        const response = await gapi.client.drive.files.get({
            fileId: versionId,
            alt: 'media'
        });
        
        document.getElementById('chapterContent').textContent = response.body;
        showStatus('ƒê√£ t·∫£i phi√™n b·∫£n kh√°c c·ªßa ch∆∞∆°ng!', 'success');
    } catch (error) {
        console.error('Error loading version:', error);
        showStatus('C√≥ l·ªói khi t·∫£i phi√™n b·∫£n!', 'error');
    }
}

// H√†m t·∫°o truy·ªán
async function generateStory() {
    const chapterCount = parseInt(document.getElementById('chapterCount').value) || 100;
    if (chapterCount < 100 || chapterCount > 150) {
        showStatus('S·ªë ch∆∞∆°ng ph·∫£i t·ª´ 100 ƒë·∫øn 150!', 'error');
        return;
    }
    
    if (aiKnowledge.vocabulary.size < 100) {
        showStatus('AI ch∆∞a ƒë∆∞·ª£c hu·∫•n luy·ªán ƒë·ªß! H√£y hu·∫•n luy·ªán AI v·ªõi √≠t nh·∫•t 100 t·ª´ v·ª±ng.', 'error');
        return;
    }
    
    showLoading(true);
    showStatus('AI ƒëang t·∫°o truy·ªán m·ªõi...', 'success');
    
    // X√°c ƒë·ªãnh ch·ªß ƒë·ªÅ
    const activeThemeBtn = document.querySelector('.theme-btn.active');
    currentTheme = activeThemeBtn ? activeThemeBtn.dataset.theme : 'sad';
    
    // Generate a story title based on theme
    const title = generateTitle(Array.from(aiKnowledge.vocabulary), currentTheme);
    
    // Create folder for the new story
    const storyFolderId = await createStoryFolder(title, true);
    
    // Generate chapters
    let generatedChapters = 0;
    const totalChapters = chapterCount;
    
    for (let i = 1; i <= totalChapters; i++) {
        const chapterTitle = `Ch∆∞∆°ng ${i}: ${generateChapterTitle(Array.from(aiKnowledge.vocabulary), currentTheme)}`;
        const chapterContent = generateChapterContent(Array.from(aiKnowledge.vocabulary), currentTheme);
        
        // Save chapter to Google Drive
        await saveStoryContent(title, chapterTitle, chapterContent, storyFolderId, true);
        
        generatedChapters++;
        
        // Update progress
        const progress = (generatedChapters / totalChapters) * 100;
        document.getElementById('generationProgressFill').style.width = progress + '%';
        document.getElementById('generationStatus').innerHTML = 
            `<div class="status success">ƒêang t·∫°o ch∆∞∆°ng ${generatedChapters}/${totalChapters}: ${chapterTitle}</div>`;
        
        // Small delay to avoid rate limiting
        await new Promise(resolve => setTimeout(resolve, 100));
    }
    
    // Reload AI generated stories
    await loadAiGeneratedStories();
    // C·∫¨P NH·∫¨T L·ªäCH S·ª¨ ƒê·ªÇ HI·ªÇN TH·ªä TRUY·ªÜN AI
    await loadStoryHistory();
    showLoading(false);
    showStatus(`ƒê√£ t·∫°o th√†nh c√¥ng truy·ªán "${title}" v·ªõi ${totalChapters} ch∆∞∆°ng!`, 'success');
    document.getElementById('generationStatus').innerHTML = '';
}

// H√†m t·∫°o ti√™u ƒë·ªÅ d·ª±a tr√™n ch·ªß ƒë·ªÅ - C·∫¢I TI·∫æN CHO N·ªòI DUNG 18+ V√Ä EXPLICIT
function generateTitle(words, theme) {
    if (theme === 'romance') {
        const romanceTitles = [
            "Chuy·ªán T√¨nh C·ªßa Ch√∫ng T√¥i",
            "Tr√°i Tim Y√™u Th∆∞∆°ng",
            "T√¨nh Y√™u B·∫•t Di·ªát",
            "M·ªëi T√¨nh ƒê·∫ßu",
            "√Ånh TrƒÉng V√† T√¨nh Y√™u",
            "Tr√°i Tim Rung ƒê·ªông",
            "T√¨nh Y√™u Mu√¥n M√†u"
        ];
        return getRandomElement(romanceTitles);
    } else if (theme === 'adult') {
        const adultTitles = [
            "ƒê√™m Kh√≥ Qu√™n",
            "Nh·ªØng K·ª∑ Ni·ªám ƒê√™m",
            "Kh√°t V·ªçng T√¨nh Y√™u",
            "B√≠ M·∫≠t Ph√≤ng The",
            "Nh·ªØng L·∫ßn ƒê·∫ßu Ti√™n",
            "M·∫≠t Ng·ªçt T√¨nh Y√™u",
            "ƒêam M√™ B√≠ ·∫®n"
        ];
        return getRandomElement(adultTitles);
    } else if (theme === 'explicit') {
        const explicitTitles = [
            "ƒê√™m Cu·ªìng D√¢m",
            "Nh·ª•c D·ª•c V√¥ Bi√™n",
            "Cu·ªìng N·ªô Th·ªÉ X√°c",
            "D√¢m D·ª•c ƒê√™m Khuya",
            "L·ª≠a D·ª•c Thi√™u ƒê·ªët",
            "ƒêam M√™ T·ªôi L·ªói",
            "Th√°c Lo·∫°n T√¨nh D·ª•c"
        ];
        return getRandomElement(explicitTitles);
    }
    
    // Simple title generation based on learned vocabulary for other themes
    const titleLength = 2 + Math.floor(Math.random() * 3);
    let title = '';
    
    for (let i = 0; i < titleLength; i++) {
        const randomIndex = Math.floor(Math.random() * words.length);
        const word = words[randomIndex];
        title += word.charAt(0).toUpperCase() + word.slice(1) + ' ';
    }
    
    return title.trim();
}

// H√†m t·∫°o ti√™u ƒë·ªÅ ch∆∞∆°ng d·ª±a tr√™n ch·ªß ƒë·ªÅ - C·∫¢I TI·∫æN CHO N·ªòI DUNG 18+ V√Ä EXPLICIT
function generateChapterTitle(words, theme) {
    if (theme === 'romance') {
        const romanceTitles = [
            "L·∫ßn ƒê·∫ßu G·∫∑p G·ª°",
            "√Ånh M·∫Øt ƒê·ªãnh M·ªánh",
            "L·ªùi T·ªè T√¨nh",
            "N·ª• H√¥n ƒê·∫ßu",
            "Ng√†y ƒê·∫πp Tr·ªùi",
            "B√™n Nhau Tr·ªçn ƒê·ªùi",
            "H·∫°nh Ph√∫c Tr√≤n ƒê·∫ßy",
            "L·ªùi H·ª©a Y√™u Th∆∞∆°ng",
            "Chuy·∫øn ƒêi ƒê√°ng Nh·ªõ",
            "K·ª∑ Ni·ªám Ng·ªçt Ng√†o"
        ];
        return getRandomElement(romanceTitles);
    } else if (theme === 'adult') {
        const adultTitles = [
            "ƒê√™m ƒê·∫ßu Ti√™n",
            "Kh√°t V·ªçng D√¢ng Tr√†o",
            "B√≠ M·∫≠t ƒê√™m Khuya",
            "Kho·∫£nh Kh·∫Øc Say ƒê·∫Øm",
            "Nh·ªØng Vu·ªët Ve ƒê·∫ßu Ti√™n",
            "ƒêam M√™ B·ª´ng Ch√°y",
            "Ranh Gi·ªõi Mong Manh",
            "V∆∞·ª£t Qua Gi·ªõi H·∫°n",
            "Kh√°m Ph√° C∆° Th·ªÉ",
            "ƒê·ªânh Cao Kho√°i C·∫£m"
        ];
        return getRandomElement(adultTitles);
    } else if (theme === 'explicit') {
        const explicitTitles = [
            "Cu·ªìng D√¢m B·∫•t T·∫≠n",
            "ƒê·ªãt Nhau Th√¢u ƒê√™m",
            "D√¢m ƒê√£ng T·ªôt C√πng",
            "Xu·∫•t Tinh Kh√¥ng Ki·ªÉm So√°t",
            "√Çn √Åi ƒêi√™n Cu·ªìng",
            "L√™n ƒê·ªânh Li√™n T·ª•c",
            "Th√°c Lo·∫°n Th·ªÉ X√°c",
            "D·ª•c V·ªçng Tr√†n Tr·ªÅ",
            "Giao H·ª£p M√£nh Li·ªát",
            "Kho√°i L·∫°c T·ªôt ƒê·ªânh"
        ];
        return getRandomElement(explicitTitles);
    }
    
    // Generate a chapter title for other themes
    const titleLength = 3 + Math.floor(Math.random() * 4);
    let title = '';
    
    for (let i = 0; i < titleLength; i++) {
        const randomIndex = Math.floor(Math.random() * words.length);
        const word = words[randomIndex];
        title += word.charAt(0).toUpperCase() + word.slice(1) + ' ';
    }
    
    return title.trim();
}

// H√†m x·ª≠ l√Ω khi ch·ªçn ch·ªß ƒë·ªÅ - TH√äM KI·ªÇM SO√ÅT N·ªòI DUNG 18+ V√Ä EXPLICIT
function handleThemeSelection(theme) {
    currentTheme = theme;
    
    // Hi·ªÉn th·ªã c·∫£nh b√°o n·∫øu ch·ªçn ch·ªß ƒë·ªÅ ng∆∞·ªùi l·ªõn
    if (theme === 'adult' || theme === 'explicit') {
        document.getElementById('adultWarning').style.display = 'block';
        document.getElementById('adultToggle').style.display = 'flex';
        document.getElementById('generateStoryButton').disabled = true;
    } else {
        document.getElementById('adultWarning').style.display = 'none';
        document.getElementById('adultToggle').style.display = 'none';
        document.getElementById('generateStoryButton').disabled = false;
    }
}

// H√†m ki·ªÉm tra xem n·ªôi dung c√≥ nh·∫°y c·∫£m kh√¥ng - M·ªû R·ªòNG
function isSensitiveContent(content) {
    const sensitiveKeywords = [
        'd·ª•c', 'khao kh√°t', 'ham mu·ªën', 'th√¢n m·∫≠t', 'g·ªëi chƒÉn', '√¢n √°i', 
        'k√≠ch d·ª•c', 'kho√°i c·∫£m', 'd√¢m', 'lo·∫°n', 'luy·∫øn', '·∫•u d√¢m', 
        'c∆° th·ªÉ', 'ch·∫°m', 'vu·ªët ve', 'h√¥n', 'c·∫Øn', '√¥m', 'si·∫øt ch·∫∑t',
        'l·ªìn', 'c·∫∑c', 'ƒë·ªãt', 'ch·ªãch', 'phang', 'ƒë·ª•', 'd∆∞∆°ng v·∫≠t', '√¢m ƒë·∫°o',
        '√¢m h·ªô', 'h·∫≠u m√¥n', 'v√∫', 'ƒë·∫ßu v√∫', 'm√¥ng', 'h√°ng', 'b∆∞·ªõm', 'c·∫≠u nh·ªè',
        'c·ª≠a m√¨nh', 'b√¨u', 'd∆∞∆°ng v·∫≠t', '√¢m v·∫≠t', 'g√≤ mu', 'l√¥ng mu', 'h√∫p',
        'li·∫øm', 'b√∫', 'c∆∞·ª°ng b·ª©c', 'xu·∫•t tinh', 'l√™n ƒë·ªânh', 'th·∫©m du', 't·ª± s∆∞·ªõng',
        'kh·∫©u giao', 'giao h·ª£p', 'l√†m t√¨nh', 'ƒë√≥ng ƒëinh'
    ];
    
    return sensitiveKeywords.some(keyword => 
        content.toLowerCase().includes(keyword.toLowerCase())
    );
}

// H√†m hi·ªÉn th·ªã n·ªôi dung ch∆∞∆°ng v·ªõi ki·ªÉm so√°t n·ªôi dung nh·∫°y c·∫£m - M·ªû R·ªòNG
async function viewChapterContent(chapter, folderId) {
    const chapterContent = document.getElementById('chapterContent');
    const chapterActions = document.getElementById('chapterActions');
    const chapterVersions = document.getElementById('chapterVersions');
    
    try {
        const response = await gapi.client.drive.files.get({
            fileId: chapter.id,
            alt: 'media'
        });
        
        const content = response.body;
        chapterContent.textContent = content;
        chapterContent.style.display = 'block';
        chapterActions.style.display = 'block';
        currentEditingChapter = { id: chapter.id, content: content, name: chapter.name };
        
        // Ki·ªÉm tra v√† x·ª≠ l√Ω n·ªôi dung nh·∫°y c·∫£m
        if (isSensitiveContent(content)) {
            chapterContent.classList.add('sensitive-content');
            
            // Th√™m n√∫t hi·ªÉn th·ªã n·ªôi dung
            const revealBtn = document.createElement('button');
            revealBtn.className = 'reveal-btn';
            revealBtn.textContent = 'üëÅÔ∏è Hi·ªÉn th·ªã n·ªôi dung nh·∫°y c·∫£m';
            revealBtn.onclick = function() {
                chapterContent.classList.toggle('revealed');
                this.textContent = chapterContent.classList.contains('revealed') ? 
                    'üôà ·∫®n n·ªôi dung nh·∫°y c·∫£m' : 'üëÅÔ∏è Hi·ªÉn th·ªã n·ªôi dung nh·∫°y c·∫£m';
            };
            
            chapterContent.parentNode.insertBefore(revealBtn, chapterContent);
        }
        
        // ·∫®n ph·∫ßn phi√™n b·∫£n tr∆∞·ªõc khi t·∫£i m·ªõi
        chapterVersions.style.display = 'none';
        
        // T·∫£i c√°c phi√™n b·∫£n kh√°c c·ªßa ch∆∞∆°ng n√†y
        await viewChapterVersions(chapter.id, folderId);
    } catch (error) {
        console.error('Error loading chapter content:', error);
        showStatus('C√≥ l·ªói khi t·∫£i n·ªôi dung ch∆∞∆°ng!', 'error');
    }
}

// UI Functions
function displayHistory() {
    const historyList = document.getElementById('historyList');
    historyList.innerHTML = '';
    
    // Hi·ªÉn th·ªã c·∫£ truy·ªán ng∆∞·ªùi d√πng v√† truy·ªán AI
    const allStories = [...storyHistory, ...aiGeneratedStories];
    
    if (allStories.length === 0) {
        historyList.innerHTML = '<div class="history-item">Ch∆∞a c√≥ truy·ªán n√†o.</div>';
        return;
    }
    
    allStories.forEach(story => {
        const item = document.createElement('div');
        item.className = 'history-item';
        item.onclick = () => viewStoryChapters(story);
        
        // Ki·ªÉm tra xem truy·ªán c√≥ n·ªôi dung nh·∫°y c·∫£m kh√¥ng
        let adultTag = '';
        if (aiKnowledge.explicitStories && aiKnowledge.explicitStories.has(story.storyTitle)) {
            adultTag = ' <span style="color:#ff6b6b">[EXPLICIT]</span>';
        } else if (aiKnowledge.adultStories && aiKnowledge.adultStories.has(story.storyTitle)) {
            adultTag = ' <span style="color:#ff9a3d">[18+]</span>';
        }
        
        item.innerHTML = `
            <div class="story-title">${story.storyTitle} ${story.isAiGenerated ? '(AI T·∫°o)' : ''}${adultTag}</div>
            <div class="story-chapter">${story.chapters.length} ch∆∞∆°ng</div>
            <div class="story-date">${new Date(story.createdTime).toLocaleDateString('vi-VN')}</div>
        `;
        historyList.appendChild(item);
    });
}

function displayFolders() {
    const folderList = document.getElementById('folderList');
    const existingStory = document.getElementById('existingStory');
    folderList.innerHTML = '';
    existingStory.innerHTML = '<option value="">-- Ch·ªçn truy·ªán --</option>';
    
    if (storyHistory.length === 0) {
        folderList.innerHTML = '<div class="history-item">Ch∆∞a c√≥ th∆∞ m·ª•c n√†o.</div>';
        return;
    }
    
    storyHistory.forEach(story => {
        // Add to folder list
        const item = document.createElement('div');
        item.className = 'history-item';
        
        // Ki·ªÉm tra xem truy·ªán c√≥ n·ªôi dung nh·∫°y c·∫£m kh√¥ng
        let adultTag = '';
        if (aiKnowledge.explicitStories && aiKnowledge.explicitStories.has(story.storyTitle)) {
            adultTag = ' <span style="color:#ff6b6b">[EXPLICIT]</span>';
        } else if (aiKnowledge.adultStories && aiKnowledge.adultStories.has(story.storyTitle)) {
            adultTag = ' <span style="color:#ff9a3d">[18+]</span>';
        }
        
        item.innerHTML = `
            <div class="story-title">${story.storyTitle}${adultTag}</div>
            <div class="story-chapter">${story.chapters.length} ch∆∞∆°ng</div>
        `;
        folderList.appendChild(item);
        
        // Add to existing story dropdown
        const option = document.createElement('option');
        option.value = story.folderId;
        option.textContent = story.storyTitle;
        existingStory.appendChild(option);
    });
}

function toggleStoryMode() {
    const mode = document.getElementById('storyMode').value;
    if (mode === 'new') {
        document.getElementById('newStoryGroup').style.display = 'block';
        document.getElementById('existingStoryGroup').style.display = 'none';
        document.getElementById('submitButtonText').textContent = 'L∆∞u Truy·ªán M·ªõi';
    } else {
        document.getElementById('newStoryGroup').style.display = 'none';
        document.getElementById('existingStoryGroup').style.display = 'block';
        document.getElementById('submitButtonText').textContent = 'Th√™m Ch∆∞∆°ng M·ªõi';
    }
}

async function handleStoryFormSubmit(e) {
    e.preventDefault();
    showLoading(true);
    
    const mode = document.getElementById('storyMode').value;
    const storyTitle = document.getElementById('storyTitle').value;
    const chapterTitle = document.getElementById('chapterTitle').value;
    const storyContent = document.getElementById('storyContent').value;
    
    try {
        let storyFolderId;
        if (mode === 'new') {
            storyFolderId = await createStoryFolder(storyTitle);
        } else {
            storyFolderId = document.getElementById('existingStory').value;
            if (!storyFolderId) {
                showStatus('Vui l√≤ng ch·ªçn m·ªôt truy·ªán c√≥ s·∫µn!', 'error');
                showLoading(false);
                return;
            }
        }
        
        await saveStoryContent(storyTitle, chapterTitle, storyContent, storyFolderId);
        await loadStoryHistory();
        
        document.getElementById('storyForm').reset();
        showStatus('ƒê√£ l∆∞u truy·ªán th√†nh c√¥ng!', 'success');
    } catch (error) {
        console.error('Error saving story:', error);
        showStatus('C√≥ l·ªói x·∫£y ra khi l∆∞u truy·ªán!', 'error');
    }
    showLoading(false);
}

function showStatus(message, type) {
    const statusEl = document.getElementById('status');
    statusEl.textContent = message;
    statusEl.className = `status ${type}`;
    statusEl.style.display = 'block';
    setTimeout(() => { statusEl.style.display = 'none'; }, 5000);
}

function showLoading(show) {
    document.getElementById('loading').style.display = show ? 'block' : 'none';
}

// Modal Functions
function viewStoryChapters(story) {
    const modal = document.getElementById('chaptersModal');
    const title = document.getElementById('chaptersModalTitle');
    const chapterList = document.getElementById('chapterList');
    const chapterContent = document.getElementById('chapterContent');
    const chapterActions = document.getElementById('chapterActions');
    
    title.textContent = story.storyTitle;
    chapterList.innerHTML = '';
    chapterContent.style.display = 'none';
    chapterActions.style.display = 'none';
    
    story.chapters.forEach(chapter => {
        const item = document.createElement('div');
        item.className = 'chapter-item';
        item.onclick = () => viewChapterContent(chapter, story.folderId);
        item.textContent = chapter.name.replace('.txt', '');
        chapterList.appendChild(item);
    });
    
    modal.style.display = 'block';
}

function editChapter() {
    const chapterContent = document.getElementById('chapterContent');
    chapterContent.contentEditable = true;
    chapterContent.focus();
    chapterContent.style.background = 'rgba(255, 255, 255, 0.1)';
    chapterContent.style.border = '1px solid rgba(102, 126, 234, 0.5)';
}

async function saveChapterChanges() {
    if (!currentEditingChapter) return;
    
    const chapterContent = document.getElementById('chapterContent');
    const newContent = chapterContent.textContent;
    
    try {
        await gapi.client.request({
            path: `https://www.googleapis.com/upload/drive/v3/files/${currentEditingChapter.id}`,
            method: 'PATCH',
            params: { uploadType: 'media' },
            body: newContent
        });
        
        chapterContent.contentEditable = false;
        chapterContent.style.background = 'rgba(255, 255, 255, 0.05)';
        chapterContent.style.border = 'none';
        currentEditingChapter.content = newContent;
        
        showStatus('ƒê√£ l∆∞u thay ƒë·ªïi th√†nh c√¥ng!', 'success');
    } catch (error) {
        console.error('Error saving chapter changes:', error);
        showStatus('C√≥ l·ªói khi l∆∞u thay ƒë·ªïi!', 'error');
    }
}

function cancelEdit() {
    const chapterContent = document.getElementById('chapterContent');
    chapterContent.textContent = currentEditingChapter.content;
    chapterContent.contentEditable = false;
    chapterContent.style.background = 'rgba(255, 255, 255, 0.05)';
    chapterContent.style.border = 'none';
}

async function deleteChapter() {
    if (!currentEditingChapter || !confirm('B·∫°n c√≥ ch·∫Øc ch·∫Øn mu·ªën x√≥a ch∆∞∆°ng n√†y?')) return;
    
    try {
        await gapi.client.drive.files.delete({ fileId: currentEditingChapter.id });
        closeModal('chaptersModal');
        await loadStoryHistory();
        showStatus('ƒê√£ x√≥a ch∆∞∆°ng th√†nh c√¥ng!', 'success');
    } catch (error) {
        console.error('Error deleting chapter:', error);
        showStatus('C√≥ l·ªói khi x√≥a ch∆∞∆°ng!', 'error');
    }
}

function closeModal(modalId) {
    document.getElementById(modalId).style.display = 'none';
    currentEditingChapter = null;
}

function viewAiStories() {
    const modal = document.getElementById('aiStoriesModal');
    const aiStoryList = document.getElementById('aiStoryList');
    
    aiStoryList.innerHTML = '';
    
    if (aiGeneratedStories.length === 0) {
        aiStoryList.innerHTML = '<div class="history-item">Ch∆∞a c√≥ truy·ªán n√†o ƒë∆∞·ª£c AI t·∫°o.</div>';
    } else {
        aiGeneratedStories.forEach(story => {
            const item = document.createElement('div');
            item.className = 'ai-story-item';
            item.onclick = () => {
                closeModal('aiStoriesModal');
                viewStoryChapters(story);
            };
            
            // Ki·ªÉm tra xem truy·ªán c√≥ n·ªôi dung nh·∫°y c·∫£m kh√¥ng
            let adultTag = '';
            if (aiKnowledge.explicitStories && aiKnowledge.explicitStories.has(story.storyTitle)) {
                adultTag = ' <span style="color:#ff6b6b">[EXPLICIT]</span>';
            } else if (aiKnowledge.adultStories && aiKnowledge.adultStories.has(story.storyTitle)) {
                adultTag = ' <span style="color:#ff9a3d">[18+]</span>';
            }
            
            item.innerHTML = `
                <div class="ai-story-title">${story.storyTitle}${adultTag}</div>
                <div class="ai-story-info">${story.chapters.length} ch∆∞∆°ng - ${new Date(story.createdTime).toLocaleDateString('vi-VN')}</div>
            `;
            aiStoryList.appendChild(item);
        });
    }
    
    modal.style.display = 'block';
}

// Menu Navigation
function showSection(sectionId) {
    // Hide all sections
    document.querySelectorAll('.content-section').forEach(section => {
        section.classList.remove('active');
    });
    
    // Show selected section
    document.getElementById(sectionId).classList.add('active');
    
    // Update active button
    document.querySelectorAll('.nav-menu button').forEach(button => {
        button.classList.remove('active');
    });
    document.querySelector(`.nav-menu button[data-section="${sectionId}"]`).classList.add('active');
}

// Event Listeners
document.getElementById('authorizeButton').addEventListener('click', handleAuthClick);
document.getElementById('signoutButton').addEventListener('click', handleSignoutClick);
document.getElementById('storyForm').addEventListener('submit', handleStoryFormSubmit);
document.getElementById('trainAiButton').addEventListener('click', trainAI);
document.getElementById('resetAiButton').addEventListener('click', resetAI);
document.getElementById('generateStoryButton').addEventListener('click', generateStory);
document.getElementById('viewAiStoriesButton').addEventListener('click', viewAiStories);

// Menu navigation event listeners
document.getElementById('menuTraining').addEventListener('click', () => showSection('trainingSection'));
document.getElementById('menuGeneration').addEventListener('click', () => showSection('generationSection'));
document.getElementById('menuManagement').addEventListener('click', () => showSection('managementSection'));
document.getElementById('menuHistory').addEventListener('click', () => showSection('historySection'));

// Add data-section attributes to menu buttons
document.getElementById('menuTraining').setAttribute('data-section', 'trainingSection');
document.getElementById('menuGeneration').setAttribute('data-section', 'generationSection');
document.getElementById('menuManagement').setAttribute('data-section', 'managementSection');
document.getElementById('menuHistory').setAttribute('data-section', 'historySection');

// C·∫¨P NH·∫¨T S·ª∞ KI·ªÜN CH·ªåN CH·ª¶ ƒê·ªÄ
document.querySelectorAll('.theme-btn').forEach(btn => {
    btn.addEventListener('click', function() {
        document.querySelectorAll('.theme-btn').forEach(b => b.classList.remove('active'));
        this.classList.add('active');
        handleThemeSelection(this.dataset.theme);
    });
});

// TH√äM S·ª∞ KI·ªÜN CHO CHECKBOX ƒê·ªíNG √ù N·ªòI DUNG 18+
document.getElementById('adultConsent').addEventListener('change', function() {
    document.getElementById('generateStoryButton').disabled = !this.checked;
});

// Initialize the app
window.onload = () => {
    initializeGapi();
    initializeGis();
};
</script>
</body>
</html>
