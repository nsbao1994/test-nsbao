<!DOCTYPE html>
<html lang="vi">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, viewport-fit=cover">
    <title>Tr√¨nh Ph√¢n T√≠ch & T·∫°o Truy·ªán N√¢ng Cao</title>
    <script src="https://apis.google.com/js/api.js"></script>
    <script src="https://accounts.google.com/gsi/client"></script>
    <style>
        :root {
            --primary-color: #8e44ad;
            --secondary-color: #3498db;
            --dark-color: #2c3e50;
            --light-color: #ecf0f1;
            --accent-color: #e74c3c;
            --success-color: #27ae60;
            --warning-color: #f39c12;
            --text-color: #333;
            --card-bg: rgba(255, 255, 255, 0.95);
            --border-radius: 16px;
            --shadow: 0 4px 20px rgba(0, 0, 0, 0.1);
            --safe-area-inset-top: env(safe-area-inset-top);
            --safe-area-inset-bottom: env(safe-area-inset-bottom);
            --safe-area-inset-left: env(safe-area-inset-left);
            --safe-area-inset-right: env(safe-area-inset-right);
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            -webkit-tap-highlight-color: transparent;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Helvetica, Arial, sans-serif;
            background: linear-gradient(135deg, #8e44ad 0%, #2c3e50 100%);
            min-height: 100vh;
            color: var(--text-color);
            padding: var(--safe-area-inset-top) var(--safe-area-inset-right) var(--safe-area-inset-bottom) var(--safe-area-inset-left);
            line-height: 1.6;
        }

        .container {
            max-width: 100%;
            margin: 0 auto;
            padding: 16px;
            padding-bottom: 80px;
        }

        .header {
            text-align: center;
            margin-bottom: 20px;
            color: white;
            padding-top: 12px;
        }

        .header h1 {
            font-size: 1.8rem;
            margin-bottom: 8px;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.3);
            font-weight: 700;
        }

        .header p {
            font-size: 1rem;
            opacity: 0.9;
            font-weight: 400;
        }

        .card {
            background: var(--card-bg);
            border-radius: var(--border-radius);
            padding: 20px;
            margin-bottom: 20px;
            box-shadow: var(--shadow);
            backdrop-filter: blur(10px);
        }

        .bottom-menu {
            position: fixed;
            bottom: 0;
            left: 0;
            right: 0;
            background: rgba(44, 62, 80, 0.95);
            backdrop-filter: blur(10px);
            padding: 12px 16px;
            padding-bottom: calc(16px + var(--safe-area-inset-bottom));
            display: flex;
            justify-content: space-around;
            border-top: 1px solid rgba(255, 255, 255, 0.1);
            z-index: 1000;
        }

        .menu-item {
            display: flex;
            flex-direction: column;
            align-items: center;
            color: var(--light-color);
            text-decoration: none;
            font-size: 0.8rem;
            opacity: 0.7;
            transition: opacity 0.3s;
        }

        .menu-item.active {
            opacity: 1;
        }

        .menu-icon {
            font-size: 1.4rem;
            margin-bottom: 4px;
        }

        .tab-content {
            display: none;
        }

        .tab-content.active {
            display: block;
        }

        .btn {
            background: var(--primary-color);
            color: white;
            border: none;
            padding: 14px 20px;
            border-radius: 50px;
            font-size: 1rem;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
            box-shadow: 0 4px 12px rgba(0,0,0,0.15);
            margin: 6px 0;
            width: 100%;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
        }

        .btn-secondary {
            background: var(--secondary-color);
        }

        .btn-danger {
            background: var(--accent-color);
        }

        .btn-success {
            background: var(--success-color);
        }

        .btn-warning {
            background: var(--warning-color);
        }

        .btn:disabled {
            background: #95a5a6;
            cursor: not-allowed;
            transform: none;
            box-shadow: none;
        }

        .story-content {
            background: #f8f9fa;
            border-radius: 12px;
            padding: 16px;
            margin: 12px 0;
            border-left: 4px solid var(--primary-color);
            font-family: 'Times New Roman', serif;
            line-height: 1.8;
            max-height: 50vh;
            overflow-y: auto;
        }

        .chapter-title {
            color: var(--primary-color);
            font-size: 1.2rem;
            margin-bottom: 10px;
            font-weight: bold;
        }

        .progress-container {
            margin: 15px 0;
        }

        .progress-bar {
            width: 100%;
            height: 20px;
            background: #e9ecef;
            border-radius: 10px;
            overflow: hidden;
        }

        .progress-fill {
            height: 100%;
            background: linear-gradient(to right, #8e44ad, #3498db);
            width: 0%;
            transition: width 0.5s ease;
            border-radius: 10px;
        }

        .status-info {
            padding: 10px;
            border-radius: 8px;
            margin: 10px 0;
            background: rgba(255, 255, 255, 0.2);
            color: white;
        }

        .detailed-status {
            font-size: 0.9rem;
            color: #ecf0f1;
            margin-top: 5px;
        }

        .toggle-container {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin: 12px 0;
        }

        .toggle-switch {
            position: relative;
            display: inline-block;
            width: 50px;
            height: 24px;
        }

        .toggle-switch input {
            opacity: 0;
            width: 0;
            height: 0;
        }

        .slider {
            position: absolute;
            cursor: pointer;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-color: #ccc;
            transition: .4s;
            border-radius: 24px;
        }

        .slider:before {
            position: absolute;
            content: "";
            height: 18px;
            width: 18px;
            left: 3px;
            bottom: 3px;
            background-color: white;
            transition: .4s;
            border-radius: 50%;
        }

        input:checked + .slider {
            background-color: var(--primary-color);
        }

        input:checked + .slider:before {
            transform: translateX(26px);
        }

        .character-profile {
            display: flex;
            align-items: center;
            margin: 15px 0;
            padding: 10px;
            background: rgba(236, 240, 241, 0.3);
            border-radius: 10px;
        }

        .character-avatar {
            width: 50px;
            height: 50px;
            border-radius: 50%;
            background: var(--primary-color);
            display: flex;
            align-items: center;
            justify-content: center;
            color: white;
            font-size: 1.5rem;
            margin-right: 15px;
        }

        .character-details {
            flex: 1;
        }

        .character-name {
            font-weight: bold;
            color: var(--dark-color);
        }

        .character-desc {
            font-size: 0.9rem;
            color: #7f8c8d;
        }

        .emotion-tag {
            display: inline-block;
            padding: 4px 10px;
            border-radius: 15px;
            font-size: 0.8rem;
            margin: 3px;
            background: #e74c3c;
            color: white;
        }

        .emotion-buon {
            background: #3498db;
        }

        .emotion-dau {
            background: #e74c3c;
        }

        .emotion-bat-luc {
            background: #95a5a6;
        }

        .sensitive-word {
            background: #e74c3c;
            color: white;
            padding: 2px 4px;
            border-radius: 4px;
            font-size: 0.9em;
        }

        .dialogue {
            font-style: italic;
            color: #2c3e50;
            margin: 5px 0;
            padding-left: 15px;
            border-left: 3px solid #3498db;
        }

        .analysis-result-item {
            margin: 10px 0;
            padding: 10px;
            background: #f8f9fa;
            border-radius: 8px;
        }

        .loading {
            display: inline-block;
            width: 18px;
            height: 18px;
            border: 2px solid #f3f3f3;
            border-top: 2px solid var(--primary-color);
            border-radius: 50%;
            animation: spin 1s linear infinite;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        @media only screen and (device-width: 375px) and (device-height: 812px) and (-webkit-device-pixel-ratio: 3) {
            .container {
                padding: 12px;
                padding-bottom: 80px;
            }
            
            .header h1 {
                font-size: 1.6rem;
            }
            
            .card {
                padding: 16px;
            }
            
            .btn {
                padding: 12px 16px;
                font-size: 0.9rem;
            }
            
            .story-content {
                font-size: 0.95rem;
                max-height: 45vh;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>üìñ Tr√¨nh Ph√¢n T√≠ch & T·∫°o Truy·ªán</h1>
            <p>Ph√¢n t√≠ch n√¢ng cao v√† t·∫°o truy·ªán t·ª± ƒë·ªông</p>
        </div>

        <div id="tab-analysis" class="tab-content active">
            <div class="card">
                <h3>üîç Ph√¢n t√≠ch ngu·ªìn truy·ªán</h3>
                <p>Ph√¢n t√≠ch c√°c file vƒÉn b·∫£n ƒë·ªÉ t·∫°o d·ªØ li·ªáu cho truy·ªán</p>
                
                <div class="status-info" id="statusInfo">
                    <p>üî¥ Ch∆∞a k·∫øt n·ªëi Google Drive</p>
                    <div class="detailed-status" id="detailedStatus"></div>
                </div>
                <div id="detailedStatus" style="margin-top:10px; color:#555; font-size:14px;"></div>
                <div class="progress-container">
                    <div class="progress-bar">
                        <div class="progress-fill" id="progressBar"></div>
                    </div>
                </div>
                
                <button class="btn" onclick="handleAuthClick()">
                    üìÅ K·∫øt n·ªëi Google Drive
                </button>
                
                <button class="btn btn-secondary" id="scanBtn" onclick="scanFolder()" disabled>
                    üîç Qu√©t th∆∞ m·ª•c
                </button>
                
                <button class="btn btn-warning" id="analyzeBtn" onclick="analyzeFiles()" disabled>
                    üß† Ph√¢n t√≠ch n√¢ng cao
                </button>
                
                <div class="toggle-container">
                    <span>B·ªè qua file ƒë√£ ph√¢n t√≠ch</span>
                    <label class="toggle-switch">
                        <input type="checkbox" id="skipAnalyzedFiles" checked>
                        <span class="slider"></span>
                    </label>
                </div>
            </div>
            
            <div class="card">
                <h3>üìä K·∫øt qu·∫£ ph√¢n t√≠ch</h3>
                <div id="analysisResults">
                    <p>Ch∆∞a c√≥ d·ªØ li·ªáu ph√¢n t√≠ch. Vui l√≤ng qu√©t v√† ph√¢n t√≠ch th∆∞ m·ª•c tr∆∞·ªõc.</p>
                </div>
            </div>
        </div>

        <div id="tab-write" class="tab-content">
            <div class="card">
                <h3>‚úçÔ∏è Vi·∫øt truy·ªán</h3>
                <p>T·∫°o truy·ªán m·ªõi d·ª±a tr√™n d·ªØ li·ªáu ƒë√£ ph√¢n t√≠ch</p>
                
                <div class="character-profile">
                    <div class="character-avatar">üë®</div>
                    <div class="character-details">
                        <div class="character-name">Ng∆∞·ªùi k·ªÉ chuy·ªán</div>
                        <div class="character-desc">T·∫°o truy·ªán t·ª´ d·ªØ li·ªáu ƒë√£ ph√¢n t√≠ch</div>
                    </div>
                </div>
                
                <div class="toggle-container">
                    <span>S·ªë ch∆∞∆°ng (50+):</span>
                    <input type="number" id="minChapters" value="50" min="50" max="100" style="width: 60px; padding: 5px; border-radius: 5px; border: 1px solid #ddd;">
                </div>

                <div class="toggle-container">
                    <span>ƒê·ªô nh·∫°y c·∫£m:</span>
                    <input type="range" id="sensitivityLevel" min="1" max="10" value="5" style="width: 120px;">
                    <span id="sensitivityValue">5</span>
                </div>
                
                <button class="btn btn-success" id="generateBtn" onclick="generateStories()" disabled>
                    ‚úçÔ∏è B·∫Øt ƒë·∫ßu vi·∫øt truy·ªán
                </button>
                
                <div class="progress-container">
                    <div class="progress-bar">
                        <div class="progress-fill" id="writeProgressBar"></div>
                    </div>
                </div>
                
                <div class="status-info">
                    <p id="writeStatus">Ch∆∞a b·∫Øt ƒë·∫ßu vi·∫øt truy·ªán</p>
                    <div class="detailed-status" id="writeDetailedStatus"></div>
                </div>
            </div>
            
            <div class="card">
                <h3>üìñ Truy·ªán ƒëang vi·∫øt</h3>
                <div id="generatedStories">
                    <p>Ch∆∞a c√≥ truy·ªán n√†o ƒë∆∞·ª£c t·∫°o. H√£y b·∫•m "B·∫Øt ƒë·∫ßu vi·∫øt truy·ªán" ƒë·ªÉ b·∫Øt ƒë·∫ßu.</p>
                </div>
            </div>
        </div>

        <div id="tab-stories" class="tab-content">
            <div class="card">
                <h3>üìö Th∆∞ vi·ªán truy·ªán</h3>
                <p>Nh·ªØng truy·ªán ƒë√£ ƒë∆∞·ª£c t·∫°o v√† l∆∞u tr·ªØ</p>
                
                <div id="storiesLibrary">
                    <p>Ch∆∞a c√≥ truy·ªán n√†o trong th∆∞ vi·ªán.</p>
                </div>
                
                <button class="btn btn-secondary" id="loadStoriesBtn" onclick="loadStories()">
                    üîÑ T·∫£i danh s√°ch truy·ªán
                </button>
            </div>
        </div>

        <div id="tab-settings" class="tab-content">
            <div class="card">
                <h3>‚öôÔ∏è C√†i ƒë·∫∑t</h3>
                
                <div class="toggle-container">
                    <span>T·ª± ƒë·ªông l∆∞u ti·∫øn ƒë·ªô</span>
                    <label class="toggle-switch">
                        <input type="checkbox" id="autoSaveResults" checked>
                        <span class="slider"></span>
                    </label>
                </div>
                
                <div class="toggle-container">
                    <span>G·ª≠i d·ªØ li·ªáu c·∫£i thi·ªán AI</span>
                    <label class="toggle-switch">
                        <input type="checkbox" id="sendImprovementData" checked>
                        <span class="slider"></span>
                    </label>
                </div>
                
                <button class="btn" onclick="clearCache()">
                    üóëÔ∏è X√≥a d·ªØ li·ªáu t·∫°m
                </button>
                
                <button class="btn btn-danger" onclick="handleSignoutClick()">
                    üö™ ƒêƒÉng xu·∫•t
                </button>
            </div>
            
            <div class="card">
                <h3>‚ÑπÔ∏è Th√¥ng tin ·ª©ng d·ª•ng</h3>
                <p>Phi√™n b·∫£n: 2.1.0</p>
                <p>Ph√¢n t√≠ch n√¢ng cao: H·ªôi tho·∫°i & T·ª´ nh·∫°y c·∫£m</p>
                <p>G√≥c nh√¨n: Linh ho·∫°t theo ph√¢n t√≠ch</p>
            </div>
        </div>
    </div>

    <div class="bottom-menu">
        <a href="#" class="menu-item active" onclick="switchTab('tab-analysis')">
            <div class="menu-icon">üîç</div>
            <span>Ph√¢n t√≠ch</span>
        </a>
        <a href="#" class="menu-item" onclick="switchTab('tab-write')">
            <div class="menu-icon">‚úçÔ∏è</div>
            <span>Vi·∫øt truy·ªán</span>
        </a>
        <a href="#" class="menu-item" onclick="switchTab('tab-stories')">
            <div class="menu-icon">üìö</div>
            <span>Th∆∞ vi·ªán</span>
        </a>
        <a href="#" class="menu-item" onclick="switchTab('tab-settings')">
            <div class="menu-icon">‚öôÔ∏è</div>
            <span>C√†i ƒë·∫∑t</span>
        </a>
    </div>

    <script>
        // Google API Configuration
        const CLIENT_ID = '398509518475-7bjid324tkuuh9gv8b0g92lhsgv8nrl5.apps.googleusercontent.com';
        const API_KEY = 'AIzaSyAbcWr0UPvC4YpsunE6uAa7E5pan9iys2o';
        const DISCOVERY_DOC = 'https://www.googleapis.com/discovery/v1/apis/drive/v3/rest';
        const SCOPES = 'https://www.googleapis.com/auth/drive';

        let tokenClient;
        let gapi_inited = false;
        let gsi_inited = false;

        // Global variables
        let analysisData = [];
        let generatedStories = [];
        let scanCache = {};
        const CACHE_FILE_NAME = 'ScanCache_QuanLyTruyen.json';
        const ANALYSIS_CACHE_NAME = 'AnalysisResults_QuanLyTruyen.json';
        const STORY_CACHE_NAME = 'GeneratedStories_QuanLyTruyen.json';

        // Vietnamese language processing data - M·ªü r·ªông cho ph√¢n t√≠ch n√¢ng cao
        const vietnameseStopWords = [
            'l√†', 'c·ªßa', 'v√†', 'c√≥', 'm·ªôt', 'ƒë∆∞·ª£c', 'trong', 'kh√¥ng', 'v·ªõi', 't·ª´', 'ƒë·ªÉ', 'ƒë√£', 's·∫Ω',
            'v·ªÅ', 'cho', 'theo', 'nh∆∞', 'khi', 'v√†o', 'ra', 'l√™n', 'xu·ªëng', 'qua', 't·∫°i', 'hay',
            'r·∫±ng', 'n·∫øu', 'm√†', 'th√¨', 'ho·∫∑c', 'nh∆∞ng', 'v√¨', 'n√™n', 'ƒë·∫øn', 'b·∫±ng', 'tr√™n', 'd∆∞·ªõi'
        ];

        // T·ª´ nh·∫°y c·∫£m cho ph√¢n t√≠ch n√¢ng cao
        const sensitiveWords = {

// ‚ö° L∆∞u √Ω: C√°c t·ª´ kh√≥a 18+ ·ªü tr√™n s·∫Ω ƒë∆∞·ª£c ph√°t hi·ªán trong analyzeSensitiveContent
// Sau ƒë√≥ s·∫Ω ƒë∆∞·ª£c d√πng ƒë·ªÉ b·ªï sung logic v√†o generateSentence() v√† generateParagraph(),
// gi√∫p truy·ªán sinh ra logic, thu·∫ßn Vi·ªát v√† ph√π h·ª£p b·ªëi c·∫£nh (kh√¥ng nh·ªìi nh√©t v√¥ l√Ω).
// H·ªá th·ªëng c√≥ th·ªÉ "h·ªçc l·∫°i" t·ª´ d·ªØ li·ªáu ph√¢n t√≠ch ƒë·ªÉ l·∫ßn sau vi·∫øt t·ªët h∆°n.

            romantic: ['y√™u', 'th∆∞∆°ng', 'h√¥n', '√¥m', '·∫•p √¥m', '√¢m √°p', 'say ƒë·∫Øm', 'ƒëam m√™', 'd·ªãu d√†ng', 'ng·ªçt ng√†o', 'quy·∫øn r≈©', 'm√™ ho·∫∑c', 'th√¢n m·∫≠t', 'g·∫ßn g≈©i'],
            sexual: [
        // Nh·∫π / g·ª£i t√¨nh
        'g·ªëi chƒÉn', 'ph√≤ng the', '√¢n √°i', 'l√†m t√¨nh', 'quan h·ªá', 't√¨nh d·ª•c',
        'd√¢m', 'd·ª•c', 'kho√°i c·∫£m', 'k√≠ch th√≠ch', 'kho·∫£ th√¢n', 'l√µa th·ªÉ',
        's∆∞·ªõng', 'r√™n r·ªâ', 'n·ª©ng', '∆∞·ªõt √°t', 'cao tr√†o', 'c·ª±c kho√°i', 'xu·∫•t tinh',
        'd∆∞∆°ng v·∫≠t', 'c·∫∑c', 'bu·ªìi', 'chim', 'c√°i ·∫•y',
        '√¢m ƒë·∫°o', 'l·ªìn', 'b∆∞·ªõm', '√¢m h·ªô', 'h·ªôt le', 'mu', 'l·ªó', 'xo·∫°c',
        'b√∫ v√∫', 'v√∫ to', 'v√∫ cƒÉng', 'b√∫ m√∫t', 'ng·ª±c tr·∫ßn', 'ng·ª±c kh·ªßng', 'ƒë·∫ßu ti',
        
        // Th√¥ t·ª•c / tr·ª±c ti·∫øp
        'b√∫ l·ªìn', 'b√∫ c·∫∑c', 'li·∫øm l·ªìn', 'li·∫øm bi', 'nu·ªët tinh', 'b√∫ h·ªôt le', 'b√∫ ƒë·∫ßu c·∫∑c',
        't·ª≠ cung', 'b·∫Øn v√†o t·ª≠ cung', 'c·∫∑c d√†i 20cm', 'ng·∫≠m tinh', 'ch·ªãch', 'ƒë·ªãt', 'n·∫Øc',
        'th·ªïi k√®n', 'bj', 'hj', 'anal', 'doggy', '69', 'threesome', 'th·ªß d√¢m',
        'ch∆°i g√°i', 'ƒëƒ©', 'g√°i m·∫°i d√¢m', 'm√¥ng to', 'th·ª•t ra th·ª•t v√†o', 'c·∫Øm s√¢u',
        
        // Bi·∫øn th·ªÉ th∆∞·ªùng g·∫∑p
        's·ªù so·∫°ng', 'm√∫t', 'c·∫Øn', 'xoa', 'vu·ªët ve', 'h√∫p s√≤', 'ph√™', 'nghi·ªán sex',
        'xo·∫°c l·ªìn', 'xo·∫°c c·∫∑c', 'tra t·∫•n t√¨nh d·ª•c', 'h√†nh x√°c', 'ch·ªãu tr·∫≠n',
        'nh√©t', 'ƒë√∫t', 'l√†m nh·ª•c', 'b√≥p v√∫', 't√©t ƒë√≠t', 'v·ªó m√¥ng', 't√∫m t√≥c',
        
        // M·∫°nh b·∫°o
        'b·∫°o d√¢m', 'c∆∞·ª°ng hi·∫øp', 'hi·∫øp d√¢m', 'lo·∫°n lu√¢n', 'th·∫±ng cha', '√¥ng gi√† d√¢m ƒë√£ng',
        'con ƒëƒ©', 'con cave', 'ch·ªã d√¢u', 'em d√¢u', 'anh r·ªÉ', 'ch·ªã g√°i', 'm·∫π ch·ªìng', 'cha con', 'm·∫π con',
        
        // Bi·ªÉu ƒë·∫°t c·ª±c kho√°i
        'r√™n la', 'r√™n r·ªâ', 'h√©t l√™n v√¨ s∆∞·ªõng', 'm·∫Øt l·ªù ƒë·ªù', 'm·ªì h√¥i nh·ªÖ nh·∫°i',
        'b·∫Øn tinh', 'phun tinh', 'tinh d·ªãch', 'tinh tr√†n', 'nu·ªët s·∫°ch tinh',
        'm√πi tanh', 'v·ªã m·∫∑n', '∆∞·ªõt ƒë·∫´m', 'n∆∞·ªõc nh·ªùn', 'd·ªãch nh·ªùn'
    ],
            negative: ['gh√©t', 'h·∫≠n', 'gi·∫≠n', 't·ª©c', 't·ªßi', 'bu·ªìn', 'ƒëau', 'kh·ªï', 's·∫ßu', 'th·∫£m', 'bi', 'tang', 't·ª≠', 'ch·∫øt', 'gi·∫øt', 'h·∫°i', '√°c', 'd·ªØ', 'hung'],
            family: ['b·ªë', 'm·∫π', 'cha', 'con', 'ch·ªìng', 'v·ª£', 'd√¢u', 'r·ªÉ', 'anh', 'ch·ªã', 'em', '√¥ng', 'b√†', 'ch√∫', 'b√°c', 'c√¥', 'd√¨', 'c·∫≠u', 'm·ª£'],
            secret: ['b√≠ m·∫≠t', 'gi·∫•u gi·∫øm', 'che gi·∫•u', 'gi·∫•u di·∫øm', 'l√©n l√∫t', 'v·ª•ng tr·ªôm', '√¢m th·∫ßm', 'l·∫∑ng l·∫Ω', 'k√≠n ƒë√°o', 'ri√™ng t∆∞']
        };

        const emotionalWords = {
            positive: ['vui', 'h·∫°nh ph√∫c', 'y√™u', 'th∆∞∆°ng', 'tuy·ªát v·ªùi', 'ƒë·∫πp', 't·ªët', 'xu·∫•t s·∫Øc', 'th√†nh c√¥ng', 'hy v·ªçng'],
            negative: ['bu·ªìn', 'ƒëau', 'kh·ªï', 't·ªá', 'x·∫•u', 'th·∫•t b·∫°i', 'tuy·ªát v·ªçng', 'gh√©t', 't·ª©c gi·∫≠n', 'lo l·∫Øng', 's·ª£ h√£i', 'kh√≥c', 'tang th∆∞∆°ng', 'b·∫•t h·∫°nh', 'd·ªëi tr√°', 'ph·∫£n b·ªôi', 'l·ª´a d·ªëi', 'x√≥t xa', 'ƒëau ƒë·ªõn', 'x·∫•u h·ªï', 't·ªßi nh·ª•c'],
            neutral: ['b√¨nh th∆∞·ªùng', 'th√¥ng th∆∞·ªùng', 'trung b√¨nh', '·ªïn', 'ƒë∆∞·ª£c', 't·∫°m ·ªïn']
        };

        // T·ª´ kh√≥a ƒë·∫∑c bi·ªát cho ph√¢n t√≠ch h·ªôi tho·∫°i
        const dialogueIndicators = ['n√≥i', 'b·∫£o', 'h·ªèi', 'ƒë√°p', 'th∆∞a', 'k√™u', 'g·ªçi', 'h√©t', 'la', 'th√©t', 'th√¨ th·∫ßm', 'r·ªß r·ªâ', 'l√™n ti·∫øng', 'ph√°t bi·ªÉu', 'tr·∫£ l·ªùi', 'h·ªèi l·∫°i', 'ƒë√°p l·∫°i'];
        const dialoguePunctuation = ['"', "'", ':', ';', '-', '‚Äî', '‚Äì'];

        // Initialize Google APIs
        function gapiLoaded() {
            gapi.load('client', initializeGapiClient);
        }

        async function initializeGapiClient() {
            await gapi.client.init({
                apiKey: API_KEY,
                discoveryDocs: [DISCOVERY_DOC],
            });
            gapi_inited = true;
            maybeEnableButtons();
        }

        function gisLoaded() {
            tokenClient = google.accounts.oauth2.initTokenClient({
                client_id: CLIENT_ID,
                scope: SCOPES,
                callback: '',
            });
            gsi_inited = true;
            maybeEnableButtons();
        }

        function maybeEnableButtons() {
            if (gapi_inited && gsi_inited) {
                document.getElementById('scanBtn').disabled = false;
            }
        }

        // Authentication functions
        function handleAuthClick() {
            tokenClient.callback = async (resp) => {
                if (resp.error !== undefined) {
                    throw (resp);
                }
                await showLoggedInState();
            };

            if (gapi.client.getToken() === null) {
                tokenClient.requestAccessToken({prompt: 'consent'});
            } else {
                tokenClient.requestAccessToken({prompt: ''});
            }
        }

        function handleSignoutClick() {
            const token = gapi.client.getToken();
            if (token !== null) {
                google.accounts.oauth2.revoke(token.access_token);
                gapi.client.setToken('');
                showLoggedOutState();
            }
        }

        async function showLoggedInState() {
            updateStatus('üü¢ ƒê√£ k·∫øt n·ªëi Google Drive');
            
            document.getElementById('scanBtn').disabled = false;
            
            try {
                const response = await gapi.client.request({
    path: 'https://openidconnect.googleapis.com/v1/userinfo'
});
                // C·∫≠p nh·∫≠t th√¥ng tin ng∆∞·ªùi d√πng n·∫øu c·∫ßn
            } catch (error) {
                console.error('Error getting user info:', error);
            }
        }

        function showLoggedOutState() {
            updateStatus('üî¥ Ch∆∞a k·∫øt n·ªëi Google Drive');
            
            const buttons = ['scanBtn', 'analyzeBtn', 'generateBtn'];
            buttons.forEach(id => document.getElementById(id).disabled = true);
        }

        // Tab switching function
        function switchTab(tabId) {
            document.querySelectorAll('.tab-content').forEach(tab => {
                tab.classList.remove('active');
            });
            
            document.getElementById(tabId).classList.add('active');
            
            document.querySelectorAll('.menu-item').forEach(item => {
                item.classList.remove('active');
            });
            
            const menuItems = document.querySelectorAll('.menu-item');
            for (let item of menuItems) {
                if (item.textContent.includes(
                    tabId === 'tab-analysis' ? 'Ph√¢n t√≠ch' :
                    tabId === 'tab-write' ? 'Vi·∫øt truy·ªán' :
                    tabId === 'tab-stories' ? 'Th∆∞ vi·ªán' : 'C√†i ƒë·∫∑t'
                )) {
                    item.classList.add('active');
                    break;
                }
            }
            
            return false;
        }

        // Advanced Analysis Functions
        async function analyzeFiles() {
            if (!window.txtFiles || window.txtFiles.length === 0) {
                alert('Vui l√≤ng qu√©t th∆∞ m·ª•c tr∆∞·ªõc khi ph√¢n t√≠ch!');
                return;
            }
            
            updateStatus('üß† B·∫Øt ƒë·∫ßu ph√¢n t√≠ch n√¢ng cao...');
            analysisData = [];
            
            const skipAnalyzed = document.getElementById('skipAnalyzedFiles').checked;
            let filesToAnalyze = window.txtFiles;
            
            if (skipAnalyzed) {
                try {
                    const response = await gapi.client.drive.files.list({
                        q: `name='${ANALYSIS_CACHE_NAME}' and trashed=false`,
                        fields: 'files(id)'
                    });
                    
                    if (response.result.files.length > 0) {
                        const analysisResponse = await gapi.client.drive.files.get({
                            fileId: response.result.files[0].id,
                            alt: 'media'
                        });
                        
                        const existingAnalysis = JSON.parse(analysisResponse.body);
                        const analyzedFileNames = existingAnalysis.analysisData.map(a => a.fileName);
                        
                        filesToAnalyze = window.txtFiles.filter(file => 
                            !analyzedFileNames.includes(file.name)
                        );
                        
                        if (filesToAnalyze.length === 0) {
                            updateStatus('‚úÖ T·∫•t c·∫£ file ƒë√£ ƒë∆∞·ª£c ph√¢n t√≠ch tr∆∞·ªõc ƒë√≥');
                            analysisData = existingAnalysis.analysisData;
                            displayAdvancedAnalysisResults();
                            document.getElementById('generateBtn').disabled = false;
                            return;
                        }
                        
                        analysisData = existingAnalysis.analysisData;
                        updateStatus(`üîç B·ªè qua ${window.txtFiles.length - filesToAnalyze.length} file ƒë√£ ph√¢n t√≠ch, ti·∫øp t·ª•c v·ªõi ${filesToAnalyze.length} file m·ªõi`);
                    }
                } catch (error) {
                    console.log('No existing analysis found or error loading it, analyzing all files');
                }
            }
            
            const totalFiles = Math.min(filesToAnalyze.length, 50);
            
            for (let i = 0; i < totalFiles; i++) {
                const file = filesToAnalyze[i];
                updateProgress((i / totalFiles) * 100);
                updateStatus(`üß† ƒêang ph√¢n t√≠ch: ${file.name} (${i+1}/${totalFiles})`);
                updateDetailedStatus(`Ph√¢n t√≠ch h·ªôi tho·∫°i v√† t·ª´ nh·∫°y c·∫£m...`);
                
                try {
                    const response = await gapi.client.drive.files.get({
                        fileId: file.id,
                        alt: 'media'
                    });
                    
                    const content = response.body;
                    const analysis = await performAdvancedAnalysis(content, file.name, file.folderPath);
                    analysisData.push(analysis);
                    
                    if (document.getElementById('autoSaveResults').checked) {
                        await autoSaveAnalysis();
                    }
                    
                    await new Promise(resolve => setTimeout(resolve, 500));
                    
                } catch (error) {
                    console.error(`Error analyzing file ${file.name}:`, error);
                    analysisData.push({
                        fileName: file.name,
                        error: error.message
                    });
                }
            }
            
            displayAdvancedAnalysisResults();
            document.getElementById('generateBtn').disabled = false;
            updateProgress(100);
            updateStatus(`‚úÖ Ho√†n th√†nh ph√¢n t√≠ch ${totalFiles} file`);
            updateDetailedStatus('');
            
            setTimeout(() => updateProgress(0), 2000);
        }

        async function performAdvancedAnalysis(content, fileName, folderPath) {
            await new Promise(resolve => setTimeout(resolve, 100));
            
            const analysis = {
                fileName: fileName,
                folderPath: folderPath || 'Unknown',
                timestamp: new Date().toLocaleString('vi-VN'),
                
                // Ph√¢n t√≠ch c∆° b·∫£n
                basicStats: analyzeBasicStats(content),
                
                // Ph√¢n t√≠ch c·∫£m x√∫c
                emotionalAnalysis: analyzeEmotionsAdvanced(content),
                
                // Ph√¢n t√≠ch ch·ªß ƒë·ªÅ
                thematicAnalysis: analyzeThemes(content),
                
                // Ph√¢n t√≠ch nh√¢n v·∫≠t
                characterAnalysis: analyzeCharactersAdvanced(content),
                
                // Ph√¢n t√≠ch h·ªôi tho·∫°i (m·ªõi)
                dialogueAnalysis: analyzeDialogues(content),
                
                // Ph√¢n t√≠ch t·ª´ nh·∫°y c·∫£m (m·ªõi)
                sensitiveAnalysis: analyzeSensitiveContent(content),
                
                // Ph√¢n t√≠ch c·ªët truy·ªán
                narrativeAnalysis: analyzeNarrativeStructure(content),
                
                // M·∫´u n·ªôi dung
                contentSample: content.substring(0, 1000) + (content.length > 1000 ? '...' : '')
            };
            
            return analysis;
        }

        function analyzeBasicStats(content) {
            const sentences = content.split(/[.!?]+/).filter(s => s.trim().length > 0);
            const paragraphs = content.split(/\n\s*\n/).filter(p => p.trim().length > 0);
            const words = content.split(/\s+/).filter(w => w.length > 0);
            const characters = content.length;
            const charactersNoSpaces = content.replace(/\s/g, '').length;
            
            return {
                wordCount: words.length,
                sentenceCount: sentences.length,
                paragraphCount: paragraphs.length,
                characterCount: characters,
                characterCountNoSpaces: charactersNoSpaces,
                avgWordsPerSentence: Math.round(words.length / sentences.length * 10) / 10,
                avgSentencesPerParagraph: Math.round(sentences.length / paragraphs.length * 10) / 10,
                avgWordLength: Math.round(charactersNoSpaces / words.length * 10) / 10
            };
        }

        function analyzeEmotionsAdvanced(content) {
            const emotionAnalysis = {};
            const sentences = content.split(/[.!?]+/).filter(s => s.trim());
            
            Object.entries(emotionalWords).forEach(([category, words]) => {
                const mentions = words.reduce((count, word) => {
                    return count + (content.toLowerCase().match(new RegExp(word, 'g')) || []).length;
                }, 0);
                emotionAnalysis[category] = {
                    count: mentions,
                    percentage: ((mentions / sentences.length) * 100).toFixed(1) + '%'
                };
            });
            
            return {
                overallTone: determineOverallTone(emotionAnalysis),
                emotionBreakdown: emotionAnalysis,
                sentimentScore: calculateSentimentScore(emotionAnalysis)
            };
        }

        function analyzeThemes(content) {
            const themeKeywords = {
                'T√¨nh y√™u': ['y√™u', 'th∆∞∆°ng', 'y√™u th∆∞∆°ng', 't√¨nh c·∫£m', 'l√£ng m·∫°n', 'tim', 'tr√°i tim', 'h√¥n', '√¥m'],
                'Gia ƒë√¨nh': ['gia ƒë√¨nh', 'b·ªë', 'm·∫π', 'con', 'ch·ªìng', 'v·ª£', 'd√¢u', 'r·ªÉ', '√¥ng b√†', 'nh√†'],
                'Ph·∫£n b·ªôi': ['ph·∫£n b·ªôi', 'l·ª´a d·ªëi', 'd·ªëi tr√°', 'l·ª´a l·ªçc', 'l·ª´a g·∫°t', 'ph·∫£n', 'b·ªôi t√≠n'],
                'ƒêau kh·ªï': ['ƒëau', 'kh·ªï', 'ƒëau kh·ªï', 'bu·ªìn', 's·∫ßu', 'th·∫£m', 'bi', 'tang', 'x√≥t', 't·ªßi'],
                'B√≠ m·∫≠t': ['b√≠ m·∫≠t', 'gi·∫•u gi·∫øm', 'che gi·∫•u', 'gi·∫•u di·∫øm', 'l√©n l√∫t', 'v·ª•ng tr·ªôm', '√¢m th·∫ßm']
            };
            
            const themes = [];
            Object.entries(themeKeywords).forEach(([theme, keywords]) => {
                const mentions = keywords.reduce((count, keyword) => {
                    return count + (content.toLowerCase().match(new RegExp(keyword, 'g')) || []).length;
                }, 0);
                if (mentions > 0) {
                    themes.push({
                        theme: theme,
                        mentions: mentions,
                        relevance: mentions
                    });
                }
            });
            
            return {
                mainThemes: themes.sort((a, b) => b.relevance - a.relevance).slice(0, 5),
                thematicComplexity: themes.length > 3 ? 'Ph·ª©c t·∫°p' : 'ƒê∆°n gi·∫£n'
            };
        }

        function analyzeCharactersAdvanced(content) {
            const characters = [];
            const namePattern = /\b[A-Z√Ä-·ª∏][a-z√†-·ªπ]{2,15}(?:\s[A-Z√Ä-·ª∏][a-z√†-·ªπ]{2,15})*\b/g;
            const potentialNames = content.match(namePattern) || [];
            
            const nameCounts = {};
            potentialNames.forEach(name => {
                if (name.length > 2 && name.length < 30) {
                    nameCounts[name] = (nameCounts[name] || 0) + 1;
                }
            });
            
            Object.entries(nameCounts)
                .filter(([name, count]) => count >= 2)
                .sort(([,a], [,b]) => b - a)
                .slice(0, 5)
                .forEach(([name, count]) => {
                    characters.push({
                        name: name,
                        appearances: count,
                        importance: count > 5 ? 'Ch√≠nh' : count > 2 ? 'Ph·ª•' : 'N·ªÅn'
                    });
                });
            
            return {
                characterCount: characters.length,
                characters: characters
            };
        }

        // PH√ÇN T√çCH H·ªòI THO·∫†I M·ªöI
        function analyzeDialogues(content) {
            const dialogues = [];
            const sentences = content.split(/[.!?]+/).filter(s => s.trim());
            
            for (const sentence of sentences) {
                // T√¨m c√°c ch·ªâ b√°o h·ªôi tho·∫°i
                const hasDialogueIndicator = dialogueIndicators.some(indicator => 
                    sentence.toLowerCase().includes(indicator)
                );
                
                // T√¨m c√°c d·∫•u hi·ªáu tr√≠ch d·∫´n
                const hasQuotes = dialoguePunctuation.some(punct => 
                    sentence.includes(punct)
                );
                
                if (hasDialogueIndicator || hasQuotes) {
                    // Tr√≠ch xu·∫•t h·ªôi tho·∫°i ti·ªÅm nƒÉng
                    const potentialDialogue = extractDialogue(sentence);
                    if (potentialDialogue) {
                        dialogues.push({
                            text: potentialDialogue,
                            length: potentialDialogue.length,
                            hasQuotes: hasQuotes,
                            hasIndicator: hasDialogueIndicator
                        });
                    }
                }
            }
            
            return {
                dialogueCount: dialogues.length,
                dialogues: dialogues.slice(0, 10), // Gi·ªõi h·∫°n s·ªë l∆∞·ª£ng
                dialoguePercentage: ((dialogues.length / sentences.length) * 100).toFixed(1) + '%'
            };
        }

        function extractDialogue(sentence) {
            // T√¨m vƒÉn b·∫£n trong ngo·∫∑c k√©p
            const quotedText = sentence.match(/["'](.*?)["']/);
            if (quotedText && quotedText[1].length > 5) {
                return quotedText[1];
            }
            
            // T√¨m vƒÉn b·∫£n sau d·∫•u hai ch·∫•m
            const colonIndex = sentence.indexOf(':');
            if (colonIndex !== -1 && colonIndex < sentence.length - 5) {
                return sentence.substring(colonIndex + 1).trim();
            }
            
            // T√¨m vƒÉn b·∫£n sau c√°c t·ª´ ch·ªâ h·ªôi tho·∫°i
            for (const indicator of dialogueIndicators) {
                const indicatorIndex = sentence.toLowerCase().indexOf(indicator);
                if (indicatorIndex !== -1) {
                    const afterIndicator = sentence.substring(indicatorIndex + indicator.length);
                    if (afterIndicator.length > 5) {
                        // T√¨m ph·∫ßn tr√≠ch d·∫´n trong ƒëo·∫°n sau
                        const nextQuote = afterIndicator.match(/["'](.*?)["']/);
                        if (nextQuote) return nextQuote[1];
                        
                        // Ho·∫∑c tr·∫£ v·ªÅ to√†n b·ªô ph·∫ßn sau
                        return afterIndicator.trim();
                    }
                }
            }
            
            return null;
        }

        // PH√ÇN T√çCH T·ª™ NH·∫†Y C·∫¢M M·ªöI
        function analyzeSensitiveContent(content) {
            const sensitiveResults = {};
            let totalSensitiveWords = 0;
            
            for (const [category, words] of Object.entries(sensitiveWords)) {
                const foundWords = {};
                
                for (const word of words) {
                    const regex = new RegExp(word, 'gi');
                    const matches = content.match(regex);
                    if (matches) {
                        foundWords[word] = matches.length;
                        totalSensitiveWords += matches.length;
                    }
                }
                
                if (Object.keys(foundWords).length > 0) {
                    sensitiveResults[category] = {
                        words: foundWords,
                        count: Object.values(foundWords).reduce((a, b) => a + b, 0)
                    };
                }
            }
            
            return {
                totalSensitiveWords: totalSensitiveWords,
                categories: sensitiveResults,
                sensitivityScore: calculateSensitivityScore(totalSensitiveWords, content.length)
            };
        }

        function calculateSensitivityScore(sensitiveWordCount, totalCharacters) {
            if (totalCharacters === 0) return 0;
            const ratio = (sensitiveWordCount / (totalCharacters / 1000)); // S·ªë t·ª´ nh·∫°y c·∫£m tr√™n 1000 k√Ω t·ª±
            return Math.min(10, Math.round(ratio * 10) / 10); // Tr·∫£ v·ªÅ ƒëi·ªÉm t·ª´ 0-10
        }

        function analyzeNarrativeStructure(content) {
            const paragraphs = content.split(/\n\s*\n/).filter(p => p.trim());
            const totalLength = content.split(/\s+/).length;
            
            return {
                structure: analyzeThreeActStructure(paragraphs, totalLength),
                pacing: analyzePacing(paragraphs),
                climax: identifyClimax(content)
            };
        }

        function analyzeThreeActStructure(paragraphs, totalLength) {
            const act1End = Math.floor(paragraphs.length * 0.25);
            const act2End = Math.floor(paragraphs.length * 0.75);
            
            return {
                act1: {
                    paragraphs: act1End,
                    percentage: '25%',
                    description: 'M·ªü ƒë·∫ßu, gi·ªõi thi·ªáu'
                },
                act2: {
                    paragraphs: act2End - act1End,
                    percentage: '50%',
                    description: 'Ph√°t tri·ªÉn, xung ƒë·ªôt'
                },
                act3: {
                    paragraphs: paragraphs.length - act2End,
                    percentage: '25%',
                    description: 'Cao tr√†o, k·∫øt th√∫c'
                }
            };
        }

        function analyzePacing(paragraphs) {
            const avgParagraphLength = paragraphs.reduce((sum, p) => sum + p.split(/\s+/).length, 0) / paragraphs.length;
            
            return {
                averageParagraphLength: Math.round(avgParagraphLength),
                pacing: avgParagraphLength > 100 ? 'Ch·∫≠m' : avgParagraphLength > 50 ? 'V·ª´a ph·∫£i' : 'Nhanh'
            };
        }

        function identifyClimax(content) {
            const climaxIndicators = ['ƒë·ªôt nhi√™n', 'b·∫•t ng·ªù', 'l√∫c n√†y', 'cu·ªëi c√πng', 'quy·∫øt ƒë·ªãnh', 'quan tr·ªçng nh·∫•t'];
            const sentences = content.split(/[.!?]+/);
            
            let climaxSentence = '';
            let maxIndicators = 0;
            
            sentences.forEach(sentence => {
                const indicatorCount = climaxIndicators.reduce((count, indicator) => {
                    return count + (sentence.toLowerCase().includes(indicator) ? 1 : 0);
                }, 0);
                
                if (indicatorCount > maxIndicators && sentence.trim().length > 20) {
                    maxIndicators = indicatorCount;
                    climaxSentence = sentence.trim();
                }
            });
            
            return {
                identified: climaxSentence.length > 0,
                sentence: climaxSentence.substring(0, 200) + (climaxSentence.length > 200 ? '...' : ''),
                indicators: maxIndicators
            };
        }

        function determineOverallTone(emotionAnalysis) {
            const positive = emotionAnalysis.positive?.count || 0;
            const negative = emotionAnalysis.negative?.count || 0;
            const neutral = emotionAnalysis.neutral?.count || 0;
            
            if (positive > negative && positive > neutral) return 'T√≠ch c·ª±c';
            if (negative > positive && negative > neutral) return 'Ti√™u c·ª±c';
            return 'Trung t√≠nh';
        }

        function calculateSentimentScore(emotionAnalysis) {
            const positive = emotionAnalysis.positive?.count || 0;
            const negative = emotionAnalysis.negative?.count || 0;
            const total = positive + negative;
            
            if (total === 0) return 0;
            return ((positive - negative) / total * 100).toFixed(1);
        }

        // Story Generation Functions - N√¢ng cao v·ªõi d·ªØ li·ªáu ph√¢n t√≠ch
        async function generateStories() {
            if (analysisData.length === 0) {
                alert('Vui l√≤ng ph√¢n t√≠ch file tr∆∞·ªõc khi t·∫°o truy·ªán!');
                return;
            }
            
            updateWriteStatus('‚úçÔ∏è B·∫Øt ƒë·∫ßu vi·∫øt truy·ªán...', 'Chu·∫©n b·ªã d·ªØ li·ªáu v√† √Ω t∆∞·ªüng');
            updateWriteProgress(5);
            
            try {
                const minChapters = parseInt(document.getElementById('minChapters').value) || 50;
                const sensitivityLevel = parseInt(document.getElementById('sensitivityLevel').value) || 5;
                
                const storyTitle = generateStoryTitle(analysisData);
                updateWriteStatus(`üìñ ƒêang vi·∫øt: "${storyTitle}"`, `K·∫ø ho·∫°ch ${minChapters} ch∆∞∆°ng`);
                updateWriteProgress(10);
                
                const mainPlot = generateMainPlot(analysisData);
                
                const chapters = [];
                for (let i = 1; i <= minChapters; i++) {
                    updateWriteProgress(10 + (i / minChapters) * 80);
                    updateWriteStatus(`üìñ ƒêang vi·∫øt ch∆∞∆°ng ${i}/${minChapters}`, `"${storyTitle}"`);
                    
                    const chapterTitle = generateChapterTitle(i, mainPlot, analysisData);
                    const chapterContent = generateChapterContent(i, chapterTitle, mainPlot, analysisData, sensitivityLevel);
                    
                    chapters.push({
                        number: i,
                        title: chapterTitle,
                        content: chapterContent,
                        wordCount: chapterContent.split(/\s+/).length
                    });
                    
                    if (document.getElementById('autoSaveResults').checked && i % 5 === 0) {
                        await autoSaveStory({
                            title: storyTitle,
                            chapters: chapters,
                            generatedAt: new Date().toISOString(),
                            basedOnAnalysis: analysisData.length
                        });
                    }
                    
                    if (i === 1 || i % 10 === 0 || i === minChapters) {
                        displayLatestChapter(storyTitle, chapters[chapters.length - 1]);
                    }
                    
                    await new Promise(resolve => setTimeout(resolve, 100));
                }
                
                const generatedStory = {
                    title: storyTitle,
                    chapters: chapters,
                    generatedAt: new Date().toISOString(),
                    basedOnAnalysis: analysisData.length,
                    totalWords: chapters.reduce((sum, ch) => sum + ch.wordCount, 0)
                };
                
                generatedStories.push(generatedStory);
                
                displayGeneratedStories();
                
                updateWriteProgress(95);
                updateWriteStatus(`‚úÖ ƒê√£ ho√†n th√†nh: "${storyTitle}"`, `${minChapters} ch∆∞∆°ng, ${generatedStory.totalWords} t·ª´`);
                
                updateWriteProgress(100);
                
                setTimeout(() => updateWriteProgress(0), 2000);
                
            } catch (error) {
                console.error('Error generating stories:', error);
                updateWriteStatus(`‚ùå L·ªói khi vi·∫øt truy·ªán: ${error.message}`, '');
                updateWriteProgress(0);
            }
        }

        function generateStoryTitle(analysisData) {
            const titleTemplates = [
                `B√≥ng T·ªëi Trong Gia ƒê√¨nh`,
                `M·ªëi T√¨nh Oan Nghi·ªát`,
                `S·ª± Th·∫≠t ƒêau L√≤ng Sau C√°nh C·ª≠a`,
                `Ng∆∞·ªùi Cha V√† Con D√¢u`,
                `M·∫•t M√°t Trong Im L·∫∑ng`,
                `Tr√°i Tim Ng∆∞·ªùi Ch·ªìng`,
                `M·ªëi T√¨nh C·∫•m ƒêo√°n`,
                `Nh·ªØng Gi·∫•u Gi·∫øm ƒêau ƒê·ªõn`,
                `S·ª± Ph·∫£n B·ªôi Th·∫ßm L·∫∑ng`,
                `Gia ƒê√¨nh Kh√¥ng Tr·ªçn V·∫πn`
            ];
            
            return titleTemplates[Math.floor(Math.random() * titleTemplates.length)];
        }

        function generateMainPlot(analysisData) {
            const emotionalTone = determineOverallEmotionalToneFromAnalysis(analysisData);
            const commonThemes = findCommonThemes(analysisData);
            const commonCharacters = findCommonCharacters(analysisData);
            
            return {
                themes: commonThemes.slice(0, 3),
                mainCharacters: commonCharacters.slice(0, 2),
                emotionalTone: emotionalTone,
                conflict: {
                    type: 't√¨nh c·∫£m gia ƒë√¨nh',
                    intensity: 'cao',
                    resolution: 'kh√¥ng tr·ªçn v·∫πn'
                },
                sensitivity: calculateAverageSensitivity(analysisData)
            };
        }

        function determineOverallEmotionalToneFromAnalysis(analysisData) {
            let positive = 0, negative = 0, neutral = 0;
            
            analysisData.forEach(analysis => {
                if (analysis.emotionalAnalysis) {
                    positive += analysis.emotionalAnalysis.emotionBreakdown.positive?.count || 0;
                    negative += analysis.emotionalAnalysis.emotionBreakdown.negative?.count || 0;
                    neutral += analysis.emotionalAnalysis.emotionBreakdown.neutral?.count || 0;
                }
            });
            
            if (negative > positive && negative > neutral) return 'negative';
            if (positive > negative && positive > neutral) return 'positive';
            return 'neutral';
        }

        function findCommonThemes(analysisData) {
            const allThemes = {};
            analysisData.forEach(analysis => {
                if (analysis.thematicAnalysis && analysis.thematicAnalysis.mainThemes) {
                    analysis.thematicAnalysis.mainThemes.forEach(theme => {
                        allThemes[theme.theme] = (allThemes[theme.theme] || 0) + 1;
                    });
                }
            });
            
            return Object.entries(allThemes)
                .sort(([,a], [,b]) => b - a)
                .map(([theme]) => theme);
        }

        function findCommonCharacters(analysisData) {
            const allCharacters = {};
            analysisData.forEach(analysis => {
                if (analysis.characterAnalysis && analysis.characterAnalysis.characters) {
                    analysis.characterAnalysis.characters.forEach(character => {
                        allCharacters[character.name] = (allCharacters[character.name] || 0) + 1;
                    });
                }
            });
            
            return Object.entries(allCharacters)
                .sort(([,a], [,b]) => b - a)
                .map(([character]) => character);
        }

        function calculateAverageSensitivity(analysisData) {
            let totalSensitivity = 0;
            let count = 0;
            
            analysisData.forEach(analysis => {
                if (analysis.sensitiveAnalysis) {
                    totalSensitivity += analysis.sensitiveAnalysis.sensitivityScore || 0;
                    count++;
                }
            });
            
            return count > 0 ? totalSensitivity / count : 0;
        }

        function generateChapterTitle(chapterNumber, mainPlot, analysisData) {
            const chapterTemplates = [
                `Kh√∫c D·∫°o ƒê·∫ßu Bu·ªìn`,
                `Nh·ªØng Nghi Ng·ªù ƒê·∫ßu Ti√™n`,
                `D·∫•u Hi·ªáu C·ªßa S·ª± D·ªëi Tr√°`,
                `Cu·ªôc Ch·∫°m Tr√°n B·∫•t Ng·ªù`,
                `S·ª± Th·∫≠t Ph≈© Ph√†ng`,
                `N·ªói ƒêau Kh√¥ng Th·ªÉ N√≥i Th√†nh L·ªùi`,
                `L·ª±a Ch·ªçn Kh√≥ KhƒÉn`,
                `S·ªëng Trong D·ªëi Tr√°`,
                `Kho·∫£nh Kh·∫Øc Y·∫øu L√≤ng`,
                `Im L·∫∑ng L√† V√†ng`,
                `Tr√°i Tim Tan V·ª°`,
                `Ng√†y Th√°ng D√†i ƒê·∫±ng ƒê·∫µng`,
                `Quy·∫øt ƒê·ªãnh Cu·ªëi C√πng`,
                `L·ªùi T·ª´ Bi·ªát Kh√¥ng L·ªùi`,
                `B√¨nh Minh C√¥ ƒê∆°n`
            ];
            
            const templateIndex = chapterNumber % chapterTemplates.length;
            return `Ch∆∞∆°ng ${chapterNumber}: ${chapterTemplates[templateIndex]}`;
        }

        function generateChapterContent(chapterNumber, chapterTitle, mainPlot, analysisData, sensitivityLevel) {
            let content = `# ${chapterTitle}\n\n`;
            
            const paragraphs = 8 + Math.floor(Math.random() * 6);
            
            for (let i = 0; i < paragraphs; i++) {
                content += generateParagraph(chapterNumber, i, paragraphs, mainPlot, analysisData, sensitivityLevel) + '\n\n';
            }
            
            return content;
        }

        function generateParagraph(chapterNumber, paragraphIndex, totalParagraphs, mainPlot, analysisData, sensitivityLevel) {
            const sentences = 3 + Math.floor(Math.random() * 3);
            let paragraph = '';
            
            for (let i = 0; i < sentences; i++) {
                paragraph += generateSentence(chapterNumber, paragraphIndex, totalParagraphs, i, sentences, mainPlot, analysisData, sensitivityLevel);
                if (i < sentences - 1) paragraph += ' ';
            }
            
            return paragraph;
        }

        function generateSentence(chapterNumber, paragraphIndex, totalParagraphs, sentenceIndex, totalSentences, mainPlot, analysisData, sensitivityLevel) {
            // L·∫•y c√°c t·ª´ nh·∫°y c·∫£m t·ª´ ph√¢n t√≠ch
            const sensitiveWordsList = extractSensitiveWordsFromAnalysis(analysisData);
            
            // M·∫´u c√¢u c∆° b·∫£n
            const sentenceTemplates = [
                `T√¥i nh√¨n th·∫•y ${mainPlot.mainCharacters[0] || 'b·ªë'} v√† ${mainPlot.mainCharacters[1] || 'v·ª£ t√¥i'} trao ƒë·ªïi √°nh m·∫Øt m√† kh√¥ng d√°m l√™n ti·∫øng.`,
                `Tr√°i tim t√¥i ƒëau nh√≥i khi ch·ª©ng ki·∫øn c·∫£nh t∆∞·ª£ng ƒë√≥ nh∆∞ng kh√¥ng th·ªÉ l√†m g√¨.`,
                `M·ªói l·∫ßn th·∫•y h·ªç g·∫ßn nhau, l√≤ng t√¥i l·∫°i qu·∫∑n th·∫Øt v√¨ ghen tu√¥ng v√† t·ªßi nh·ª•c.`,
                `T√¥i t·ª± h·ªèi m√¨nh ƒë√£ l√†m g√¨ sai ƒë·ªÉ ph·∫£i ch·ªãu ƒë·ª±ng s·ª± ph·∫£n b·ªôi n√†y.`,
                `ƒê√™m nay l·∫°i m·ªôt ƒë√™m d√†i tr·∫±n tr·ªçc v·ªõi nh·ªØng suy nghƒ© mi√™n man.`,
                `T√¥i mu·ªën h√©t l√™n cho c·∫£ th·∫ø gi·ªõi bi·∫øt s·ª± th·∫≠t, nh∆∞ng l·∫°i im l·∫∑ng.`,
                `Gia ƒë√¨nh - hai ti·∫øng ·∫•y gi·ªù ƒë√¢y tr·ªü n√™n th·∫≠t xa l·∫° v√† gi·∫£ d·ªëi.`,
                `T√¥i th·∫•y m√¨nh th·∫≠t b·∫•t l·ª±c, kh√¥ng d√°m ƒë·ªëi m·∫∑t v·ªõi s·ª± th·∫≠t ph≈© ph√†ng.`,
                `N·ª• c∆∞·ªùi c·ªßa v·ª£ t√¥i v·ªõi b·ªë t√¥i sao c√≥ th·ªÉ t∆∞∆°i ƒë·∫øn th·∫ø, c√≤n v·ªõi t√¥i th√¨ kh√¥ng?`,
                `T√¥i t·ª± d·∫±n v·∫∑t b·∫£n th√¢n, c√≥ ph·∫£i m√¨nh ƒë√£ qu√° v√¥ t√¢m v·ªõi v·ª£?`,
                `Nh∆∞ng kh√¥ng, t√¥i bi·∫øt r√µ ai l√† ng∆∞·ªùi c√≥ l·ªói trong chuy·ªán n√†y.`,
                `Im l·∫∑ng c√≥ ph·∫£i l√† v√†ng? Hay t√¥i ch·ªâ ƒëang h√®n nh√°t kh√¥ng d√°m ƒë·ªëi di·ªán?`,
                `M·ªói ng√†y tr√¥i qua l√† m·ªôt ng√†y t√¥i ph·∫£i di·ªÖn nh·ªØng v·ªü k·ªãch kh√¥ng c√≥ h·ªìi k·∫øt.`,
                `T√¥i mu·ªën tr·ªën ch·∫°y kh·ªèi t·∫•t c·∫£, nh∆∞ng kh√¥ng bi·∫øt ph·∫£i ƒëi ƒë√¢u.`,
                `Li·ªáu c√≥ ai hi·ªÉu ƒë∆∞·ª£c n·ªói l√≤ng c·ªßa m·ªôt ng∆∞·ªùi ch·ªìng trong ho√†n c·∫£nh c·ªßa t√¥i?`
            ];
            
            // Ch·ªçn m·∫´u
            const templateIndex = (chapterNumber + paragraphIndex + sentenceIndex) % sentenceTemplates.length;
            let sentence = sentenceTemplates[templateIndex];
            
            // Th√™m t·ª´ nh·∫°y c·∫£m n·∫øu c√≥ v√† n·∫øu ƒë·ªô nh·∫°y c·∫£m ƒë·ªß cao
if (sensitiveWordsList.length > 0 && sensitivityLevel >= 7) {
    const sensitiveWord = sensitiveWordsList[Math.floor(Math.random() * sensitiveWordsList.length)];
    sentence = sentence.replace('.', ` ${sensitiveWord}.`);
}

const shouldAddSensitive = Math.random() < (sensitivityLevel / 10);
if (shouldAddSensitive) {
    const sensitiveWord = sensitiveWordsList[Math.floor(Math.random() * sensitiveWordsList.length)];
    sentence = sentence.replace('.', ` ${sensitiveWord}.`);
}
            
            // Th√™m h·ªôi tho·∫°i n·∫øu c√≥
            if (analysisData.some(a => a.dialogueAnalysis && a.dialogueAnalysis.dialogueCount > 0)) {
                const shouldAddDialogue = Math.random() < 0.3;
                if (shouldAddDialogue) {
                    const dialogueTemplate = [
                        `B·ªóng t√¥i nghe th·∫•y gi·ªçng n√≥i: "Sao em c√≥ th·ªÉ l√†m v·∫≠y v·ªõi anh?"`,
                        `T√¥i kh√¥ng th·ªÉ qu√™n ƒë∆∞·ª£c c√¢u n√≥i: "Chuy·ªán n√†y ƒë·ª´ng ƒë·ªÉ ai bi·∫øt."`,
                        `Gi·ªçng n√≥i th√¨ th·∫ßm: "Anh y√™u em, nh∆∞ng kh√¥ng th·ªÉ ti·∫øp t·ª•c ƒë∆∞·ª£c."`,
                        `T√¥i nghe r√µ m·ªìn m·ªôt: "ƒê√¢y l√† l·∫ßn cu·ªëi c√πng, t√¥i h·ª©a."`
                    ];
                    const dialogue = dialogueTemplate[Math.floor(Math.random() * dialogueTemplate.length)];
                    sentence += ' ' + dialogue;
                }
            }
            
            return sentence;
        }

        function extractSensitiveWordsFromAnalysis(analysisData) {
            const words = [];
            
            analysisData.forEach(analysis => {
                if (analysis.sensitiveAnalysis && analysis.sensitiveAnalysis.categories) {
                    for (const category of Object.values(analysis.sensitiveAnalysis.categories)) {
                        for (const word of Object.keys(category.words)) {
                            if (!words.includes(word)) {
                                words.push(word);
                            }
                        }
                    }
                }
            });
            
            return words;
        }

        // UI Update Functions
        function updateStatus(message) {
            document.getElementById('statusInfo').innerHTML = `<p>${message}</p>`;
        }

        function updateDetailedStatus(message) {
            document.getElementById('detailedStatus').textContent = message;
        }

        function updateProgress(percent) {
            document.getElementById('progressBar').style.width = percent + '%';
        }

        function updateWriteStatus(message, detail) {
            document.getElementById('writeStatus').textContent = message;
            document.getElementById('writeDetailedStatus').textContent = detail;
        }

        function updateWriteProgress(percent) {
            document.getElementById('writeProgressBar').style.width = percent + '%';
        }

        function displayAdvancedAnalysisResults() {
            const container = document.getElementById('analysisResults');
            container.innerHTML = '';
            
            if (analysisData.length === 0) {
                container.innerHTML = '<p>Ch∆∞a c√≥ d·ªØ li·ªáu ph√¢n t√≠ch.</p>';
                return;
            }
            
            // Ph√¢n t√≠ch t·ªïng quan
            let emotionalScore = 0;
            let themeCount = 0;
            let dialogueCount = 0;
            let sensitiveWordCount = 0;
            
            analysisData.forEach(analysis => {
                if (analysis.emotionalAnalysis) {
                    emotionalScore += parseFloat(analysis.emotionalAnalysis.sentimentScore) || 0;
                }
                if (analysis.thematicAnalysis) {
                    themeCount += analysis.thematicAnalysis.mainThemes.length;
                }
                if (analysis.dialogueAnalysis) {
                    dialogueCount += analysis.dialogueAnalysis.dialogueCount || 0;
                }
                if (analysis.sensitiveAnalysis) {
                    sensitiveWordCount += analysis.sensitiveAnalysis.totalSensitiveWords || 0;
                }
            });
            
            emotionalScore = (emotionalScore / analysisData.length).toFixed(1);
            
            container.innerHTML = `
                <div class="status-info">
                    <p>üìä T·ªïng quan ph√¢n t√≠ch</p>
                    <p>ƒêi·ªÉm c·∫£m x√∫c: ${emotionalScore}%</p>
                    <p>S·ªë ch·ªß ƒë·ªÅ ph√°t hi·ªán: ${themeCount}</p>
                    <p>H·ªôi tho·∫°i ph√°t hi·ªán: ${dialogueCount}</p>
                    <p>T·ª´ nh·∫°y c·∫£m: ${sensitiveWordCount}</p>
                    <p>S·ªë file ƒë√£ ph√¢n t√≠ch: ${analysisData.length}</p>
                </div>
            `;
            
            // Hi·ªÉn th·ªã c√°c c·∫£m x√∫c ch√≠nh
            const emotionalThemes = analysisData.flatMap(a => 
                a.emotionalAnalysis ? [a.emotionalAnalysis.overallTone] : []
            );
            
            const emotionalCounts = emotionalThemes.reduce((acc, tone) => {
                acc[tone] = (acc[tone] || 0) + 1;
                return acc;
            }, {});
            
            let emotionalHTML = '<p>C·∫£m x√∫c ch·ªß ƒë·∫°o:</p>';
            for (const [tone, count] of Object.entries(emotionalCounts)) {
                emotionalHTML += `<span class="emotion-tag">${tone} (${count})</span>`;
            }
            
            container.innerHTML += emotionalHTML;
            
            // Hi·ªÉn th·ªã t·ª´ nh·∫°y c·∫£m
            const sensitiveWords = extractSensitiveWordsFromAnalysis(analysisData);
            if (sensitiveWords.length > 0) {
                container.innerHTML += `<p>T·ª´ nh·∫°y c·∫£m ph√°t hi·ªán: ${sensitiveWords.slice(0, 10).join(', ')}${sensitiveWords.length > 10 ? '...' : ''}</p>`;
            }
            
            // Hi·ªÉn th·ªã m·∫´u h·ªôi tho·∫°i
            const sampleDialogues = [];
            analysisData.forEach(analysis => {
                if (analysis.dialogueAnalysis && analysis.dialogueAnalysis.dialogues) {
                    analysis.dialogueAnalysis.dialogues.forEach(dialogue => {
                        if (sampleDialogues.length < 3) {
                            sampleDialogues.push(dialogue.text);
                        }
                    });
                }
            });
            
            if (sampleDialogues.length > 0) {
                container.innerHTML += `<p>M·∫´u h·ªôi tho·∫°i:</p>`;
                sampleDialogues.forEach(dialogue => {
                    container.innerHTML += `<div class="dialogue">"${dialogue}"</div>`;
                });
            }
        }

        function displayLatestChapter(storyTitle, chapter) {
            const container = document.getElementById('generatedStories');
            container.innerHTML = `
                <div class="story-content">
                    <div class="chapter-title">${storyTitle} - ${chapter.title}</div>
                    <div>${chapter.content.substring(0, 300)}...</div>
                    <p><i>${chapter.wordCount} t·ª´</i></p>
                </div>
            `;
        }

        function displayGeneratedStories() {
            const container = document.getElementById('generatedStories');
            
            if (generatedStories.length === 0) {
                container.innerHTML = '<p>Ch∆∞a c√≥ truy·ªán n√†o ƒë∆∞·ª£c t·∫°o.</p>';
                return;
            }
            
            const story = generatedStories[generatedStories.length - 1];
            const latestChapter = story.chapters[story.chapters.length - 1];
            
            container.innerHTML = `
                <div class="story-content">
                    <div class="chapter-title">${story.title} - ${latestChapter.title}</div>
                    <div>${latestChapter.content.substring(0, 500)}...</div>
                    <p><i>Ch∆∞∆°ng ${story.chapters.length}/${story.chapters.length} ‚Ä¢ ${story.totalWords} t·ª´</i></p>
                </div>
                <button class="btn btn-success" onclick="saveToGoogleDrive()">
                    üíæ L∆∞u truy·ªán
                </button>
            `;
        }

        // C√°c h√†m utility kh√°c
        async function scanFolder() {
            updateStatus('üîç ƒêang qu√©t th∆∞ m·ª•c QuanLyTruyen...');
            updateDetailedStatus('ƒêang t√¨m ki·∫øm t·∫•t c·∫£ file .txt trong th∆∞ m·ª•c v√† th∆∞ m·ª•c con...');

            try {
                const response = await gapi.client.drive.files.list({
                    q: "name contains 'QuanLyTruyen' and mimeType = 'application/vnd.google-apps.folder' and trashed=false",
                    fields: 'files(id, name)'
                });

                if (response.result.files.length === 0) {
                    updateStatus('‚ùå Kh√¥ng t√¨m th·∫•y th∆∞ m·ª•c "QuanLyTruyen" trong Google Drive');
                    return;
                }

                const rootFolderId = response.result.files[0].id;
                window.txtFiles = [];

                async function listFilesInFolder(folderId, folderPath = '') {
                    const res = await gapi.client.drive.files.list({
                        q: `'${folderId}' in parents and trashed=false`,
                        fields: 'files(id, name, mimeType)'
                    });

                    for (const file of res.result.files) {
                        if (file.mimeType === 'application/vnd.google-apps.folder') {
                            await listFilesInFolder(file.id, folderPath + '/' + file.name);
                        } else if (file.name.endsWith('.txt')) {
                            window.txtFiles.push({
                                id: file.id,
                                name: file.name,
                                folderPath: folderPath
                            });
                        }
                    }
                }

                await listFilesInFolder(rootFolderId, 'QuanLyTruyen');

                if (window.txtFiles.length === 0) {
                    updateStatus('‚ö†Ô∏è Kh√¥ng t√¨m th·∫•y file .txt n√†o trong th∆∞ m·ª•c');
                } else {
                    updateStatus(`‚úÖ ƒê√£ qu√©t ${window.txtFiles.length} file .txt`);
                    document.getElementById('analyzeBtn').disabled = false;

                    // L∆∞u cache
                    if (document.getElementById('autoSaveResults').checked) {
                        await gapi.client.request({
                            path: '/upload/drive/v3/files',
                            method: 'POST',
                            params: { uploadType: 'media' },
                            body: JSON.stringify({ txtFiles: window.txtFiles }),
                            headers: { 'Content-Type': 'application/json' }
                        });
                    }
                }

            } catch (error) {
                console.error('Error scanning folder:', error);
                updateStatus('‚ùå L·ªói khi qu√©t th∆∞ m·ª•c: ' + error.message);
            }
        }

        async function saveToGoogleDrive() {
            updateWriteStatus('üíæ ƒêang l∆∞u truy·ªán...', '');
            // Tri·ªÉn khai l∆∞u truy·ªán
        }

        async function autoSaveAnalysis() {
            try {
                // Ki·ªÉm tra file ph√¢n t√≠ch ƒë√£ t·ªìn t·∫°i tr√™n Drive ch∆∞a
                const response = await gapi.client.drive.files.list({
                    q: `name='${ANALYSIS_CACHE_NAME}' and trashed=false`,
                    fields: 'files(id, name)'
                });

                let fileId;
                if (response.result.files.length > 0) {
                    fileId = response.result.files[0].id;
                    // C·∫≠p nh·∫≠t file c≈©
                    await gapi.client.request({
                        path: `/upload/drive/v3/files/${fileId}`,
                        method: 'PATCH',
                        params: { uploadType: 'media' },
                        body: JSON.stringify({ analysisData }),
                        headers: { 'Content-Type': 'application/json' }
                    });
                } else {
                    // T·∫°o file m·ªõi
                    const createResponse = await gapi.client.request({
                        path: '/upload/drive/v3/files',
                        method: 'POST',
                        params: { uploadType: 'media' },
                        body: JSON.stringify({ analysisData }),
                        headers: { 'Content-Type': 'application/json' }
                    });
                    fileId = createResponse.result.id;
                }

                console.log('‚úÖ Analysis auto-saved to Google Drive:', fileId);
            } catch (error) {
                console.error('‚ùå Error auto-saving analysis:', error);
            }
        }

        async function autoSaveStory(story) {
            try {
                // Ki·ªÉm tra file truy·ªán ƒë√£ t·ªìn t·∫°i ch∆∞a
                const response = await gapi.client.drive.files.list({
                    q: `name='${STORY_CACHE_NAME}' and trashed=false`,
                    fields: 'files(id, name)'
                });

                let fileId;
                if (response.result.files.length > 0) {
                    fileId = response.result.files[0].id;
                    await gapi.client.request({
                        path: `/upload/drive/v3/files/${fileId}`,
                        method: 'PATCH',
                        params: { uploadType: 'media' },
                        body: JSON.stringify(story),
                        headers: { 'Content-Type': 'application/json' }
                    });
                } else {
                    const createResponse = await gapi.client.request({
                        path: '/upload/drive/v3/files',
                        method: 'POST',
                        params: { uploadType: 'media' },
                        body: JSON.stringify(story),
                        headers: { 'Content-Type': 'application/json' }
                    });
                    fileId = createResponse.result.id;
                }

                console.log('‚úÖ Story auto-saved to Google Drive:', fileId);
            } catch (error) {
                console.error('‚ùå Error auto-saving story:', error);
            }
        }

        async function clearCache() {
            if (confirm('B·∫°n c√≥ ch·∫Øc ch·∫Øn mu·ªën x√≥a d·ªØ li·ªáu t·∫°m?')) {
                updateStatus('üóëÔ∏è ƒêang x√≥a d·ªØ li·ªáu t·∫°m...');
                // Tri·ªÉn khai x√≥a cache
            }
        }

        async function loadStories() {
            updateStatus('üìö ƒêang t·∫£i danh s√°ch truy·ªán...');
            // Tri·ªÉn khai t·∫£i truy·ªán
        }

        // Initialize when page loads
        window.onload = function() {
            if (typeof gapi !== 'undefined') {
                gapiLoaded();
            }
            if (typeof google !== 'undefined') {
                gisLoaded();
            }
            
            updateStatus('üî¥ Ch∆∞a k·∫øt n·ªëi Google Drive');
            
            // C·∫≠p nh·∫≠t gi√° tr·ªã ƒë·ªô nh·∫°y c·∫£m
            document.getElementById('sensitivityLevel').addEventListener('input', function() {
                document.getElementById('sensitivityValue').textContent = this.value;
            });
        };
    </script>
</body>
</html>
