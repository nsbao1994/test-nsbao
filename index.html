<!DOCTYPE html>
<html lang="vi">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, viewport-fit=cover">
    <title>Tr√¨nh Ph√¢n T√≠ch & T·∫°o Truy·ªán N√¢ng Cao</title>
    <script src="https://apis.google.com/js/api.js"></script>
    <script src="https://accounts.google.com/gsi/client"></script>
    <style>
        :root {
           --primary-color: #9b59b6;
    --secondary-color: #2980b9;
    --dark-color: #1e1e1e;
    --light-color: #bdc3c7;
    --accent-color: #e74c3c;
    --success-color: #2ecc71;
    --warning-color: #f39c12;
    --text-color: #ecf0f1;
    --card-bg: rgba(30, 30, 30, 0.95);
    --border-radius: 16px;
    --shadow: 0 4px 20px rgba(0, 0, 0, 0.6);
            --safe-area-inset-top: env(safe-area-inset-top);
            --safe-area-inset-bottom: env(safe-area-inset-bottom);
            --safe-area-inset-left: env(safe-area-inset-left);
            --safe-area-inset-right: env(safe-area-inset-right);
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            -webkit-tap-highlight-color: transparent;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Helvetica, Arial, sans-serif;
    background: #121212;   /* n·ªÅn ƒëen thu·∫ßn */
    min-height: 100vh;
    color: var(--text-color);
    padding: var(--safe-area-inset-top) var(--safe-area-inset-right) var(--safe-area-inset-bottom) var(--safe-area-inset-left);
    line-height: 1.6;
        }

        .container {
            max-width: 100%;
            margin: 0 auto;
            padding: 16px;
            padding-bottom: 80px;
        }

        .header {
            text-align: center;
            margin-bottom: 20px;
            color: white;
            padding-top: 12px;
        }

        .header h1 {
            font-size: 1.8rem;
            margin-bottom: 8px;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.3);
            font-weight: 700;
        }

        .header p {
            font-size: 1rem;
            opacity: 0.9;
            font-weight: 400;
        }

        .card {
            background: var(--card-bg);
            border-radius: var(--border-radius);
            padding: 20px;
            margin-bottom: 20px;
            box-shadow: var(--shadow);
            backdrop-filter: blur(10px);
        }

        .bottom-menu {
            position: fixed;
            bottom: 0;
            left: 0;
            right: 0;
            background: rgba(44, 62, 80, 0.95);
            backdrop-filter: blur(10px);
            padding: 12px 16px;
            padding-bottom: calc(16px + var(--safe-area-inset-bottom));
            display: flex;
            justify-content: space-around;
            border-top: 1px solid rgba(255, 255, 255, 0.1);
            z-index: 1000;
        }

        .menu-item {
            display: flex;
            flex-direction: column;
            align-items: center;
            color: var(--light-color);
            text-decoration: none;
            font-size: 0.8rem;
            opacity: 0.7;
            transition: opacity 0.3s;
        }

        .menu-item.active {
            opacity: 1;
        }

        .menu-icon {
            font-size: 1.4rem;
            margin-bottom: 4px;
        }

        .tab-content {
            display: none;
        }

        .tab-content.active {
            display: block;
        }

        .btn {
            background: var(--primary-color);
            color: white;
            border: none;
            padding: 14px 20px;
            border-radius: 50px;
            font-size: 1rem;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
            box-shadow: 0 4px 12px rgba(0,0,0,0.15);
            margin: 6px 0;
            width: 100%;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
        }

        .btn-secondary {
            background: var(--secondary-color);
        }

        .btn-danger {
            background: var(--accent-color);
        }

        .btn-success {
            background: var(--success-color);
        }

        .btn-warning {
            background: var(--warning-color);
        }

        .btn:disabled {
            background: #95a5a6;
            cursor: not-allowed;
            transform: none;
            box-shadow: none;
        }

        .story-content {
            background: #1e1e1e;
            border-radius: 12px;
            padding: 16px;
            margin: 12px 0;
            border-left: 4px solid var(--primary-color);
            font-family: 'Times New Roman', serif;
            line-height: 1.8;
            max-height: 50vh;
            overflow-y: auto;
        }

        .chapter-title {
            color: var(--primary-color);
            font-size: 1.2rem;
            margin-bottom: 10px;
            font-weight: bold;
        }

        .progress-container {
            margin: 15px 0;
        }

        .progress-bar {
            width: 100%;
            height: 20px;
            background: #e9ecef;
            border-radius: 10px;
            overflow: hidden;
        }

        .progress-fill {
            height: 100%;
            background: linear-gradient(to right, #8e44ad, #3498db);
            width: 0%;
            transition: width 0.5s ease;
            border-radius: 10px;
        }

        .status-info {
            padding: 10px;
            border-radius: 8px;
            margin: 10px 0;
            background: rgba(255, 255, 255, 0.2);
            color: white;
        }

        .detailed-status {
            font-size: 0.9rem;
            color: #ecf0f1;
            margin-top: 5px;
        }

        .toggle-container {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin: 12px 0;
        }

        .toggle-switch {
            position: relative;
            display: inline-block;
            width: 50px;
            height: 24px;
        }

        .toggle-switch input {
            opacity: 0;
            width: 0;
            height: 0;
        }

        .slider {
            position: absolute;
            cursor: pointer;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-color: #ccc;
            transition: .4s;
            border-radius: 24px;
        }

        .slider:before {
            position: absolute;
            content: "";
            height: 18px;
            width: 18px;
            left: 3px;
            bottom: 3px;
            background-color: white;
            transition: .4s;
            border-radius: 50%;
        }

        input:checked + .slider {
            background-color: var(--primary-color);
        }

        input:checked + .slider:before {
            transform: translateX(26px);
        }

        .character-profile {
            display: flex;
            align-items: center;
            margin: 15px 0;
            padding: 10px;
            background: rgba(236, 240, 241, 0.3);
            border-radius: 10px;
        }

        .character-avatar {
            width: 50px;
            height: 50px;
            border-radius: 50%;
            background: var(--primary-color);
            display: flex;
            align-items: center;
            justify-content: center;
            color: white;
            font-size: 1.5rem;
            margin-right: 15px;
        }

        .character-details {
            flex: 1;
        }

        .character-name {
            font-weight: bold;
            color: var(--dark-color);
        }

        .character-desc {
            font-size: 0.9rem;
            color: #7f8c8d;
        }

        .emotion-tag {
            display: inline-block;
            padding: 4px 10px;
            border-radius: 15px;
            font-size: 0.8rem;
            margin: 3px;
            background: #e74c3c;
            color: white;
        }

        .emotion-buon {
            background: #3498db;
        }

        .emotion-dau {
            background: #e74c3c;
        }

        .emotion-bat-luc {
            background: #95a5a6;
        }

        .sensitive-word {
            background: #e74c3c;
            color: white;
            padding: 2px 4px;
            border-radius: 4px;
            font-size: 0.9em;
        }

        .dialogue {
            font-style: italic;
            color: #2c3e50;
            margin: 5px 0;
            padding-left: 15px;
            border-left: 3px solid #3498db;
        }

        .analysis-result-item {
            margin: 10px 0;
            padding: 10px;
            background: #2c2c2c;
            border-radius: 8px;
        }

        .loading {
            display: inline-block;
            width: 18px;
            height: 18px;
            border: 2px solid #f3f3f3;
            border-top: 2px solid var(--primary-color);
            border-radius: 50%;
            animation: spin 1s linear infinite;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        @media only screen and (device-width: 375px) and (device-height: 812px) and (-webkit-device-pixel-ratio: 3) {
            .container {
                padding: 12px;
                padding-bottom: 80px;
            }
            
            .header h1 {
                font-size: 1.6rem;
            }
            
            .card {
                padding: 16px;
            }
            
            .btn {
                padding: 12px 16px;
                font-size: 0.9rem;
            }
            
            .story-content {
                font-size: 0.95rem;
                max-height: 45vh;
            }
        }
        
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>üìñ Tr√¨nh Ph√¢n T√≠ch & T·∫°o Truy·ªán</h1>
            <p>Ph√¢n t√≠ch n√¢ng cao v√† t·∫°o truy·ªán t·ª± ƒë·ªông</p>
        </div>

        <div id="tab-analysis" class="tab-content active">
            <div class="card">
                <h3>üîç Ph√¢n t√≠ch ngu·ªìn truy·ªán</h3>
                <p>Ph√¢n t√≠ch c√°c file vƒÉn b·∫£n ƒë·ªÉ t·∫°o d·ªØ li·ªáu cho truy·ªán</p>
                
                <div class="status-info" id="statusInfo">
                    <p>üî¥ Ch∆∞a k·∫øt n·ªëi Google Drive</p>
                    <div class="detailed-status" id="detailedStatus"></div>
                </div>
                <div id="detailedStatus" style="margin-top:10px; color:#555; font-size:14px;"></div>
                <div class="progress-container">
                    <div class="progress-bar">
                        <div class="progress-fill" id="progressBar"></div>
                    </div>
                </div>
                
                <button class="btn" onclick="handleAuthClick()">
                    üìÅ K·∫øt n·ªëi Google Drive
                </button>
                
                <button class="btn btn-secondary" id="scanBtn" onclick="scanFolder()" disabled>
                    üîç Qu√©t th∆∞ m·ª•c
                </button>
                
                <button class="btn btn-warning" id="analyzeBtn" onclick="analyzeFiles()" disabled>
                    üß† Ph√¢n t√≠ch n√¢ng cao
                </button>
                
                <button class="btn btn-success" id="downloadAnalysisBtn" onclick="downloadAnalysis()" disabled>
                    üì• T·∫£i ph√¢n t√≠ch xu·ªëng
                </button>
                
                <div class="toggle-container">
                    <span>B·ªè qua file ƒë√£ ph√¢n t√≠ch</span>
                    <label class="toggle-switch">
                        <input type="checkbox" id="skipAnalyzedFiles" checked>
                        <span class="slider"></span>
                    </label>
                </div>
            </div>
            
            <div class="card">
                <button class="btn btn-secondary" id="downloadScanCacheBtn" onclick="downloadScanCache()" disabled>
    üì• T·∫£i danh s√°ch ƒë√£ qu√©t
</button>
                <h3>üìä K·∫øt qu·∫£ ph√¢n t√≠ch</h3>
                <div id="analysisResults">
                    <p>Ch∆∞a c√≥ d·ªØ li·ªáu ph√¢n t√≠ch. Vui l√≤ng qu√©t v√† ph√¢n t√≠ch th∆∞ m·ª•c tr∆∞·ªõc.</p>
                </div>
            </div>
        </div>

        <div id="tab-write" class="tab-content">
            <div class="card">
                <h3>‚úçÔ∏è Vi·∫øt truy·ªán</h3>
                <p>T·∫°o truy·ªán m·ªõi d·ª±a tr√™n d·ªØ li·ªáu ƒë√£ ph√¢n t√≠ch</p>
                
                <div class="character-profile">
                    <div class="character-avatar">üë®</div>
                    <div class="character-details">
                        <div class="character-name">Ng∆∞·ªùi k·ªÉ chuy·ªán</div>
                        <div class="character-desc">T·∫°o truy·ªán t·ª´ d·ªØ li·ªáu ƒë√£ ph√¢n t√≠ch</div>
                    </div>
                </div>
                
                <div class="toggle-container">
                    <span>S·ªë ch∆∞∆°ng (50+):</span>
                    <input type="number" id="minChapters" value="50" min="50" max="100" style="width: 60px; padding: 5px; border-radius: 5px; border: 1px solid #ddd;">
                </div>

                <div class="toggle-container">
                    <span>ƒê·ªô nh·∫°y c·∫£m:</span>
                    <input type="range" id="sensitivityLevel" min="1" max="10" value="5" style="width: 120px;">
                    <span id="sensitivityValue">5</span>
                </div>
                
                <button class="btn btn-success" id="generateBtn" onclick="generateStories()" disabled>
                    ‚úçÔ∏è B·∫Øt ƒë·∫ßu vi·∫øt truy·ªán
                </button>
                
                <div class="progress-container">
                    <div class="progress-bar">
                        <div class="progress-fill" id="writeProgressBar"></div>
                    </div>
                </div>
                
                <div class="status-info">
                    <p id="writeStatus">Ch∆∞a b·∫Øt ƒë·∫ßu vi·∫øt truy·ªán</p>
                    <div class="detailed-status" id="writeDetailedStatus"></div>
                </div>
            </div>
            
            <div class="card">
                <h3>üìñ Truy·ªán ƒëang vi·∫øt</h3>
                <div id="generatedStories">
                    <p>Ch∆∞a c√≥ truy·ªán n√†o ƒë∆∞·ª£c t·∫°o. H√£y b·∫•m "B·∫Øt ƒë·∫ßu vi·∫øt truy·ªán" ƒë·ªÉ b·∫Øt ƒë·∫ßu.</p>
                </div>
            </div>
        </div>

        <div id="tab-stories" class="tab-content">
            <div class="card">
                <h3>üìö Th∆∞ vi·ªán truy·ªán</h3>
                <p>Nh·ªØng truy·ªán ƒë√£ ƒë∆∞·ª£c t·∫°o v√† l∆∞u tr·ªØ</p>
                
                <div id="storiesLibrary">
                    <p>Ch∆∞a c√≥ truy·ªán n√†o trong th∆∞ vi·ªán.</p>
                    <div id="readerContainer" style="display:none; margin-top:20px;">
    <h3 id="readerTitle">üìñ ƒêang ƒë·ªçc truy·ªán</h3>
    <div id="readerContent" class="story-content"></div>
    <div style="margin-top:10px; display:flex; justify-content:space-between;">
        <button class="btn btn-secondary" onclick="prevChapter()">‚¨ÖÔ∏è Ch∆∞∆°ng tr∆∞·ªõc</button>
        <button class="btn btn-secondary" onclick="nextChapter()">Ch∆∞∆°ng ti·∫øp ‚û°Ô∏è</button>
    </div>
                </div>
                
                <button class="btn btn-secondary" id="loadStoriesBtn" onclick="loadStories()">
                    üîÑ T·∫£i danh s√°ch truy·ªán
                </button>
            </div>
        </div>

        <div id="tab-settings" class="tab-content">
            <div class="card">
                <h3>‚öôÔ∏è C√†i ƒë·∫∑t</h3>
                
                <div class="toggle-container">
                    <span>T·ª± ƒë·ªông l∆∞u ti·∫øn ƒë·ªô</span>
                    <label class="toggle-switch">
                        <input type="checkbox" id="autoSaveResults" checked>
                        <span class="slider"></span>
                    </label>
                </div>
                
                <div class="toggle-container">
                    <span>G·ª≠i d·ªØ li·ªáu c·∫£i thi·ªán AI</span>
                    <label class="toggle-switch">
                        <input type="checkbox" id="sendImprovementData" checked>
                        <span class="slider"></span>
                    </label>
                </div>
                
                <button class="btn" onclick="clearCache()">
                    üóëÔ∏è X√≥a d·ªØ li·ªáu t·∫°m
                </button>
                
                <button class="btn btn-danger" onclick="handleSignoutClick()">
                    üö™ ƒêƒÉng xu·∫•t
                </button>
            </div>
            
            <div class="card">
                <h3>‚ÑπÔ∏è Th√¥ng tin ·ª©ng d·ª•ng</h3>
                <p>Phi√™n b·∫£n: 2.1.0</p>
                <p>Ph√¢n t√≠ch n√¢ng cao: H·ªôi tho·∫°i & T·ª´ nh·∫°y c·∫£m</p>
                <p>G√≥c nh√¨n: Linh ho·∫°t theo ph√¢n t√≠ch</p>
            </div>
        </div>
    </div>

    <div class="bottom-menu">
        <a href="#" class="menu-item active" onclick="switchTab('tab-analysis')">
            <div class="menu-icon">üîç</div>
            <span>Ph√¢n t√≠ch</span>
        </a>
        <a href="#" class="menu-item" onclick="switchTab('tab-write')">
            <div class="menu-icon">‚úçÔ∏è</div>
            <span>Vi·∫øt truy·ªán</span>
        </a>
        <a href="#" class="menu-item" onclick="switchTab('tab-stories')">
            <div class="menu-icon">üìö</div>
            <span>Th∆∞ vi·ªán</span>
        </a>
        <a href="#" class="menu-item" onclick="switchTab('tab-settings')">
            <div class="menu-icon">‚öôÔ∏è</div>
            <span>C√†i ƒë·∫∑t</span>
        </a>
    </div>

    <script>
        // Google API Configuration
        const CLIENT_ID = '398509518475-7bjid324tkuuh9gv8b0g92lhsgv8nrl5.apps.googleusercontent.com';
        const API_KEY = 'AIzaSyAbcWr0UPvC4YpsunE6uAa7E5pan9iys2o';
        const DISCOVERY_DOC = 'https://www.googleapis.com/discovery/v1/apis/drive/v3/rest';
        const SCOPES = 'https://www.googleapis.com/auth/drive';

        let tokenClient;
        let gapi_inited = false;
        let gsi_inited = false;

        // Global variables
        let analysisData = [];
        let generatedStories = [];
        let scanCache = {};
        const CACHE_FILE_NAME = 'ScanCache_QuanLyTruyen.json';
        const ANALYSIS_CACHE_NAME = 'AnalysisResults_QuanLyTruyen.json';
        const STORY_CACHE_NAME = 'GeneratedStories_QuanLyTruyen.json';

        // Vietnamese language processing data - M·ªü r·ªông cho ph√¢n t√≠ch n√¢ng cao
        const vietnameseStopWords = [
            'l√†', 'c·ªßa', 'v√†', 'c√≥', 'm·ªôt', 'ƒë∆∞·ª£c', 'trong', 'kh√¥ng', 'v·ªõi', 't·ª´', 'ƒë·ªÉ', 'ƒë√£', 's·∫Ω',
            'v·ªÅ', 'cho', 'theo', 'nh∆∞', 'khi', 'v√†o', 'ra', 'l√™n', 'xu·ªëng', 'qua', 't·∫°i', 'hay',
            'r·∫±ng', 'n·∫øu', 'm√†', 'th√¨', 'ho·∫∑c', 'nh∆∞ng', 'v√¨', 'n√™n', 'ƒë·∫øn', 'b·∫±ng', 'tr√™n', 'd∆∞·ªõi'
        ];

        // T·ª´ nh·∫°y c·∫£m cho ph√¢n t√≠ch n√¢ng cao
        const sensitiveWords = {
            romantic: ['y√™u', 'th∆∞∆°ng', 'h√¥n', '√¥m', '·∫•p √¥m', '√¢m √°p', 'say ƒë·∫Øm', 'ƒëam m√™', 'd·ªãu d√†ng', 'ng·ªçt ng√†o', 'quy·∫øn r≈©', 'm√™ ho·∫∑c', 'th√¢n m·∫≠t', 'g·∫ßn g≈©i'],
            sexual: [
                'g·ªëi chƒÉn', 'ph√≤ng the', '√¢n √°i', 'l√†m t√¨nh', 'quan h·ªá', 't√¨nh d·ª•c',
                'd√¢m', 'd·ª•c', 'kho√°i c·∫£m', 'k√≠ch th√≠ch', 'kho·∫£ th√¢n', 'l√µa th·ªÉ',
                's∆∞·ªõng', 'r√™n r·ªâ', 'n·ª©ng', '∆∞·ªõt √°t', 'cao tr√†o', 'c·ª±c kho√°i', 'xu·∫•t tinh',
                'd∆∞∆°ng v·∫≠t', 'c·∫∑c', 'bu·ªìi', 'chim', 'c√°i ·∫•y',
                '√¢m ƒë·∫°o', 'l·ªìn', 'b∆∞·ªõm', '√¢m h·ªô', 'h·ªôt le', 'mu', 'l·ªó', 'xo·∫°c',
                'b√∫ v√∫', 'v√∫ to', 'v√∫ cƒÉng', 'b√∫ m√∫t', 'ng·ª±c tr·∫ßn', 'ng·ª±c kh·ªßng', 'ƒë·∫ßu ti',
                'b√∫ l·ªìn', 'b√∫ c·∫∑c', 'li·∫øm l·ªìn', 'li·∫øm bi', 'nu·ªët tinh', 'b√∫ h·ªôt le', 'b√∫ ƒë·∫ßu c·∫∑c',
                't·ª≠ cung', 'b·∫Øn v√†o t·ª≠ cung', 'c·∫∑c d√†i 20cm', 'ng·∫≠m tinh', 'ch·ªãch', 'ƒë·ªãt', 'n·∫Øc',
                'th·ªïi k√®n', 'bj', 'hj', 'anal', 'doggy', '69', 'threesome', 'th·ªß d√¢m',
                'ch∆°i g√°i', 'ƒëƒ©', 'g√°i m·∫°i d√¢m', 'm√¥ng to', 'th·ª•t ra th·ª•t v√†o', 'c·∫Øm s√¢u',
                's·ªù so·∫°ng', 'm√∫t', 'c·∫Øn', 'xoa', 'vu·ªët ve', 'h√∫p s√≤', 'ph√™', 'nghi·ªán sex',
                'xo·∫°c l·ªìn', 'xo·∫°c c·∫∑c', 'tra t·∫•n t√¨nh d·ª•c', 'h√†nh x√°c', 'ch·ªãu tr·∫≠n',
                'nh√©t', 'ƒë√∫t', 'l√†m nh·ª•c', 'b√≥p v√∫', 't√©t ƒë√≠t', 'v·ªó m√¥ng', 't√∫m t√≥c',
                'b·∫°o d√¢m', 'c∆∞·ª°ng hi·∫øp', 'hi·∫øp d√¢m', 'lo·∫°n lu√¢n', 'th·∫±ng cha', '√¥ng gi√† d√¢m ƒë√£ng',
                'con ƒëƒ©', 'con cave', 'ch·ªã d√¢u', 'em d√¢u', 'anh r·ªÉ', 'ch·ªã g√°i', 'm·∫π ch·ªìng', 'cha con', 'm·∫π con',
                'r√™n la', 'r√™n r·ªâ', 'h√©t l√™n v√¨ s∆∞·ªõng', 'm·∫Øt l·ªù ƒë·ªù', 'm·ªì h√¥i nh·ªÖ nh·∫°i',
                'b·∫Øn tinh', 'phun tinh', 'tinh d·ªãch', 'tinh tr√†n', 'nu·ªët s·∫°ch tinh',
                'm√πi tanh', 'v·ªã m·∫∑n', '∆∞·ªõt ƒë·∫´m', 'n∆∞·ªõc nh·ªùn', 'd·ªãch nh·ªùn',
                 // ===== H√†nh ƒë·ªông & t√¨nh d·ª•c =====
        'l√†m t√¨nh', 'quan h·ªá', '√¢n √°i', 'th·ªß d√¢m', 'k√≠ch th√≠ch',
        'c·ªüi ƒë·ªì', 'vu·ªët ve', 's·ªù m√≥', '√¥m h√¥n', 'th√¢m nh·∫≠p',
        'r√™n r·ªâ', 'xu·∫•t tinh', 'cao tr√†o', 'c·ª±c kho√°i', '∆∞·ªõt √°t',

        // ===== L·ªùi tho·∫°i t√¨nh d·ª•c chung =====
        '"mu·ªën anh"', '"mu·ªën em"', '"l√†m em s∆∞·ªõng"', '"c·ª©ng qu√°"',
        '"em ∆∞·ªõt r·ªìi"', '"m·∫°nh l√™n"', '"ra ƒëi"', '"b·∫Øn v√†o trong"',

        // ===== Quan h·ªá gia ƒë√¨nh nh·∫°y c·∫£m =====
        'b·ªë ch·ªìng', 'con d√¢u', 'cha ch·ªìng', 'n√†ng d√¢u',
        '"b·ªë ch·ªìng"', '"con d√¢u"', '"cha ch·ªìng"', '"n√†ng d√¢u"',
        '"b·ªë ch·ªìng ∆°i"', '"con d√¢u ngoan"', '"b·ªë ch·ªìng l√†m cho con"',
        '"con d√¢u c·ªßa b·ªë"', '"b·ªë mu·ªën con"', '"b·ªë ch·ªìng kh√¥ng ch·ªãu n·ªïi"',
        '"con d√¢u s∆∞·ªõng qu√°"', '"l√†m d√¢u b·ªë"', '"b·ªë ch·ªìng y√™u con d√¢u"',
        
        // ===== C√°c t√¨nh hu·ªëng tho·∫°i ƒë·∫∑c th√π =====
        'quan h·ªá v·ªõi b·ªë ch·ªìng', 'quan h·ªá c√πng con d√¢u', 
        'ch·ªãch con d√¢u', 'b·ªë ch·ªìng ƒë·ª• con d√¢u', 'b·ªë ch·ªìng hi·∫øp con d√¢u',
        'l√†m t√¨nh v·ªõi con d√¢u', 'b·ªë ch·ªìng √¥m con d√¢u',
        'con d√¢u r√™n', 'b·ªë ch·ªìng th·ªèa m√£n', 'b·ªë ch·ªìng c∆∞·ª°ng hi·∫øp'
            ],
            negative: ['gh√©t', 'h·∫≠n', 'gi·∫≠n', 't·ª©c', 't·ªßi', 'bu·ªìn', 'ƒëau', 'kh·ªï', 's·∫ßu', 'th·∫£m', 'bi', 'tang', 't·ª≠', 'ch·∫øt', 'gi·∫øt', 'h·∫°i', '√°c', 'd·ªØ', 'hung'],
            family: ['b·ªë', 'm·∫π', 'cha', 'con', 'ch·ªìng', 'v·ª£', 'd√¢u', 'r·ªÉ', 'anh', 'ch·ªã', 'em', '√¥ng', 'b√†', 'ch√∫', 'b√°c', 'c√¥', 'd√¨', 'c·∫≠u', 'm·ª£'],
            secret: ['b√≠ m·∫≠t', 'gi·∫•u gi·∫øm', 'che gi·∫•u', 'gi·∫•u di·∫øm', 'l√©n l√∫t', 'v·ª•ng tr·ªôm', '√¢m th·∫ßm', 'l·∫∑ng l·∫Ω', 'k√≠n ƒë√°o', 'ri√™ng t∆∞']
        };

        const emotionalWords = {
            positive: ['vui', 'h·∫°nh ph√∫c', 'y√™u', 'th∆∞∆°ng', 'tuy·ªát v·ªùi', 'ƒë·∫πp', 't·ªët', 'xu·∫•t s·∫Øc', 'th√†nh c√¥ng', 'hy v·ªçng'],
            negative: ['bu·ªìn', 'ƒëau', 'kh·ªï', 't·ªá', 'x·∫•u', 'th·∫•t b·∫°i', 'tuy·ªát v·ªçng', 'gh√©t', 't·ª©c gi·∫≠n', 'lo l·∫Øng', 's·ª£ h√£i', 'kh√≥c', 'tang th∆∞∆°ng', 'b·∫•t h·∫°nh', 'd·ªëi tr√°', 'ph·∫£n b·ªôi', 'l·ª´a d·ªëi', 'x√≥t xa', 'ƒëau ƒë·ªõn', 'x·∫•u h·ªï', 't·ªßi nh·ª•c'],
            neutral: ['b√¨nh th∆∞·ªùng', 'th√¥ng th∆∞·ªùng', 'trung b√¨nh', '·ªïn', 'ƒë∆∞·ª£c', 't·∫°m ·ªïn']
        };

        // T·ª´ kh√≥a ƒë·∫∑c bi·ªát cho ph√¢n t√≠ch h·ªôi tho·∫°i
        const dialogueIndicators = ['n√≥i', 'b·∫£o', 'h·ªèi', 'ƒë√°p', 'th∆∞a', 'k√™u', 'g·ªçi', 'h√©t', 'la', 'th√©t', 'th√¨ th·∫ßm', 'r·ªß r·ªâ', 'l√™n ti·∫øng', 'ph√°t bi·ªÉu', 'tr·∫£ l·ªùi', 'h·ªèi l·∫°i', 'ƒë√°p l·∫°i'];
        const dialoguePunctuation = ['"', "'", ':', ';', '-', '‚Äî', '‚Äì'];

        // Initialize Google APIs
        function gapiLoaded() {
            gapi.load('client', initializeGapiClient);
        }

        async function initializeGapiClient() {
            await gapi.client.init({
                apiKey: API_KEY,
                discoveryDocs: [DISCOVERY_DOC],
            });
            gapi_inited = true;
            maybeEnableButtons();
            await loadAnalysisData(); // T·∫£i d·ªØ li·ªáu ph√¢n t√≠ch khi kh·ªüi ƒë·ªông
        }

        function gisLoaded() {
            tokenClient = google.accounts.oauth2.initTokenClient({
                client_id: CLIENT_ID,
                scope: SCOPES,
                callback: '',
            });
            gsi_inited = true;
            maybeEnableButtons();
        }

        function maybeEnableButtons() {
            if (gapi_inited && gsi_inited) {
                document.getElementById('scanBtn').disabled = false;
            }
        }

        // Authentication functions
        function handleAuthClick() {
            tokenClient.callback = async (resp) => {
                if (resp.error !== undefined) {
                    throw (resp);
                }
                await showLoggedInState();
            };

            if (gapi.client.getToken() === null) {
                tokenClient.requestAccessToken({prompt: 'consent'});
            } else {
                tokenClient.requestAccessToken({prompt: ''});
            }
        }

        function handleSignoutClick() {
            const token = gapi.client.getToken();
            if (token !== null) {
                google.accounts.oauth2.revoke(token.access_token);
                gapi.client.setToken('');
                showLoggedOutState();
            }
        }

        async function showLoggedInState() {
             updateStatus('üü¢ ƒê√£ k·∫øt n·ªëi Google Drive');
    
    const enableButtons = ['scanBtn', 'analyzeBtn', 'generateBtn', 
                           'downloadAnalysisBtn', 'downloadScanCacheBtn', 
                           'loadStoriesBtn'];
    enableButtons.forEach(id => {
        if (document.getElementById(id)) {
            document.getElementById(id).disabled = false;
        }
    });

    try {
        const response = await gapi.client.request({
            path: 'https://openidconnect.googleapis.com/v1/userinfo'
        });
        // üëâ C√≥ th·ªÉ hi·ªÉn th·ªã t√™n / email ng∆∞·ªùi d√πng t·∫°i ƒë√¢y
        console.log("User Info:", response.result);
    } catch (error) {
        console.error('Error getting user info:', error);
    }
        }

        function showLoggedOutState() {
              updateStatus('üî¥ Ch∆∞a k·∫øt n·ªëi Google Drive');

    const disableButtons = ['scanBtn', 'analyzeBtn', 'generateBtn', 
                            'downloadAnalysisBtn', 'downloadScanCacheBtn', 
                            'loadStoriesBtn'];
    disableButtons.forEach(id => {
        if (document.getElementById(id)) {
            document.getElementById(id).disabled = true;
        }
    });

    // ·∫®n lu√¥n tr√¨nh ƒë·ªçc truy·ªán n·∫øu ƒëang m·ªü
    document.getElementById('readerContainer').style.display = "none";
        }

        // Tab switching function
        function switchTab(tabId) {
            document.querySelectorAll('.tab-content').forEach(tab => {
                tab.classList.remove('active');
            });
            
            document.getElementById(tabId).classList.add('active');
            
            document.querySelectorAll('.menu-item').forEach(item => {
                item.classList.remove('active');
            });
            
            const menuItems = document.querySelectorAll('.menu-item');
            for (let item of menuItems) {
                if (item.textContent.includes(
                    tabId === 'tab-analysis' ? 'Ph√¢n t√≠ch' :
                    tabId === 'tab-write' ? 'Vi·∫øt truy·ªán' :
                    tabId === 'tab-stories' ? 'Th∆∞ vi·ªán' : 'C√†i ƒë·∫∑t'
                )) {
                    item.classList.add('active');
                    break;
                }
            }
            
            return false;
        }

        // Advanced Analysis Functions
        async function analyzeFiles() {
            if (!window.txtFiles || window.txtFiles.length === 0) {
                alert('Vui l√≤ng qu√©t th∆∞ m·ª•c tr∆∞·ªõc khi ph√¢n t√≠ch!');
                return;
            }
            
            updateStatus('üß† B·∫Øt ƒë·∫ßu ph√¢n t√≠ch n√¢ng cao...');
            analysisData = [];
            
            const skipAnalyzed = document.getElementById('skipAnalyzedFiles').checked;
            let filesToAnalyze = window.txtFiles;
            
            if (skipAnalyzed) {
                try {
                    const response = await gapi.client.drive.files.list({
                        q: `name='${ANALYSIS_CACHE_NAME}' and trashed=false`,
                        fields: 'files(id)'
                    });
                    
                    if (response.result.files.length > 0) {
                        const analysisResponse = await gapi.client.drive.files.get({
                            fileId: response.result.files[0].id,
                            alt: 'media'
                        });
                        
                        const existingAnalysis = JSON.parse(analysisResponse.body);
                        const analyzedFileNames = existingAnalysis.analysisData.map(a => a.fileName);
                        
                        filesToAnalyze = window.txtFiles.filter(file => 
                            !analyzedFileNames.includes(file.name)
                        );
                        
                        if (filesToAnalyze.length === 0) {
                            updateStatus('‚úÖ T·∫•t c·∫£ file ƒë√£ ƒë∆∞·ª£c ph√¢n t√≠ch tr∆∞·ªõc ƒë√≥');
                            analysisData = existingAnalysis.analysisData;
                            displayAdvancedAnalysisResults();
                            document.getElementById('generateBtn').disabled = false;
                            document.getElementById('downloadAnalysisBtn').disabled = false;
                            return;
                        }
                        
                        analysisData = existingAnalysis.analysisData;
                        updateStatus(`üîç B·ªè qua ${window.txtFiles.length - filesToAnalyze.length} file ƒë√£ ph√¢n t√≠ch, ti·∫øp t·ª•c v·ªõi ${filesToAnalyze.length} file m·ªõi`);
                    }
                } catch (error) {
                    console.log('No existing analysis found or error loading it, analyzing all files');
                }
            }
            
            const totalFiles = Math.min(filesToAnalyze.length, 50);
            
            for (let i = 0; i < totalFiles; i++) {
                const file = filesToAnalyze[i];
                updateProgress((i / totalFiles) * 100);
                updateStatus(`üß† ƒêang ph√¢n t√≠ch: ${file.name} (${i+1}/${totalFiles})`);
                updateDetailedStatus(`Ph√¢n t√≠ch h·ªôi tho·∫°i v√† t·ª´ nh·∫°y c·∫£m...`);
                
                try {
                    const response = await gapi.client.drive.files.get({
                        fileId: file.id,
                        alt: 'media'
                    });
                    
                    const content = response.body;
                    const analysis = await performAdvancedAnalysis(content, file.name, file.folderPath);
                    analysisData.push(analysis);
                    
                    if (document.getElementById('autoSaveResults').checked) {
                        await autoSaveAnalysis();
                    }
                    
                    await new Promise(resolve => setTimeout(resolve, 500));
                    
                } catch (error) {
                    console.error(`Error analyzing file ${file.name}:`, error);
                    analysisData.push({
                        fileName: file.name,
                        error: error.message
                    });
                }
            }
            
            displayAdvancedAnalysisResults();
            document.getElementById('generateBtn').disabled = false;
            document.getElementById('downloadAnalysisBtn').disabled = false;
            updateProgress(100);
            updateStatus(`‚úÖ Ho√†n th√†nh ph√¢n t√≠ch ${totalFiles} file`);
            updateDetailedStatus('');
            
            setTimeout(() => updateProgress(0), 2000);
        }

        async function performAdvancedAnalysis(content, fileName, folderPath) {
            await new Promise(resolve => setTimeout(resolve, 100));
            
            const analysis = {
                fileName: fileName,
                folderPath: folderPath || 'Unknown',
                timestamp: new Date().toLocaleString('vi-VN'),
                
                // Ph√¢n t√≠ch c∆° b·∫£n
                basicStats: analyzeBasicStats(content),
                
                // Ph√¢n t√≠ch c·∫£m x√∫c
                emotionalAnalysis: analyzeEmotionsAdvanced(content),
                
                // Ph√¢n t√≠ch ch·ªß ƒë·ªÅ
                thematicAnalysis: analyzeThemes(content),
                
                // Ph√¢n t√≠ch nh√¢n v·∫≠t
                characterAnalysis: analyzeCharactersAdvanced(content),
                
                // Ph√¢n t√≠ch h·ªôi tho·∫°i (m·ªõi)
                dialogueAnalysis: analyzeDialogues(content),
                
                // Ph√¢n t√≠ch t·ª´ nh·∫°y c·∫£m (m·ªõi)
                sensitiveAnalysis: analyzeSensitiveContent(content),
                
                // Ph√¢n t√≠ch c·ªët truy·ªán
                narrativeAnalysis: analyzeNarrativeStructure(content),
                
                // M·∫´u n·ªôi dung
                contentSample: content.substring(0, 1000) + (content.length > 1000 ? '...' : '')
            };
            
            return analysis;
        }

        function analyzeBasicStats(content) {
            const sentences = content.split(/[.!?]+/).filter(s => s.trim().length > 0);
            const paragraphs = content.split(/\n\s*\n/).filter(p => p.trim().length > 0);
            const words = content.split(/\s+/).filter(w => w.length > 0);
            const characters = content.length;
            const charactersNoSpaces = content.replace(/\s/g, '').length;
            
            return {
                wordCount: words.length,
                sentenceCount: sentences.length,
                paragraphCount: paragraphs.length,
                characterCount: characters,
                characterCountNoSpaces: charactersNoSpaces,
                avgWordsPerSentence: Math.round(words.length / sentences.length * 10) / 10,
                avgSentencesPerParagraph: Math.round(sentences.length / paragraphs.length * 10) / 10,
                avgWordLength: Math.round(charactersNoSpaces / words.length * 10) / 10
            };
        }

        function analyzeEmotionsAdvanced(content) {
            const words = content.toLowerCase().split(/\s+/);
            const sentences = content.split(/[.!?]+/).filter(s => s.trim().length > 0);
            
            let emotionCounts = {
                positive: 0,
                negative: 0,
                neutral: 0
            };
            
            let emotionDistribution = [];
            let emotionalSentences = [];
            
            words.forEach(word => {
                for (const [emotion, keywords] of Object.entries(emotionalWords)) {
                    if (keywords.some(kw => word.includes(kw))) {
                        emotionCounts[emotion]++;
                        break;
                    }
                }
            });
            
            sentences.forEach((sentence, index) => {
                const sentenceLower = sentence.toLowerCase();
                let emotionScore = 0;
                
                for (const [emotion, keywords] of Object.entries(emotionalWords)) {
                    keywords.forEach(kw => {
                        if (sentenceLower.includes(kw)) {
                            emotionScore += emotion === 'positive' ? 1 : emotion === 'negative' ? -1 : 0;
                        }
                    });
                }
                
                if (Math.abs(emotionScore) > 0) {
                    emotionalSentences.push({
                        sentence: sentence.trim(),
                        emotionScore: emotionScore,
                        index: index
                    });
                }
            });
            
            const totalEmotionalWords = emotionCounts.positive + emotionCounts.negative + emotionCounts.neutral;
            
            if (totalEmotionalWords > 0) {
                emotionDistribution = [
                    { emotion: 'positive', percentage: Math.round((emotionCounts.positive / totalEmotionalWords) * 100) },
                    { emotion: 'negative', percentage: Math.round((emotionCounts.negative / totalEmotionalWords) * 100) },
                    { emotion: 'neutral', percentage: Math.round((emotionCounts.neutral / totalEmotionalWords) * 100) }
                ];
            }
            
            return {
                emotionCounts,
                emotionDistribution,
                emotionalSentences: emotionalSentences.slice(0, 10),
                dominantEmotion: emotionDistribution.length > 0 ? 
                    emotionDistribution.reduce((prev, current) => 
                        (prev.percentage > current.percentage) ? prev : current).emotion : 'neutral'
            };
        }

        function analyzeThemes(content) {
            const words = content.toLowerCase().split(/\s+/);
            const wordFrequency = {};
            
            words.forEach(word => {
                if (word.length > 3 && !vietnameseStopWords.includes(word)) {
                    wordFrequency[word] = (wordFrequency[word] || 0) + 1;
                }
            });
            
            const sortedWords = Object.entries(wordFrequency)
                .sort((a, b) => b[1] - a[1])
                .slice(0, 20);
            
            const themes = [];
            sortedWords.forEach(([word, count]) => {
                if (count > 2) {
                    themes.push({ word, count });
                }
            });
            
            return themes;
        }

        function analyzeCharactersAdvanced(content) {
            const lines = content.split('\n');
            const characters = [];
            const characterMentions = {};
            
            lines.forEach(line => {
                // T√¨m t√™n nh√¢n v·∫≠t (vi·∫øt hoa ch·ªØ c√°i ƒë·∫ßu)
                const nameMatches = line.match(/\b[A-Z√Ä√Å·∫¢√É·∫†ƒÇ·∫∞·∫Æ·∫≤·∫¥·∫∂√Ç·∫¶·∫§·∫®·∫™·∫¨ƒê√à√â·∫∫·∫º·∫∏√ä·ªÄ·∫æ·ªÇ·ªÑ·ªÜ√å√ç·ªàƒ®·ªä√í√ì·ªé√ï·ªå√î·ªí·ªê·ªî·ªñ·ªò∆†·ªú·ªö·ªû·ª†·ª¢√ô√ö·ª¶≈®·ª§∆Ø·ª™·ª®·ª¨·ªÆ·ª∞·ª≤√ù·ª∂·ª∏·ª¥][a-z√†√°·∫£√£·∫°ƒÉ·∫±·∫Ø·∫≥·∫µ·∫∑√¢·∫ß·∫•·∫©·∫´·∫≠ƒë√®√©·∫ª·∫Ω·∫π√™·ªÅ·∫ø·ªÉ·ªÖ·ªá√¨√≠·ªâƒ©·ªã√≤√≥·ªè√µ·ªç√¥·ªì·ªë·ªï·ªó·ªô∆°·ªù·ªõ·ªü·ª°·ª£√π√∫·ªß≈©·ª•∆∞·ª´·ª©·ª≠·ªØ·ª±·ª≥√Ω·ª∑·ªπ·ªµ]+\b/g);
                
                if (nameMatches) {
                    nameMatches.forEach(name => {
                        if (name.length > 2 && !characterMentions[name]) {
                            characterMentions[name] = 0;
                            characters.push({
                                name: name,
                                mentions: 0,
                                firstAppearance: line.substring(0, 100) + '...'
                            });
                        }
                        if (characterMentions[name] !== undefined) {
                            characterMentions[name]++;
                        }
                    });
                }
            });
            
            characters.forEach(char => {
                char.mentions = characterMentions[char.name] || 0;
            });
            
            return characters.sort((a, b) => b.mentions - a.mentions).slice(0, 10);
        }

        function analyzeDialogues(content) {
            const lines = content.split('\n');
            const dialogues = [];
            let dialogueCount = 0;
            
            lines.forEach((line, index) => {
                const trimmedLine = line.trim();
                
                // Ki·ªÉm tra xem d√≤ng n√†y c√≥ ph·∫£i l√† h·ªôi tho·∫°i kh√¥ng
                const isDialogue = dialogueIndicators.some(indicator => 
                    trimmedLine.toLowerCase().includes(indicator)
                ) || dialoguePunctuation.some(punct => 
                    trimmedLine.includes(punct)
                );
                
                if (isDialogue && trimmedLine.length > 10) {
                    dialogueCount++;
                    
                    // T√¨m c√¢u h·ªôi tho·∫°i tr·ª±c ti·∫øp (trong d·∫•u ngo·∫∑c k√©p)
                    const directDialogueMatch = trimmedLine.match(/["'](.*?)["']/);
                    if (directDialogueMatch) {
                        dialogues.push({
                            type: 'direct',
                            content: directDialogueMatch[1],
                            context: trimmedLine,
                            lineNumber: index + 1
                        });
                    } else {
                        dialogues.push({
                            type: 'indirect',
                            content: trimmedLine,
                            context: '',
                            lineNumber: index + 1
                        });
                    }
                }
            });
            
            return {
                totalDialogues: dialogueCount,
                sampleDialogues: dialogues.slice(0, 5)
            };
        }

        function analyzeSensitiveContent(content) {
            const contentLower = content.toLowerCase();
            const foundSensitiveWords = {};
            let totalSensitiveWords = 0;
            
            // Ki·ªÉm tra t·∫•t c·∫£ c√°c lo·∫°i t·ª´ nh·∫°y c·∫£m
            for (const [category, words] of Object.entries(sensitiveWords)) {
                foundSensitiveWords[category] = [];
                
                words.forEach(word => {
                    const regex = new RegExp('\\b' + word + '\\b', 'gi');
                    const matches = contentLower.match(regex);
                    
                    if (matches) {
                        foundSensitiveWords[category].push({
                            word: word,
                            count: matches.length
                        });
                        totalSensitiveWords += matches.length;
                    }
                });
            }
            
            // T√≠nh ƒëi·ªÉm nh·∫°y c·∫£m
            let sensitivityScore = 0;
            if (totalSensitiveWords > 0) {
                sensitivityScore = Math.min(10, Math.floor(totalSensitiveWords / 5) + 
                    (foundSensitiveWords.sexual ? foundSensitiveWords.sexual.length * 2 : 0));
            }
            
            return {
                foundSensitiveWords,
                totalSensitiveWords,
                sensitivityScore
            };
        }

        function analyzeNarrativeStructure(content) {
            const sentences = content.split(/[.!?]+/).filter(s => s.trim().length > 0);
            const paragraphs = content.split(/\n\s*\n/).filter(p => p.trim().length > 0);
            
            return {
                estimatedReadingTime: Math.ceil(sentences.length / 10),
                complexityScore: Math.min(10, Math.ceil(sentences.length / 50 + paragraphs.length / 10)),
                narrativeStyle: sentences.length > paragraphs.length * 5 ? 'descriptive' : 'dialogue-heavy'
            };
        }

        function displayAdvancedAnalysisResults() {
            const resultsContainer = document.getElementById('analysisResults');
            
            if (!analysisData || analysisData.length === 0) {
                resultsContainer.innerHTML = '<p>Ch∆∞a c√≥ d·ªØ li·ªáu ph√¢n t√≠ch. Vui l√≤ng qu√©t v√† ph√¢n t√≠ch th∆∞ m·ª•c tr∆∞·ªõc.</p>';
                return;
            }
            
            let html = `<h4>üìä T·ªïng quan ph√¢n t√≠ch (${analysisData.length} file)</h4>`;
            
            analysisData.forEach((data, index) => {
                if (data.error) {
                    html += `
                        <div class="analysis-result-item">
                            <h4>‚ùå ${data.fileName}</h4>
                            <p>L·ªói: ${data.error}</p>
                        </div>
                    `;
                    return;
                }
                
                html += `
                    <div class="analysis-result-item">
                        <h4>üìÑ ${data.fileName} (${data.folderPath})</h4>
                        <p><strong>Th·ªùi gian:</strong> ${data.timestamp}</p>
                        
                        <div class="toggle-container" onclick="toggleDetails('details-${index}')">
                            <span>üìà Th·ªëng k√™ c∆° b·∫£n</span>
                            <span>‚ñº</span>
                        </div>
                        <div id="details-${index}" style="display:none;">
                            <p><strong>S·ªë t·ª´:</strong> ${data.basicStats.wordCount}</p>
                            <p><strong>S·ªë c√¢u:</strong> ${data.basicStats.sentenceCount}</p>
                            <p><strong>S·ªë ƒëo·∫°n:</strong> ${data.basicStats.paragraphCount}</p>
                            <p><strong>ƒê·ªô d√†i trung b√¨nh t·ª´:</strong> ${data.basicStats.avgWordLength} k√Ω t·ª±</p>
                            <p><strong>T·ª´/c√¢u trung b√¨nh:</strong> ${data.basicStats.avgWordsPerSentence}</p>
                            
                            <div class="toggle-container" onclick="toggleDetails('emotion-${index}')">
                                <span>üòä Ph√¢n t√≠ch c·∫£m x√∫c</span>
                                <span>‚ñº</span>
                            </div>
                            <div id="emotion-${index}" style="display:none;">
                                <p><strong>C·∫£m x√∫c ch·ªß ƒë·∫°o:</strong> ${data.emotionalAnalysis.dominantEmotion}</p>
                                <p><strong>T√≠ch c·ª±c:</strong> ${data.emotionalAnalysis.emotionCounts.positive} t·ª´</p>
                                <p><strong>Ti√™u c·ª±c:</strong> ${data.emotionalAnalysis.emotionCounts.negative} t·ª´</p>
                                <p><strong>Trung t√≠nh:</strong> ${data.emotionalAnalysis.emotionCounts.neutral} t·ª´</p>
                                
                                ${data.emotionalAnalysis.emotionDistribution.map(ed => 
                                    `<p><strong>${ed.emotion}:</strong> ${ed.percentage}%</p>`
                                ).join('')}
                            </div>
                            
                            <div class="toggle-container" onclick="toggleDetails('dialogue-${index}')">
                                <span>üí¨ Ph√¢n t√≠ch h·ªôi tho·∫°i</span>
                                <span>‚ñº</span>
                            </div>
                            <div id="dialogue-${index}" style="display:none;">
                                <p><strong>T·ªïng s·ªë h·ªôi tho·∫°i:</strong> ${data.dialogueAnalysis.totalDialogues}</p>
                                ${data.dialogueAnalysis.sampleDialogues.map(d => 
                                    `<div class="dialogue">
                                        <p>${d.content.substring(0, 100)}${d.content.length > 100 ? '...' : ''}</p>
                                        <small>D√≤ng ${d.lineNumber}, Lo·∫°i: ${d.type}</small>
                                    </div>`
                                ).join('')}
                            </div>
                            
                            <div class="toggle-container" onclick="toggleDetails('sensitive-${index}')">
                                <span>‚ö†Ô∏è T·ª´ nh·∫°y c·∫£m</span>
                                <span>‚ñº</span>
                            </div>
                            <div id="sensitive-${index}" style="display:none;">
                                <p><strong>ƒêi·ªÉm nh·∫°y c·∫£m:</strong> ${data.sensitiveAnalysis.sensitivityScore}/10</p>
                                <p><strong>T·ªïng t·ª´ nh·∫°y c·∫£m:</strong> ${data.sensitiveAnalysis.totalSensitiveWords}</p>
                                
                                ${Object.entries(data.sensitiveAnalysis.foundSensitiveWords).map(([category, words]) => {
                                    if (words.length === 0) return '';
                                    return `
                                        <p><strong>${category}:</strong> ${words.map(w => `${w.word} (${w.count})`).join(', ')}</p>
                                    `;
                                }).join('')}
                            </div>
                            
                            <div class="toggle-container" onclick="toggleDetails('sample-${index}')">
                                <span>üîç M·∫´u n·ªôi dung</span>
                                <span>‚ñº</span>
                            </div>
                            <div id="sample-${index}" style="display:none;">
                                <div class="story-content">
                                    ${highlightSensitiveWords(data.contentSample)}
                                </div>
                            </div>
                        </div>
                    </div>
                `;
            });
            
            resultsContainer.innerHTML = html;
        }

        function highlightSensitiveWords(text) {
            let highlightedText = text;
            
            // T√¥ s√°ng t·∫•t c·∫£ c√°c t·ª´ nh·∫°y c·∫£m
            for (const [category, words] of Object.entries(sensitiveWords)) {
                for (const word of words) {
                    const regex = new RegExp('\\b' + word + '\\b', 'gi');
                    highlightedText = highlightedText.replace(regex, 
                        match => `<span class="sensitive-word">${match}</span>`
                    );
                }
            }
            
            return highlightedText;
        }

        function toggleDetails(id) {
            const element = document.getElementById(id);
            if (element.style.display === 'none') {
                element.style.display = 'block';
            } else {
                element.style.display = 'none';
            }
        }

        // Scan folder function
        async function scanFolder() {
            updateStatus('üîç ƒêang qu√©t th∆∞ m·ª•c "QuanLyTruyen"...');
            updateProgress(10);
            
            try {
                // T√¨m th∆∞ m·ª•c QuanLyTruyen
                const folderResponse = await gapi.client.drive.files.list({
                    q: "name='QuanLyTruyen' and mimeType='application/vnd.google-apps.folder' and trashed=false",
                    fields: 'files(id, name)'
                });
                
                if (folderResponse.result.files.length === 0) {
                    updateStatus('‚ùå Kh√¥ng t√¨m th·∫•y th∆∞ m·ª•c "QuanLyTruyen"');
                    return;
                }
                
                const folderId = folderResponse.result.files[0].id;
                updateProgress(30);
                updateStatus('üìÇ ƒêang t√¨m ki·∫øm file vƒÉn b·∫£n...');
                
                // T√¨m t·∫•t c·∫£ c√°c file .txt trong th∆∞ m·ª•c v√† c√°c th∆∞ m·ª•c con
                let allFiles = [];
                let nextPageToken = null;
                
                do {
                    const fileResponse = await gapi.client.drive.files.list({
                        q: `'${folderId}' in parents and trashed=false`,
                        fields: 'nextPageToken, files(id, name, mimeType, parents)',
                        pageSize: 100,
                        pageToken: nextPageToken || undefined
                    });
                    
                    const files = fileResponse.result.files;
                    
                    for (let file of files) {
                        if (file.mimeType === 'application/vnd.google-apps.folder') {
                            // ƒê·ªá quy v√†o th∆∞ m·ª•c con
                            const subFiles = await getFilesFromFolder(file.id, file.name);
                            allFiles = allFiles.concat(subFiles);
                        } else if (file.name.endsWith('.txt')) {
                            file.folderPath = 'QuanLyTruyen';
                            allFiles.push(file);
                        }
                    }
                    
                    nextPageToken = fileResponse.result.nextPageToken;
                } while (nextPageToken);
                
                updateProgress(70);
                
                if (allFiles.length === 0) {
                    updateStatus('‚ùå Kh√¥ng t√¨m th·∫•y file vƒÉn b·∫£n (.txt) trong th∆∞ m·ª•c');
                    return;
                }
                
                window.txtFiles = allFiles;
                updateProgress(100);
                updateStatus(`‚úÖ ƒê√£ t√¨m th·∫•y ${allFiles.length} file vƒÉn b·∫£n`);
                document.getElementById('analyzeBtn').disabled = false;
                document.getElementById('downloadScanCacheBtn').disabled = false;
                
                // L∆∞u cache scan
                scanCache = {
                    files: allFiles.map(f => ({ id: f.id, name: f.name, folderPath: f.folderPath })),
                    timestamp: new Date().toISOString()
                };
                
                await saveScanCache();
                
            } catch (error) {
                console.error('Error scanning folder:', error);
                updateStatus('‚ùå L·ªói khi qu√©t th∆∞ m·ª•c: ' + error.message);
            }
        }

        async function getFilesFromFolder(folderId, folderPath) {
            let files = [];
            let nextPageToken = null;
            
            do {
                const response = await gapi.client.drive.files.list({
                    q: `'${folderId}' in parents and trashed=false`,
                    fields: 'nextPageToken, files(id, name, mimeType, parents)',
                    pageSize: 100,
                    pageToken: nextPageToken || undefined
                });
                
                const folderFiles = response.result.files;
                
                for (let file of folderFiles) {
                    if (file.mimeType === 'application/vnd.google-apps.folder') {
                        // ƒê·ªá quy v√†o th∆∞ m·ª•c con
                        const subFiles = await getFilesFromFolder(file.id, `${folderPath}/${file.name}`);
                        files = files.concat(subFiles);
                    } else if (file.name.endsWith('.txt')) {
                        file.folderPath = folderPath;
                        files.push(file);
                    }
                }
                
                nextPageToken = response.result.nextPageToken;
            } while (nextPageToken);
            
            return files;
        }

        async function saveScanCache() {
            try {
                // Ki·ªÉm tra xem file cache ƒë√£ t·ªìn t·∫°i ch∆∞a
                const response = await gapi.client.drive.files.list({
                    q: `name='${CACHE_FILE_NAME}' and trashed=false`,
                    fields: 'files(id)'
                });
                
                const cacheContent = JSON.stringify(scanCache);
                const media = {
                    mimeType: 'application/json',
                    body: cacheContent
                };
                
                if (response.result.files.length > 0) {
                    // C·∫≠p nh·∫≠t file cache ƒë√£ t·ªìn t·∫°i
                    await gapi.client.drive.files.update({
                        fileId: response.result.files[0].id,
                        media: media
                    });
                } else {
                    // T·∫°o file cache m·ªõi
                    const metadata = {
                        name: CACHE_FILE_NAME,
                        mimeType: 'application/json'
                    };
                    
                    await gapi.client.drive.files.create({
                        resource: metadata,
                        media: media,
                        fields: 'id'
                    });
                }
            } catch (error) {
                console.error('Error saving scan cache:', error);
            }
        }

        async function loadScanCache() {
            try {
                const response = await gapi.client.drive.files.list({
                    q: `name='${CACHE_FILE_NAME}' and trashed=false`,
                    fields: 'files(id)'
                });
                
                if (response.result.files.length > 0) {
                    const cacheResponse = await gapi.client.drive.files.get({
                        fileId: response.result.files[0].id,
                        alt: 'media'
                    });
                    
                    scanCache = JSON.parse(cacheResponse.body);
                    
                    // Ki·ªÉm tra xem cache c√≥ c√≤n h·ª£p l·ªá kh√¥ng (kh√¥ng qu√° 24 gi·ªù)
                    const cacheAge = new Date() - new Date(scanCache.timestamp);
                    if (cacheAge < 24 * 60 * 60 * 1000) {
                        window.txtFiles = scanCache.files;
                        document.getElementById('analyzeBtn').disabled = false;
                         document.getElementById('downloadScanCacheBtn').disabled = false;
                        updateStatus(`‚úÖ ƒê√£ t·∫£i cache scan v·ªõi ${scanCache.files.length} file`);
                        return true;
                    }
                }
            } catch (error) {
                console.error('Error loading scan cache:', error);
            }
            
            return false;
        }

        async function autoSaveAnalysis() {
    try {
        const analysisContent = {
            analysisData: analysisData,
            timestamp: new Date().toISOString()
        };

        const contentString = JSON.stringify(analysisContent);
        const media = {
            mimeType: 'application/json',
            body: contentString
        };

        // Ki·ªÉm tra xem file ƒë√£ t·ªìn t·∫°i ch∆∞a
        const response = await gapi.client.drive.files.list({
            q: `name='${ANALYSIS_CACHE_NAME}' and trashed=false`,
            fields: 'files(id)'
        });

        if (response.result.files.length > 0) {
            // üîÑ Update file duy nh·∫•t
            await gapi.client.request({
                path: `/upload/drive/v3/files/${response.result.files[0].id}`,
                method: 'PATCH',
                params: { uploadType: 'media' },
                body: contentString
            });
        } else {
            // ‚ûï Create file m·ªõi
            const metadata = {
                name: ANALYSIS_CACHE_NAME,
                mimeType: 'application/json'
            };

            await gapi.client.drive.files.create({
                resource: metadata,
                media: media,
                fields: 'id'
            });
        }
    } catch (error) {
        console.error('Error auto-saving analysis:', error);
    }
}


        async function loadAnalysisData() {
            try {
                const response = await gapi.client.drive.files.list({
                    q: `name='${ANALYSIS_CACHE_NAME}' and trashed=false`,
                    fields: 'files(id)'
                });
                
                if (response.result.files.length > 0) {
                    const analysisResponse = await gapi.client.drive.files.get({
                        fileId: response.result.files[0].id,
                        alt: 'media'
                    });
                    
                    const analysisContent = JSON.parse(analysisResponse.body);
                    analysisData = analysisContent.analysisData;
                    
                    displayAdvancedAnalysisResults();
                    document.getElementById('generateBtn').disabled = false;
                    document.getElementById('downloadAnalysisBtn').disabled = false;
                    
                    updateStatus('‚úÖ ƒê√£ t·∫£i d·ªØ li·ªáu ph√¢n t√≠ch t·ª´ l·∫ßn tr∆∞·ªõc');
                    return true;
                }
            } catch (error) {
                console.error('Error loading analysis data:', error);
            }
            
            return false;
        }

        async function downloadAnalysis() {
           try {
        const response = await gapi.client.drive.files.list({
            q: `name='${ANALYSIS_CACHE_NAME}' and trashed=false`,
            fields: 'files(id, name)'
        });

        if (response.result.files.length === 0) {
            alert("‚ùå Kh√¥ng t√¨m th·∫•y file ph√¢n t√≠ch tr√™n Google Drive!");
            return;
        }

        const fileId = response.result.files[0].id;
        const analysisResponse = await gapi.client.drive.files.get({
            fileId: fileId,
            alt: 'media'
        });

        const analysisContent = JSON.parse(analysisResponse.body);
        analysisData = analysisContent.analysisData;

        displayAdvancedAnalysisResults();
        updateStatus('‚úÖ ƒê√£ t·∫£i d·ªØ li·ªáu ph√¢n t√≠ch t·ª´ Google Drive');
    } catch (error) {
        console.error('Error downloading analysis:', error);
        updateStatus('‚ùå L·ªói khi t·∫£i d·ªØ li·ªáu ph√¢n t√≠ch t·ª´ Google Drive');
    }
        }

        // Story generation functions
        async function generateStories() {
            if (!analysisData || analysisData.length === 0) {
        alert('‚ö†Ô∏è Vui l√≤ng ph√¢n t√≠ch d·ªØ li·ªáu tr∆∞·ªõc khi t·∫°o truy·ªán!');
        return;
    }

    updateWriteStatus('‚úçÔ∏è B·∫Øt ƒë·∫ßu vi·∫øt truy·ªán...');
    updateWriteProgress(0);

    const minChapters = parseInt(document.getElementById('minChapters').value) || 50;
    const sensitivityLevel = parseInt(document.getElementById('sensitivityLevel').value) || 5;

    generatedStories = [];

    // T√¨m ho·∫∑c t·∫°o th∆∞ m·ª•c cha QuanLyTruyen
    let storiesFolderId = await findOrCreateFolder('QuanLyTruyen');

    for (let i = 0; i < analysisData.length; i++) {
        const data = analysisData[i];
        updateWriteStatus(`üìñ ƒêang vi·∫øt truy·ªán t·ª´: ${data.fileName} (${i+1}/${analysisData.length})`);
        updateWriteProgress((i / analysisData.length) * 50);

        try {
            // T·∫°o truy·ªán t·ª´ data ph√¢n t√≠ch
            const story = await generateStoryFromAnalysis(data, minChapters, sensitivityLevel);
            generatedStories.push(story);

            // L∆∞u v√†o Google Drive
            await saveStoryToDrive(story, storiesFolderId);

            updateWriteDetailedStatus(`‚úÖ ƒê√£ t·∫°o: ${story.title} (${story.chapters.length} ch∆∞∆°ng)`);
        } catch (error) {
            console.error(`Error generating story from ${data.fileName}:`, error);
            updateWriteDetailedStatus(`‚ùå L·ªói v·ªõi ${data.fileName}: ${error.message}`);
        }

        await new Promise(resolve => setTimeout(resolve, 500));
    }

    displayGeneratedStories();
    updateWriteProgress(100);
    updateWriteStatus(`üéâ Ho√†n th√†nh t·∫°o ${generatedStories.length} truy·ªán`);
        }

        async function generateStoryFromAnalysis(analysis, minChapters, sensitivityLevel) {
             const title = generateTitle(analysis);
  const description = generateDescription(analysis);

  const chapters = [];
  const numChapters = Math.max(minChapters, Math.floor(analysis.basicStats.wordCount / 2500));

  for (let i = 1; i <= numChapters; i++) {
    const chapterTitle = `Ch∆∞∆°ng ${i}: ${generateChapterTitle(analysis, i)}`;
    const chapterContent = await generateChapterContent(analysis, sensitivityLevel, 2000, 3000);

    chapters.push({
      title: chapterTitle,
      content: chapterContent,
      wordCount: chapterContent.split(/\s+/).length
    });
  }

  return { title, description, chapters };
    //        const title = generateTitle(analysis);       // t√™n truy·ªán t·ª± sinh
    // const description = generateDescription(analysis);

    // const chapters = [];
    // const numChapters = Math.max(minChapters, Math.floor(analysis.basicStats.wordCount / 2500));

    // for (let i = 1; i <= numChapters; i++) {
    //     const chapterTitle = `Ch∆∞∆°ng ${i}: ${generateChapterTitle(analysis, i)}`;
    //     const chapterContent = generateChapterContent(analysis, sensitivityLevel, 2000, 3000);

    //     chapters.push({
    //         title: chapterTitle,
    //         content: chapterContent,
    //         wordCount: chapterContent.split(/\s+/).length
    //     });
    }

    // return {
    //     title: title,
    //     description: description,
    //     chapters: chapters,
    //     source: analysis.fileName,
    //     generatedAt: new Date().toLocaleString('vi-VN'),
    //     totalWords: chapters.reduce((sum, ch) => sum + ch.wordCount, 0)
    // };
        // }

        function generateTitle(analysis) {
            const themes = analysis.thematicAnalysis.slice(0, 3).map(t => t.word);
            const characters = analysis.characterAnalysis.slice(0, 2).map(c => c.name);
            
            const titlePatterns = [
                `${characters[0]} v√† ${characters[1]}`,
                `Cu·ªôc ƒë·ªùi ${characters[0]}`,
                `H√†nh tr√¨nh c·ªßa ${characters[0]}`,
                `T√¨nh ${themes[0]}`,
                `B√≠ m·∫≠t ${themes[0]}`,
                `${themes[0]} v√† ${themes[1]}`,
                `M·ªëi t√¨nh ${themes[0]}`,
                `S·ªë ph·∫≠n ${characters[0]}`,
                `Ng∆∞·ªùi ${themes[0]}`,
                `N·ªói ƒëau ${themes[0]}`,
                `√Ånh s√°ng ${themes[0]}`,
                `B√≥ng t·ªëi ${themes[0]}`
            ];
            
            return titlePatterns[Math.floor(Math.random() * titlePatterns.length)];
        }

        function generateDescription(analysis) {
            const themes = analysis.thematicAnalysis.slice(0, 3).map(t => t.word);
            const characters = analysis.characterAnalysis.slice(0, 2).map(c => c.name);
            const emotion = analysis.emotionalAnalysis.dominantEmotion;
            
            const descriptions = [
                `C√¢u chuy·ªán v·ªÅ ${characters[0]} v√† ${characters[1]} trong th·∫ø gi·ªõi ƒë·∫ßy ${themes[0]} v√† ${themes[1]}. M·ªôt h√†nh tr√¨nh ƒë·∫ßy ${emotion} s·∫Ω thay ƒë·ªïi cu·ªôc ƒë·ªùi h·ªç m√£i m√£i.`,
                `${characters[0]} ƒë√£ lu√¥n tin r·∫±ng ${themes[0]} l√† th·ª© quan tr·ªçng nh·∫•t, cho ƒë·∫øn khi g·∫∑p ${characters[1]}. Li·ªáu ${emotion} c√≥ gi√∫p h·ªç v∆∞·ª£t qua m·ªçi th·ª≠ th√°ch?`,
                `Trong m·ªôt x√£ h·ªôi ƒë·∫ßy r·∫´y ${themes[0]}, ${characters[0]} ph·∫£i ƒë·∫•u tranh ƒë·ªÉ t√¨m ra √Ω nghƒ©a th·ª±c s·ª± c·ªßa ${themes[1]}. M·ªôt c√¢u chuy·ªán ƒë·∫ßy ${emotion} v√† b·∫•t ng·ªù.`,
                `Khi ${themes[0]} v√† ${themes[1]} ƒë·ª•ng ƒë·ªô, ${characters[0]} v√† ${characters[1]} ph·∫£i ƒë∆∞a ra nh·ªØng l·ª±a ch·ªçn kh√≥ khƒÉn. Li·ªáu ${emotion} c√≥ ƒë·ªß ƒë·ªÉ gi·ªØ h·ªç l·∫°i v·ªõi nhau?`,
                `B√≠ m·∫≠t v·ªÅ ${themes[0]} ƒë√£ ƒë∆∞·ª£c gi·∫•u k√≠n h√†ng th·∫ø k·ª∑, cho ƒë·∫øn khi ${characters[0]} v√¥ t√¨nh kh√°m ph√° ra. M·ªôt h√†nh tr√¨nh ${emotion} ƒë·∫ßy nguy hi·ªÉm b·∫Øt ƒë·∫ßu.`
            ];
            
            return descriptions[Math.floor(Math.random() * descriptions.length)];
        }

        function generateChapterTitle(analysis, chapterNumber) {
            const themes = analysis.thematicAnalysis.map(t => t.word);
            const emotions = ['Vui', 'Bu·ªìn', 'Gi·∫≠n', 'Y√™u', 'Th·∫•t v·ªçng', 'Hy v·ªçng', 'ƒêau kh·ªï', 'H·∫°nh ph√∫c'];
            const events = ['G·∫∑p g·ª°', 'Chia ly', 'Kh√°m ph√°', 'Th·ª≠ th√°ch', 'Bi·∫øn c·ªë', 'B√≠ m·∫≠t', 'L·ª±a ch·ªçn', 'Hy sinh'];
            
            return `${events[Math.floor(Math.random() * events.length)]} ${emotions[Math.floor(Math.random() * emotions.length)]}`;
        }

        function generateChapterContent(analysis, sensitivityLevel, minWords = 2000, maxWords = 3000) {
             const wordCountTarget = Math.floor(Math.random() * (maxWords - minWords)) + minWords;

  // Ng·∫´u nhi√™n b·ªëi c·∫£nh
  const times = ["m·ªôt ƒë√™m m∆∞a", "m·ªôt bu·ªïi chi·ªÅu oi ·∫£", "m·ªôt bu·ªïi s√°ng tinh m∆°", "l√∫c ho√†ng h√¥n bu√¥ng xu·ªëng"];
  const places = ["ph√≤ng kh√°ch", "ph√≤ng ng·ªß c≈© c·ªßa b·ªë", "cƒÉn b·∫øp im l√¨m", "g√°c nh·ªè ph√≠a sau nh√†"];
  const weathers = ["m∆∞a r∆°i r·∫£ r√≠ch", "gi√≥ th·ªïi r√≠t qua khe c·ª≠a", "tr·ªùi oi b·ª©c kh√≥ ch·ªãu", "kh√¥ng gian tƒ©nh l·∫∑ng"];
  const chosenTime = times[Math.floor(Math.random() * times.length)];
  const chosenPlace = places[Math.floor(Math.random() * places.length)];
  const chosenWeather = weathers[Math.floor(Math.random() * weathers.length)];

  // Prompt cho AI
  const prompt = `
  H√£y vi·∫øt m·ªôt ch∆∞∆°ng truy·ªán d√†i kho·∫£ng ${wordCountTarget} t·ª´ theo ng√¥i th·ª© nh·∫•t.
  Ng∆∞·ªùi k·ªÉ chuy·ªán l√† ng∆∞·ªùi ch·ªìng, ph√°t hi·ªán m·ªëi quan h·ªá gi·ªØa v·ª£ (con d√¢u) v√† b·ªë (b·ªë ch·ªìng).
  Anh ta ch·ªçn im l·∫∑ng, b·∫•t l·ª±c, ch·ªâ quan s√°t v√† d·∫±n v·∫∑t.
  Trong l·ªùi tho·∫°i: v·ª£ g·ªçi "b·ªë", b·ªë g·ªçi "con".
  B·ªëi c·∫£nh: ${chosenTime}, t·∫°i ${chosenPlace}, ngo√†i tr·ªùi ${chosenWeather}.
  Mi√™u t·∫£ c·∫£m x√∫c n·ªôi t√¢m, h·ªôi tho·∫°i, nguy√™n nh√¢n, khung c·∫£nh, cao tr√†o v√† d∆∞ √¢m.
  `;

  return new Promise((resolve, reject) => {
    textGenerator.generate(
      {
        seed: prompt,        // g·ª£i √Ω ƒë·∫ßu v√†o
        length: 2000,        // s·ªë k√Ω t·ª± (ch·ªânh cao h∆°n n·∫øu mu·ªën d√†i h∆°n)
        temperature: 0.6     // ƒë·ªô s√°ng t·∫°o (0.5‚Äì0.7 ·ªïn)
      },
      (err, result) => {
        if (err) {
          console.error(err);
          reject("‚ùå L·ªói khi sinh vƒÉn b·∫£n v·ªõi ml5");
        } else {
          resolve(result.sample); // vƒÉn b·∫£n AI sinh
        }
      }
    );
  });
            // const targetWords = Math.floor(Math.random() * (maxWords - minWords + 1)) + minWords;
            // let content = '';
            // let wordCount = 0;
            
            // // L·∫•y c√°c y·∫øu t·ªë t·ª´ ph√¢n t√≠ch ƒë·ªÉ t·∫°o n·ªôi dung
            // const themes = analysis.thematicAnalysis.map(t => t.word);
            // const characters = analysis.characterAnalysis.map(c => c.name);
            // const emotionalStyle = analysis.emotionalAnalysis.dominantEmotion;
            
            // // T·∫°o n·ªôi dung cho ƒë·∫øn khi ƒë·∫°t s·ªë t·ª´ mong mu·ªën
            // while (wordCount < targetWords) {
            //     // T·∫°o ƒëo·∫°n vƒÉn ng·∫´u nhi√™n d·ª±a tr√™n ph√¢n t√≠ch
            //     const paragraph = generateParagraph(analysis, themes, characters, emotionalStyle, sensitivityLevel);
            //     content += paragraph + '\n\n';
            //     wordCount += paragraph.split(/\s+/).length;
            // }
            
            // return content;
        }

        function generateParagraph(analysis, themes, characters, emotionalStyle, sensitivityLevel) {
            const paragraphTypes = ['description', 'dialogue', 'action', 'reflection'];
            const type = paragraphTypes[Math.floor(Math.random() * paragraphTypes.length)];
            
            switch (type) {
                case 'description':
                    return generateDescriptiveParagraph(themes, emotionalStyle);
                case 'dialogue':
                    return generateDialogueParagraph(characters, analysis.dialogueAnalysis);
                case 'action':
                    return generateActionParagraph(characters, themes);
                case 'reflection':
                    return generateReflectionParagraph(characters, emotionalStyle);
                default:
                    return generateDescriptiveParagraph(themes, emotionalStyle);
            }
        }

        function generateDescriptiveParagraph(themes, emotionalStyle) {
            const descriptions = [
                `B·∫ßu tr·ªùi ƒë·∫ßy sao l·∫•p l√°nh tr√™n ƒë·∫ßu, mang ƒë·∫øn c·∫£m gi√°c ${emotionalStyle} kh√≥ t·∫£. ${themes[0]} v√† ${themes[1]} h√≤a quy·ªán v√†o nhau t·∫°o n√™n m·ªôt khung c·∫£nh ƒë·∫πp ƒë·∫øn nao l√≤ng.`,
                `Con ƒë∆∞·ªùng l√†ng quanh co u·ªën l∆∞·ª£n gi·ªØa nh·ªØng r·∫∑ng tre xanh r√¨. Ti·∫øng gi√≥ th·ªïi vi vu qua k·∫Ω l√°, mang theo h∆∞∆°ng th∆°m c·ªßa ${themes[2]} v√† ${themes[0]}.`,
                `CƒÉn ph√≤ng nh·ªè ·∫•m √°p v·ªõi √°nh ƒë√®n v√†ng d·ªãu d√†ng. Tr√™n b√†n, m·ªôt ly tr√† n√≥ng b·ªëc kh√≥i nghi ng√∫t, t·ªèa h∆∞∆°ng th∆°m c·ªßa ${themes[1]} v√† k·ª∑ ni·ªám.`,
                `M·∫∑t h·ªì ph·∫≥ng l·∫∑ng nh∆∞ g∆∞∆°ng, ph·∫£n chi·∫øu nh·ªØng ƒë√°m m√¢y tr·∫Øng b·ªìng b·ªÅnh. Xa xa, ti·∫øng chim h√≥t v√©o von h√≤a c√πng ti·∫øng gi√≥ th·ªïi mang ƒë·∫øn s·ª± b√¨nh y√™n ${emotionalStyle}.`,
                `Th√†nh ph·ªë nh·ªôn nh·ªãp v·ªõi nh·ªØng t√≤a nh√† cao t·∫ßng san s√°t nhau. √Ånh ƒë√®n neon ƒë·ªß m√†u nh·∫•p nh√°y, t·∫°o n√™n m·ªôt th·∫ø gi·ªõi ${themes[0]} ƒë·∫ßy m√†u s·∫Øc v√† ${emotionalStyle}.`
            ];
            
            return descriptions[Math.floor(Math.random() * descriptions.length)];
        }

        function generateDialogueParagraph(characters, dialogueAnalysis) {
            if (characters.length < 2) {
                return generateDescriptiveParagraph(['thi√™n nhi√™n', 'phong c·∫£nh'], 'b√¨nh y√™n');
            }
            
            const char1 = characters[Math.floor(Math.random() * characters.length)];
            let char2 = characters[Math.floor(Math.random() * characters.length)];
            
            // ƒê·∫£m b·∫£o 2 nh√¢n v·∫≠t kh√°c nhau
            while (char2 === char1 && characters.length > 1) {
                char2 = characters[Math.floor(Math.random() * characters.length)];
            }
            
            const dialogues = [
                `${char1} nh√¨n ${char2} ch·∫±m ch·∫±m: "T·∫°i sao anh l·∫°i l√†m th·∫ø?"\n${char2} c√∫i ƒë·∫ßu: "Em kh√¥ng hi·ªÉu ƒë√¢u, c√≥ nh·ªØng th·ª© bu·ªôc ph·∫£i nh∆∞ v·∫≠y."`,
                `"T√¥i ƒë√£ nghƒ© ch√∫ng ta hi·ªÉu nhau h∆°n th·∫ø," ${char1} n√≥i v·ªõi gi·ªçng ƒë·∫ßy th·∫•t v·ªçng.\n${char2} th·ªü d√†i: "ƒê√¥i khi hi·ªÉu qu√° r√µ l·∫°i khi·∫øn ng∆∞·ªùi ta ƒëau kh·ªï."`,
                `${char1} m·ªâm c∆∞·ªùi: "M·ªçi chuy·ªán r·ªìi s·∫Ω ·ªïn th√¥i."\n${char2} l·∫Øc ƒë·∫ßu: "T√¥i kh√¥ng ch·∫Øc nh∆∞ v·∫≠y, c√≥ qu√° nhi·ªÅu r·ªßi ro."`,
                `"Anh c√≥ bao gi·ªù nghƒ© v·ªÅ t∆∞∆°ng lai c·ªßa ch√∫ng ta?" ${char1} h·ªèi kh·∫Ω.\n${char2} im l·∫∑ng m·ªôt l√∫c: "T∆∞∆°ng lai l√† th·ª© kh√¥ng th·ªÉ ƒëo√°n tr∆∞·ªõc, em √†."`,
                `${char1} n·∫Øm tay ${char2}: "D√π th·∫ø n√†o ƒëi n·ªØa, t√¥i v·∫´n s·∫Ω lu√¥n b√™n c·∫°nh em."\n${char2} m·∫Øt r∆∞ng r∆∞ng: "Anh th·∫≠t s·ª± nghƒ© v·∫≠y sao?"`
            ];
            
            return dialogues[Math.floor(Math.random() * dialogues.length)];
        }

        function generateActionParagraph(characters, themes) {
            const char = characters[Math.floor(Math.random() * characters.length)];
            
            const actions = [
                `B·∫•t ch·ª£t, ${char} lao v·ªÅ ph√≠a tr∆∞·ªõc v·ªõi t·ªëc ƒë·ªô ch√≥ng m·∫∑t, v∆∞·ª£t qua m·ªçi ch∆∞·ªõng ng·∫°i v·∫≠t v·ªõi s·ª± kh√©o l√©o ƒë√°ng kinh ng·∫°c.`,
                `V·ªõi m·ªôt ƒë·ªông t√°c nhanh nh∆∞ ch·ªõp, ${char} r√∫t v≈© kh√≠ ra v√† chu·∫©n b·ªã cho tr·∫≠n chi·∫øn s·∫Øp t·ªõi.`,
                `${char} h√©t l√™n ƒë·∫ßy ph·∫´n n·ªô v√† t·∫•n c√¥ng ƒë·ªëi th·ªß b·∫±ng t·∫•t c·∫£ s·ª©c m·∫°nh c√≥ trong ng∆∞·ªùi.`,
                `Kh√¥ng ch·∫ßn ch·ª´ th√™m n·ªØa, ${char} nh·∫£y xu·ªëng t·ª´ tr√™n cao, xoay ng∆∞·ªùi v√† ti·∫øp ƒë·∫•t m·ªôt c√°ch nh·∫π nh√†ng.`,
                `V·ªõi ƒë√¥i m·∫Øt s·∫Øc l·∫πm, ${char} quan s√°t xung quanh, t√¨m ki·∫øm b·∫•t k·ª≥ d·∫•u hi·ªáu nguy hi·ªÉm n√†o.`
            ];
            
            return actions[Math.floor(Math.random() * actions.length)];
        }

        function generateReflectionParagraph(characters, emotionalStyle) {
            const char = characters[Math.floor(Math.random() * characters.length)];
            
            const reflections = [
                `${char} ng·ªìi m·ªôt m√¨nh trong ph√≤ng, suy nghƒ© v·ªÅ nh·ªØng g√¨ ƒë√£ x·∫£y ra. C·∫£m gi√°c ${emotionalStyle} tr√†o d√¢ng trong l√≤ng.`,
                `Trong im l·∫∑ng, ${char} nh·∫≠n ra r·∫±ng c√≥ nh·ªØng th·ª© quan tr·ªçng h∆°n nh·ªØng g√¨ m√¨nh t·ª´ng nghƒ©.`,
                `${char} t·ª± h·ªèi li·ªáu m√¨nh ƒë√£ ƒë∆∞a ra quy·∫øt ƒë·ªãnh ƒë√∫ng ƒë·∫Øn hay kh√¥ng. S·ª± ${emotionalStyle} khi·∫øn tr√°i tim nh√≥i ƒëau.`,
                `K√Ω ·ª©c √πa v·ªÅ nh∆∞ th√°c l≈©, khi·∫øn ${char} kh√¥ng th·ªÉ k√¨m ƒë∆∞·ª£c n∆∞·ªõc m·∫Øt. Nh·ªØng k·ª∑ ni·ªám ${emotionalStyle} c·ª© th·∫ø xo√°y s√¢u v√†o t√¢m tr√≠.`,
                `${char} nh√¨n ra xa, suy ng·∫´m v·ªÅ √Ω nghƒ©a th·ª±c s·ª± c·ªßa cu·ªôc s·ªëng v√† nh·ªØng g√¨ th·ª±c s·ª± quan tr·ªçng.`
            ];
            
            return reflections[Math.floor(Math.random() * reflections.length)];
        }

        async function findOrCreateFolder(folderName) {
            try {
                // T√¨m th∆∞ m·ª•c
                const response = await gapi.client.drive.files.list({
                    q: `name='${folderName}' and mimeType='application/vnd.google-apps.folder' and trashed=false`,
                    fields: 'files(id, name)'
                });
                
                if (response.result.files.length > 0) {
                    return response.result.files[0].id;
                }
                
                // T·∫°o th∆∞ m·ª•c m·ªõi n·∫øu kh√¥ng t√¨m th·∫•y
                const metadata = {
                    name: folderName,
                    mimeType: 'application/vnd.google-apps.folder'
                };
                
                const folder = await gapi.client.drive.files.create({
                    resource: metadata,
                    fields: 'id'
                });
                
                return folder.result.id;
            } catch (error) {
                console.error('Error finding/creating folder:', error);
                throw error;
            }
        }

        async function saveStoryToDrive(story, parentFolderId) {
           try {
        // T·∫°o th∆∞ m·ª•c ri√™ng cho truy·ªán
        const storyFolderMetadata = {
            name: story.title,
            mimeType: 'application/vnd.google-apps.folder',
            parents: [parentFolderId]
        };

        const storyFolder = await gapi.client.drive.files.create({
            resource: storyFolderMetadata,
            fields: 'id'
        });

        const storyFolderId = storyFolder.result.id;

        // T·∫°o file m√¥ t·∫£
        const descriptionContent = `T·ª±a ƒë·ªÅ: ${story.title}\nM√¥ t·∫£: ${story.description}\nNgu·ªìn: ${story.source}\nNg√†y t·∫°o: ${story.generatedAt}\nS·ªë ch∆∞∆°ng: ${story.chapters.length}\nT·ªïng s·ªë t·ª´: ${story.totalWords}`;
        await gapi.client.drive.files.create({
            resource: { name: 'M√¥ t·∫£.txt', mimeType: 'text/plain', parents: [storyFolderId] },
            media: { mimeType: 'text/plain', body: descriptionContent },
            fields: 'id'
        });

        // T·∫°o t·ª´ng ch∆∞∆°ng
        for (let i = 0; i < story.chapters.length; i++) {
            const chapter = story.chapters[i];
            const content = `${chapter.title}\n\n${chapter.content}`;

            await gapi.client.drive.files.create({
                resource: { name: `Ch∆∞∆°ng ${i+1}.txt`, mimeType: 'text/plain', parents: [storyFolderId] },
                media: { mimeType: 'text/plain', body: content },
                fields: 'id'
            });
        }

        return storyFolderId;
    } catch (error) {
        console.error('‚ùå Error saving story to drive:', error);
        throw error;
    }
        }

        function displayGeneratedStories() {
            const container = document.getElementById('generatedStories');
            
            if (!generatedStories || generatedStories.length === 0) {
                container.innerHTML = '<p>Ch∆∞a c√≥ truy·ªán n√†o ƒë∆∞·ª£c t·∫°o. H√£y b·∫•m "B·∫Øt ƒë·∫ßu vi·∫øt truy·ªán" ƒë·ªÉ b·∫Øt ƒë·∫ßu.</p>';
                return;
            }
            
            let html = `<h4>üìö ${generatedStories.length} truy·ªán ƒë√£ ƒë∆∞·ª£c t·∫°o</h4>`;
            
            generatedStories.forEach((story, index) => {
                html += `
                    <div class="analysis-result-item">
                        <h4>üìñ ${story.title}</h4>
                        <p><strong>Ngu·ªìn:</strong> ${story.source}</p>
                        <p><strong>Th·ªùi gian:</strong> ${story.generatedAt}</p>
                        <p><strong>S·ªë ch∆∞∆°ng:</strong> ${story.chapters.length}</p>
                        <p><strong>T·ªïng s·ªë t·ª´:</strong> ${story.totalWords}</p>
                        
                        <div class="toggle-container" onclick="toggleStoryDetails('story-${index}')">
                            <span>üìÑ M√¥ t·∫£ truy·ªán</span>
                            <span>‚ñº</span>
                        </div>
                        <div id="story-${index}" style="display:none;">
                            <p>${story.description}</p>
                            
                            <div class="toggle-container" onclick="toggleStoryChapter('story-${index}-chapter')">
                                <span>üîç Xem ch∆∞∆°ng m·∫´u</span>
                                <span>‚ñº</span>
                            </div>
                            <div id="story-${index}-chapter" style="display:none;">
                                <div class="story-content">
                                    <div class="chapter-title">${story.chapters[0].title}</div>
                                    ${story.chapters[0].content.substring(0, 500)}...
                                </div>
                            </div>
                        </div>
                    </div>
                `;
            });
            
            container.innerHTML = html;
        }

        function toggleStoryDetails(id) {
            const element = document.getElementById(id);
            if (element.style.display === 'none') {
                element.style.display = 'block';
            } else {
                element.style.display = 'none';
            }
        }

        function toggleStoryChapter(id) {
            const element = document.getElementById(id);
            if (element.style.display === 'none') {
                element.style.display = 'block';
            } else {
                element.style.display = 'none';
            }
        }

        async function saveGeneratedStoriesCache() {
            try {
                const content = {
                    stories: generatedStories,
                    timestamp: new Date().toISOString()
                };
                
                const contentString = JSON.stringify(content);
                const media = {
                    mimeType: 'application/json',
                    body: contentString
                };
                
                // Ki·ªÉm tra xem file ƒë√£ t·ªìn t·∫°i ch∆∞a
                const response = await gapi.client.drive.files.list({
                    q: `name='${STORY_CACHE_NAME}' and trashed=false`,
                    fields: 'files(id)'
                });
                
                if (response.result.files.length > 0) {
                    // C·∫≠p nh·∫≠t file ƒë√£ t·ªìn t·∫°i
                    await gapi.client.drive.files.update({
                        fileId: response.result.files[0].id,
                        media: media
                    });
                } else {
                    // T·∫°o file m·ªõi
                    const metadata = {
                        name: STORY_CACHE_NAME,
                        mimeType: 'application/json'
                    };
                    
                    await gapi.client.drive.files.create({
                        resource: metadata,
                        media: media,
                        fields: 'id'
                    });
                }
            } catch (error) {
                console.error('Error saving generated stories cache:', error);
            }
        }

        async function loadGeneratedStoriesCache() {
            try {
                const response = await gapi.client.drive.files.list({
                    q: `name='${STORY_CACHE_NAME}' and trashed=false`,
                    fields: 'files(id)'
                });
                
                if (response.result.files.length > 0) {
                    const storiesResponse = await gapi.client.drive.files.get({
                        fileId: response.result.files[0].id,
                        alt: 'media'
                    });
                    
                    const storiesContent = JSON.parse(storiesResponse.body);
                    generatedStories = storiesContent.stories;
                    
                    displayGeneratedStories();
                    return true;
                }
            } catch (error) {
                console.error('Error loading generated stories cache:', error);
            }
            
            return false;
        }

        // Load stories from library
        async function loadStories() {
           try {
        const folderId = await findOrCreateFolder('QuanLyTruyen');
        const response = await gapi.client.drive.files.list({
            q: `'${folderId}' in parents and mimeType='application/vnd.google-apps.folder' and trashed=false`,
            fields: 'files(id, name)',
            pageSize: 100
        });

        const stories = response.result.files;
        const container = document.getElementById('storiesLibrary');
        if (stories.length === 0) {
            container.innerHTML = "<p>‚ùå Ch∆∞a c√≥ truy·ªán n√†o.</p>";
            return;
        }

        let html = "<ul>";
        stories.forEach(story => {
            html += `<li>
                <button class="btn" onclick="openStory('${story.id}','${story.name}')">üìñ ${story.name}</button>
            </li>`;
        });
        html += "</ul>";
        container.innerHTML = html;
    } catch (error) {
        console.error("Error loading stories:", error);
        alert("‚ùå L·ªói khi t·∫£i th∆∞ vi·ªán truy·ªán");
    }
        }

        function displayStoriesLibrary(stories) {
            const container = document.getElementById('storiesLibrary');
            
            if (!stories || stories.length === 0) {
                container.innerHTML = '<p>Ch∆∞a c√≥ truy·ªán n√†o trong th∆∞ vi·ªán.</p>';
                return;
            }
            
            let html = `<h4>üìö ${stories.length} truy·ªán trong th∆∞ vi·ªán</h4>`;
            
            stories.forEach(story => {
                const createdDate = new Date(story.createdTime).toLocaleDateString('vi-VN');
                const modifiedDate = new Date(story.modifiedTime).toLocaleDateString('vi-VN');
                
                html += `
                    <div class="analysis-result-item">
                        <h4>üìñ ${story.name}</h4>
                        <p><strong>Ng√†y t·∫°o:</strong> ${createdDate}</p>
                        <p><strong>Ch·ªânh s·ª≠a l·∫ßn cu·ªëi:</strong> ${modifiedDate}</p>
                        <button class="btn btn-secondary" onclick="openStory('${story.id}')">
                            üìñ M·ªü truy·ªán
                        </button>
                    </div>
                `;
            });
            
            container.innerHTML = html;
        }

        async function openStory(folderId) {
            try {
                // L·∫•y danh s√°ch file trong th∆∞ m·ª•c truy·ªán
                const response = await gapi.client.drive.files.list({
                    q: `'${folderId}' in parents and trashed=false`,
                    fields: 'files(id, name, mimeType)'
                });
                
                const files = response.result.files;
                let storyContent = '';
                
                // T√¨m file m√¥ t·∫£ v√† c√°c ch∆∞∆°ng
                for (const file of files) {
                    if (file.name === 'M√¥ t·∫£.txt') {
                        const descResponse = await gapi.client.drive.files.get({
                            fileId: file.id,
                            alt: 'media'
                        });
                        storyContent += `<h4>${descResponse.body}</h4>`;
                    } else if (file.name.startsWith('Ch∆∞∆°ng') && file.name.endsWith('.txt')) {
                        const chapterResponse = await gapi.client.drive.files.get({
                            fileId: file.id,
                            alt: 'media'
                        });
                        storyContent += `<div class="story-content">${chapterResponse.body}</div>`;
                        break; // Ch·ªâ hi·ªÉn th·ªã ch∆∞∆°ng ƒë·∫ßu ti√™n
                    }
                }
                
                // Hi·ªÉn th·ªã n·ªôi dung truy·ªán
                const container = document.getElementById('storiesLibrary');
                container.innerHTML = `
                    <button class="btn" onclick="loadStories()">‚Üê Quay l·∫°i th∆∞ vi·ªán</button>
                    <div class="story-content">${storyContent}</div>
                `;
                
            } catch (error) {
                console.error('Error opening story:', error);
                updateStatus('‚ùå L·ªói khi m·ªü truy·ªán: ' + error.message);
            }
        }

        // Utility functions
        function updateStatus(message) {
            const statusElement = document.getElementById('statusInfo');
            if (statusElement) {
                statusElement.innerHTML = `<p>${message}</p>`;
            }
        }

        function updateDetailedStatus(message) {
            const detailedStatus = document.getElementById('detailedStatus');
            if (detailedStatus) {
                detailedStatus.textContent = message;
            }
        }

        function updateProgress(percentage) {
            const progressBar = document.getElementById('progressBar');
            if (progressBar) {
                progressBar.style.width = percentage + '%';
            }
        }

        function updateWriteStatus(message) {
            const writeStatus = document.getElementById('writeStatus');
            if (writeStatus) {
                writeStatus.textContent = message;
            }
        }

        function updateWriteDetailedStatus(message) {
            const writeDetailedStatus = document.getElementById('writeDetailedStatus');
            if (writeDetailedStatus) {
                writeDetailedStatus.textContent = message;
            }
        }

        function updateWriteProgress(percentage) {
            const writeProgressBar = document.getElementById('writeProgressBar');
            if (writeProgressBar) {
                writeProgressBar.style.width = percentage + '%';
            }
        }

        function clearCache() {
            if (confirm('B·∫°n c√≥ ch·∫Øc mu·ªën x√≥a t·∫•t c·∫£ d·ªØ li·ªáu t·∫°m? H√†nh ƒë·ªông n√†y kh√¥ng th·ªÉ ho√†n t√°c.')) {
                localStorage.clear();
                updateStatus('üóëÔ∏è ƒê√£ x√≥a d·ªØ li·ªáu t·∫°m');
                
                // C≈©ng x√≥a cache tr√™n Google Drive
                deleteDriveCache();
            }
        }

        async function deleteDriveCache() {
            try {
                const cacheFiles = [CACHE_FILE_NAME, ANALYSIS_CACHE_NAME, STORY_CACHE_NAME];
                
                for (const fileName of cacheFiles) {
                    const response = await gapi.client.drive.files.list({
                        q: `name='${fileName}' and trashed=false`,
                        fields: 'files(id)'
                    });
                    
                    if (response.result.files.length > 0) {
                        await gapi.client.drive.files.delete({
                            fileId: response.result.files[0].id
                        });
                    }
                }
                
                updateStatus('üóëÔ∏è ƒê√£ x√≥a cache tr√™n Google Drive');
            } catch (error) {
                console.error('Error deleting drive cache:', error);
            }
        }

        // Event listeners
        document.getElementById('sensitivityLevel').addEventListener('input', function() {
            document.getElementById('sensitivityValue').textContent = this.value;
        });

        // Initialize the app
        window.onload = function() {
            // Initialize Google APIs
            gapiLoaded();
            gisLoaded();
            
            // Try to load cached data
            setTimeout(() => {
                if (gapi_inited && gsi_inited) {
                    loadScanCache();
                    loadAnalysisData();
                    loadGeneratedStoriesCache();
                }
            }, 2000);
             showLoggedOutState(); // Kh√≥a h·∫øt ch·ª©c nƒÉng khi ch∆∞a login
             setupML5();
        };
        
        async function downloadScanCache() {
    if (!scanCache || !scanCache.files || scanCache.files.length === 0) {
        alert("Ch∆∞a c√≥ d·ªØ li·ªáu cache ƒë·ªÉ t·∫£i xu·ªëng!");
        return;
    }

    try {
        const content = JSON.stringify(scanCache, null, 2);
        const blob = new Blob([content], { type: 'application/json' });
        const url = URL.createObjectURL(blob);

        const a = document.createElement('a');
        a.href = url;
        a.download = 'scan_cache_QuanLyTruyen.json';
        document.body.appendChild(a);
        a.click();

        setTimeout(() => {
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
        }, 100);

        updateStatus('‚úÖ ƒê√£ t·∫£i xu·ªëng file cache danh s√°ch qu√©t');
    } catch (error) {
        console.error('Error downloading scan cache:', error);
        updateStatus('‚ùå L·ªói khi t·∫£i cache');
    }
}
// ==================== üìñ Tr√¨nh ƒë·ªçc truy·ªán t·ª´ Google Drive ====================
let currentChapters = [];
let currentIndex = 0;

async function openStory(storyId, storyName) {
    document.getElementById('readerTitle').innerText = "üìñ " + storyName;
    document.getElementById('readerContainer').style.display = "block";
    
    const response = await gapi.client.drive.files.list({
        q: `'${storyId}' in parents and trashed=false and name contains 'Ch∆∞∆°ng'`,
        fields: 'files(id, name)',
        orderBy: 'name'
    });

    currentChapters = response.result.files.sort((a,b) => a.name.localeCompare(b.name));
    currentIndex = 0;
    await loadChapter(currentIndex);
}

async function loadChapter(index) {
    if (index < 0 || index >= currentChapters.length) return;
    const fileId = currentChapters[index].id;
    const response = await gapi.client.drive.files.get({
        fileId: fileId,
        alt: 'media'
    });
    document.getElementById('readerContent').innerText = response.body;
}

async function nextChapter() {
    if (currentIndex < currentChapters.length - 1) {
        currentIndex++;
        await loadChapter(currentIndex);
    } else {
        alert("‚úÖ B·∫°n ƒë√£ ƒë·ªçc h·∫øt truy·ªán!");
    }
}

async function prevChapter() {
    if (currentIndex > 0) {
        currentIndex--;
        await loadChapter(currentIndex);
    }
}
let textGenerator;

function setupML5() {
  // Load model charRNN (Shakespeare sample, b·∫°n c√≥ th·ªÉ train ri√™ng sau)
  textGenerator = ml5.charRNN(
    "https://storage.googleapis.com/ml5-models/charRNN/shakespeare/",
    modelReady
  );
}

function modelReady() {
  console.log("‚úÖ ml5.js model s·∫µn s√†ng ƒë·ªÉ sinh vƒÉn b·∫£n!");
}
    </script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/ml5/0.12.2/ml5.min.js"></script>

</body>
</html>
