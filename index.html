<!DOCTYPE html>
<html lang="vi">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>AI Story Writer - Simple</title>
    <script src="https://apis.google.com/js/api.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: #f5f5f5;
            color: #333;
            line-height: 1.6;
        }

        .container {
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
        }

        .header {
            text-align: center;
            margin-bottom: 30px;
            background: white;
            padding: 20px;
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }

        .header h1 {
            color: #333;
            margin-bottom: 10px;
        }

        .header p {
            color: #666;
            font-size: 16px;
        }

        .main-content {
            background: white;
            border-radius: 8px;
            padding: 30px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
            margin-bottom: 20px;
        }

        .tabs {
            display: flex;
            background: #f8f9fa;
            border-radius: 6px;
            padding: 4px;
            margin-bottom: 30px;
        }

        .tab {
            flex: 1;
            padding: 12px;
            text-align: center;
            border-radius: 4px;
            cursor: pointer;
            background: none;
            border: none;
            color: #666;
            font-size: 14px;
        }

        .tab.active {
            background: #007bff;
            color: white;
        }

        .tab-content {
            display: none;
        }

        .tab-content.active {
            display: block;
        }

        .section {
            background: #f8f9fa;
            border-radius: 6px;
            padding: 20px;
            margin-bottom: 20px;
        }

        .section h3 {
            margin-bottom: 15px;
            color: #333;
        }

        .form-group {
            margin-bottom: 20px;
        }

        .form-group label {
            display: block;
            margin-bottom: 8px;
            font-weight: 600;
            color: #333;
        }

        .form-group input,
        .form-group select,
        .form-group textarea {
            width: 100%;
            padding: 12px;
            border: 1px solid #ddd;
            border-radius: 4px;
            font-size: 14px;
            background: white;
        }

        .form-group textarea {
            min-height: 120px;
            resize: vertical;
            font-family: inherit;
        }

        .story-input-area {
            min-height: 400px;
            font-family: 'Georgia', serif;
            line-height: 1.8;
        }

        .btn {
            padding: 12px 24px;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-size: 14px;
            font-weight: 500;
            margin-right: 10px;
            margin-bottom: 10px;
            display: inline-block;
        }

        .btn-primary {
            background: #007bff;
            color: white;
        }

        .btn-success {
            background: #28a745;
            color: white;
        }

        .btn-secondary {
            background: #6c757d;
            color: white;
        }

        .btn-danger {
            background: #dc3545;
            color: white;
        }

        .btn:hover {
            opacity: 0.9;
        }

        .btn:disabled {
            opacity: 0.6;
            cursor: not-allowed;
        }

        .alert {
            padding: 12px 16px;
            border-radius: 4px;
            margin-bottom: 20px;
        }

        .alert-success {
            background: #d4edda;
            color: #155724;
            border: 1px solid #c3e6cb;
        }

        .alert-error {
            background: #f8d7da;
            color: #721c24;
            border: 1px solid #f5c6cb;
        }

        .alert-info {
            background: #d1ecf1;
            color: #0c5460;
            border: 1px solid #bee5eb;
        }

        .status-indicator {
            display: inline-block;
            width: 10px;
            height: 10px;
            border-radius: 50%;
            margin-right: 8px;
        }

        .status-connected {
            background: #28a745;
        }

        .status-disconnected {
            background: #dc3545;
        }

        .file-list {
            background: white;
            border: 1px solid #ddd;
            border-radius: 4px;
            max-height: 300px;
            overflow-y: auto;
        }

        .file-item {
            padding: 12px 16px;
            border-bottom: 1px solid #eee;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .file-item:last-child {
            border-bottom: none;
        }

        .file-item:hover {
            background: #f8f9fa;
        }

        .loading {
            text-align: center;
            padding: 40px;
            color: #666;
        }

        .spinner {
            border: 3px solid #f3f3f3;
            border-top: 3px solid #007bff;
            border-radius: 50%;
            width: 30px;
            height: 30px;
            animation: spin 1s linear infinite;
            margin: 0 auto 15px;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        .stats {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 15px;
            margin: 20px 0;
        }

        .stat-card {
            background: white;
            padding: 20px;
            border-radius: 6px;
            border: 1px solid #ddd;
            text-align: center;
        }

        .stat-number {
            font-size: 24px;
            font-weight: bold;
            color: #007bff;
            margin-bottom: 5px;
        }

        .stat-label {
            color: #666;
            font-size: 14px;
        }

        @media (max-width: 768px) {
            .container {
                padding: 15px;
            }
            .tabs {
                flex-direction: column;
            }
            .btn {
                width: 100%;
                margin-right: 0;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>AI Story Writer</h1>
            <p>Vi·∫øt truy·ªán v√† l∆∞u tr·ªØ tr√™n Google Drive</p>
        </div>

        <div class="main-content">
            <div class="tabs">
                <button class="tab active" data-tab="write">Vi·∫øt truy·ªán</button>
                <button class="tab" data-tab="ai">Hu·∫•n luy·ªán AI</button>
                <button class="tab" data-tab="library">Th∆∞ vi·ªán</button>
                <button class="tab" data-tab="drive">Google Drive</button>
            </div>

            <!-- Tab Vi·∫øt truy·ªán -->
            <div class="tab-content active" data-content="write">
                <div class="section">
                    <h3>Ch·∫ø ƒë·ªô vi·∫øt truy·ªán</h3>
                    <div class="form-group">
                        <label>Ch·ªçn ch·∫ø ƒë·ªô</label>
                        <select id="writingMode" onchange="toggleWritingMode()">
                            <option value="manual">Vi·∫øt th·ªß c√¥ng</option>
                            <option value="ai">AI vi·∫øt truy·ªán</option>
                        </select>
                    </div>
                </div>

                <!-- AI Writing Section -->
                <div class="section" id="aiSection" style="display: none;">
                    <h3>ü§ñ C√†i ƒë·∫∑t AI vi·∫øt truy·ªán</h3>
                    <div class="form-group">
                        <label>Ch·ªß ƒë·ªÅ/√ù t∆∞·ªüng truy·ªán</label>
                        <textarea id="storyPrompt" placeholder="V√≠ d·ª•: T√¥i l√† m·ªôt sinh vi√™n ƒë·∫°i h·ªçc s·ªëng ·ªü H√† N·ªôi, g·∫∑p kh√≥ khƒÉn trong cu·ªôc s·ªëng v√† t√¨nh y√™u. Vi·∫øt v·ªÅ nh·ªØng tr·∫£i nghi·ªám c·ªßa t√¥i trong th√†nh ph·ªë l·ªõn..." rows="4"></textarea>
                    </div>
                    <div class="form-group">
                        <label>Phong c√°ch vi·∫øt</label>
                        <select id="writingStyle">
                            <option value="melancholy">Bu·ªìn b√£, n·ªôi t√¢m</option>
                            <option value="romantic">L√£ng m·∫°n, ng·ªçt ng√†o</option>
                            <option value="philosophical">Tri·∫øt l√Ω, s√¢u s·∫Øc</option>
                            <option value="realistic">Th·ª±c t·∫ø, g·∫ßn g·ª•i</option>
                            <option value="nostalgic">Ho√†i ni·ªám, nh·ªõ nhung</option>
                        </select>
                    </div>
                    <div class="form-group">
                        <label>ƒê·ªô d√†i ch∆∞∆°ng (s·ªë t·ª´)</label>
                        <select id="chapterLength">
                            <option value="short">Ng·∫Øn (800-1200 t·ª´)</option>
                            <option value="medium" selected>Trung b√¨nh (1500-2000 t·ª´)</option>
                            <option value="long">D√†i (2500-3000 t·ª´)</option>
                        </select>
                    </div>
                    <div class="form-group">
                        <label>S·ªë ch∆∞∆°ng mu·ªën t·∫°o</label>
                        <input type="number" id="numberOfChapters" value="1" min="1" max="10">
                    </div>
                    <button class="btn btn-success" id="generateStoryBtn">‚ú® T·∫°o truy·ªán b·∫±ng AI</button>
                    <button class="btn btn-primary" id="trainAIBtn">üß† Hu·∫•n luy·ªán AI t·ª´ d·ªØ li·ªáu</button>
                </div>

                <!-- AI Training Status -->
                <div class="section" id="aiTrainingStatus" style="display: none;">
                    <h3>üìä Tr·∫°ng th√°i AI</h3>
                    <div class="stats">
                        <div class="stat-card">
                            <div class="stat-number" id="aiTrainedStories">0</div>
                            <div class="stat-label">Truy·ªán ƒë√£ h·ªçc</div>
                        </div>
                        <div class="stat-card">
                            <div class="stat-number" id="aiVocabulary">0</div>
                            <div class="stat-label">T·ª´ v·ª±ng</div>
                        </div>
                        <div class="stat-card">
                            <div class="stat-number" id="aiAccuracy">0%</div>
                            <div class="stat-label">ƒê·ªô ch√≠nh x√°c</div>
                        </div>
                    </div>
                </div>

                <div class="section">
                    <h3>Th√¥ng tin truy·ªán</h3>
                    <div class="form-group">
                        <label>T√™n truy·ªán</label>
                        <input type="text" id="storyTitle" placeholder="Nh·∫≠p t√™n truy·ªán ho·∫∑c ƒë·ªÉ AI t·ª± t·∫°o...">
                    </div>
                    <div class="form-group">
                        <label>T√°c gi·∫£</label>
                        <input type="text" id="authorName" placeholder="T√™n t√°c gi·∫£...">
                    </div>
                    <div class="form-group">
                        <label>Th·ªÉ lo·∫°i</label>
                        <select id="storyGenre">
                            <option value="romance">L√£ng m·∫°n</option>
                            <option value="drama">T√¢m l√Ω</option>
                            <option value="adventure">Phi√™u l∆∞u</option>
                            <option value="mystery">B√≠ ·∫©n</option>
                            <option value="fantasy">Gi·∫£ t∆∞·ªüng</option>
                        </select>
                    </div>
                </div>

                <div class="section">
                    <h3>N·ªôi dung truy·ªán</h3>
                    <div class="form-group">
                        <label>Vi·∫øt truy·ªán c·ªßa b·∫°n</label>
                        <textarea id="storyContent" class="story-input-area" placeholder="B·∫Øt ƒë·∫ßu vi·∫øt truy·ªán c·ªßa b·∫°n t·∫°i ƒë√¢y...

V√≠ d·ª• (ng√¥i th·ª© nh·∫•t):
Ch∆∞∆°ng 1: Kh·ªüi ƒë·∫ßu

T√¥i b∆∞·ªõc ra kh·ªèi t√≤a nh√† vƒÉn ph√≤ng v·ªõi t√¢m tr·∫°ng n·∫∑ng n·ªÅ. H√† N·ªôi h√¥m nay se l·∫°nh, gi·ªëng nh∆∞ tr√°i tim t√¥i v·∫≠y. C√¥ng vi·ªác v·ª´a m·∫•t, t√¨nh y√™u c≈©ng tan v·ª°. T√¥i kh√¥ng bi·∫øt m√¨nh s·∫Ω ƒëi v·ªÅ ƒë√¢u trong th√†nh ph·ªë r·ªông l·ªõn n√†y.

Nh·ªØng gi·ªçt m∆∞a nh·ªè b·∫Øt ƒë·∫ßu r∆°i, ∆∞·ªõt vai √°o t√¥i. T√¥i ƒë·ª©ng gi·ªØa ph·ªë, nh√¨n nh·ªØng ng∆∞·ªùi qua l·∫°i v·ªôi v√£ t√¨m ch·ªó tr√∫ m∆∞a. Ch·ªâ c√≥ t√¥i, m·ªôt m√¨nh, ƒë·ª©ng ƒë√≥ nh∆∞ m·ªôt k·∫ª l·∫°c l·ªëi..."></textarea>
                    </div>
                    <div id="aiGeneratedContent" style="display: none;">
                        <label>N·ªôi dung AI ƒë√£ t·∫°o</label>
                        <div id="generatedChapters"></div>
                    </div>
                    <button class="btn btn-success" id="saveStoryBtn">üíæ L∆∞u truy·ªán</button>
                    <button class="btn btn-primary" id="uploadToGoogleDrive">‚òÅÔ∏è T·∫£i l√™n Google Drive</button>
                    <button class="btn btn-secondary" id="clearContentBtn">üóëÔ∏è X√≥a n·ªôi dung</button>
                    <button class="btn btn-primary" id="continueWritingBtn" style="display: none;">üìù Ti·∫øp t·ª•c vi·∫øt ch∆∞∆°ng sau</button>
                </div>

                <div id="writeAlert" style="display: none;"></div>
            </div>

            <!-- Tab Th∆∞ vi·ªán -->
            <div class="tab-content" data-content="library">
                <div class="section">
                    <h3>Truy·ªán ƒë√£ l∆∞u</h3>
                    <div class="stats">
                        <div class="stat-card">
                            <div class="stat-number" id="localStoriesCount">0</div>
                            <div class="stat-label">Truy·ªán c·ª•c b·ªô</div>
                        </div>
                        <div class="stat-card">
                            <div class="stat-number" id="driveStoriesCount">0</div>
                            <div class="stat-label">Truy·ªán tr√™n Drive</div>
                        </div>
                        <div class="stat-card">
                            <div class="stat-number" id="totalWordsCount">0</div>
                            <div class="stat-label">T·ªïng s·ªë t·ª´</div>
                        </div>
                    </div>
                </div>

                <div class="section">
                    <h3>Danh s√°ch truy·ªán</h3>
                    <div class="file-list" id="localStoriesList">
                        <div class="loading">Ch∆∞a c√≥ truy·ªán n√†o ƒë∆∞·ª£c l∆∞u</div>
                    </div>
                    <button class="btn btn-primary" id="refreshLibraryBtn">üîÑ L√†m m·ªõi</button>
                </div>
            </div>

            <!-- Tab AI Training -->
            <div class="tab-content" data-content="ai">
                <div class="section">
                    <h3>üß† Hu·∫•n luy·ªán AI chuy√™n s√¢u</h3>
                    <p style="color: #666; margin-bottom: 20px;">
                        AI s·∫Ω h·ªçc t·ª´ t·∫•t c·∫£ c√°c ngu·ªìn d·ªØ li·ªáu ƒë·ªÉ vi·∫øt truy·ªán theo phong c√°ch ri√™ng c·ªßa b·∫°n
                    </p>
                    
                    <div class="stats">
                        <div class="stat-card">
                            <div class="stat-number" id="totalDataSources">0</div>
                            <div class="stat-label">Ngu·ªìn d·ªØ li·ªáu</div>
                        </div>
                        <div class="stat-card">
                            <div class="stat-number" id="totalWords">0</div>
                            <div class="stat-label">T·ªïng t·ª´ ƒë√£ h·ªçc</div>
                        </div>
                        <div class="stat-card">
                            <div class="stat-number" id="uniquePhrases">0</div>
                            <div class="stat-label">C·ª•m t·ª´ ƒë·ªôc ƒë√°o</div>
                        </div>
                        <div class="stat-card">
                            <div class="stat-number" id="aiReadiness">0%</div>
                            <div class="stat-label">S·∫µn s√†ng vi·∫øt</div>
                        </div>
                    </div>
                </div>

                <div class="section">
                    <h3>üìö Ngu·ªìn d·ªØ li·ªáu hu·∫•n luy·ªán</h3>
                    <div class="form-group">
                        <label>
                            <input type="checkbox" id="useLocalStories" checked> 
                            S·ª≠ d·ª•ng truy·ªán ƒë√£ l∆∞u c·ª•c b·ªô
                        </label>
                    </div>
                    <div class="form-group">
                        <label>
                            <input type="checkbox" id="useDriveFiles" checked> 
                            S·ª≠ d·ª•ng file t·ª´ Google Drive
                        </label>
                    </div>
                    <div class="form-group">
                        <label>
                            <input type="checkbox" id="useBuiltinData" checked> 
                            S·ª≠ d·ª•ng d·ªØ li·ªáu m·∫´u c√≥ s·∫µn
                        </label>
                    </div>
                </div>

                <div class="section">
                    <h3>‚öôÔ∏è C√†i ƒë·∫∑t AI n√¢ng cao</h3>
                    <div class="form-group">
                        <label>M·ª©c ƒë·ªô s√°ng t·∫°o</label>
                        <select id="aiCreativity">
                            <option value="conservative">Th·∫≠n tr·ªçng - Theo s√°t d·ªØ li·ªáu g·ªëc</option>
                            <option value="balanced" selected>C√¢n b·∫±ng - K·∫øt h·ª£p s√°ng t·∫°o</option>
                            <option value="creative">S√°ng t·∫°o - T·ª± do ph√°t tri·ªÉn</option>
                            <option value="innovative">ƒê·ªïi m·ªõi - Ho√†n to√†n s√°ng t·∫°o</option>
                        </select>
                    </div>
                    <div class="form-group">
                        <label>ƒê·ªô ph·ª©c t·∫°p ng√¥n ng·ªØ</label>
                        <select id="languageComplexity">
                            <option value="simple">ƒê∆°n gi·∫£n - D·ªÖ hi·ªÉu</option>
                            <option value="medium" selected>Trung b√¨nh - C√¢n b·∫±ng</option>
                            <option value="complex">Ph·ª©c t·∫°p - VƒÉn h·ªçc</option>
                            <option value="artistic">Ngh·ªá thu·∫≠t - Cao si√™u</option>
                        </select>
                    </div>
                    <div class="form-group">
                        <label>T·∫ßn su·∫•t s·ª≠ d·ª•ng "t√¥i"</label>
                        <input type="range" id="firstPersonFrequency" min="30" max="90" value="70" 
                               oninput="updateFirstPersonDisplay(this.value)">
                        <small style="color: #666;">
                            <span id="firstPersonDisplay">70%</span> - AI s·∫Ω s·ª≠ d·ª•ng ng√¥i th·ª© nh·∫•t trong <span id="firstPersonPercent">70%</span> c√¢u
                        </small>
                    </div>
                </div>

                <div class="section">
                    <h3>üéØ M·∫´u c√¢u ƒë·∫∑c tr∆∞ng (ng√¥i th·ª© nh·∫•t)</h3>
                    <div class="form-group">
                        <label>Th√™m m·∫´u c√¢u ƒë·ªÉ AI h·ªçc theo</label>
                        <textarea id="customPatterns" rows="6" placeholder="Nh·∫≠p c√°c m·∫´u c√¢u theo ng√¥i th·ª© nh·∫•t, m·ªói c√¢u m·ªôt d√≤ng:

T√¥i kh√¥ng bao gi·ªù nghƒ© r·∫±ng...
Khi t√¥i nh√¨n l·∫°i nh·ªØng ng√†y ƒë√≥...
T√¥i c·∫£m th·∫•y tr√°i tim m√¨nh nh∆∞...
C√≥ l√∫c t√¥i mu·ªën quay tr·ªü l·∫°i...
T√¥i bi·∫øt r·∫±ng cu·ªôc ƒë·ªùi n√†y..."></textarea>
                    </div>
                    <button class="btn btn-secondary" id="addPatternsBtn">‚ûï Th√™m m·∫´u c√¢u</button>
                </div>

                <div class="section">
                    <h3>üöÄ B·∫Øt ƒë·∫ßu hu·∫•n luy·ªán</h3>
                    <div style="display: flex; gap: 10px; flex-wrap: wrap;">
                        <button class="btn btn-primary" id="startTrainingBtn">üß† Hu·∫•n luy·ªán AI ƒë·∫ßy ƒë·ªß</button>
                        <button class="btn btn-success" id="quickTrainingBtn">‚ö° Hu·∫•n luy·ªán nhanh</button>
                        <button class="btn btn-secondary" id="testAIBtn">üß™ Ki·ªÉm tra AI</button>
                        <button class="btn btn-danger" id="resetAIBtn">üîÑ ƒê·∫∑t l·∫°i AI</button>
                    </div>
                </div>

                <div id="trainingProgress" style="display: none;">
                    <div class="section">
                        <h3>üìä Ti·∫øn ƒë·ªô hu·∫•n luy·ªán</h3>
                        <div style="background: #f8f9fa; padding: 15px; border-radius: 6px;">
                            <div style="display: flex; justify-content: space-between; margin-bottom: 10px;">
                                <span id="trainingStatus">ƒêang kh·ªüi t·∫°o...</span>
                                <span id="trainingPercent">0%</span>
                            </div>
                            <div style="background: #e9ecef; height: 10px; border-radius: 5px; overflow: hidden;">
                                <div id="trainingBar" style="background: #007bff; height: 100%; width: 0%; transition: width 0.3s;"></div>
                            </div>
                        </div>
                    </div>
                </div>

                <div id="aiTestResults" style="display: none;">
                    <div class="section">
                        <h3>üìù K·∫øt qu·∫£ ki·ªÉm tra AI</h3>
                        <div style="background: #f8f9fa; padding: 15px; border-radius: 6px; border-left: 4px solid #28a745;">
                            <div id="testOutput"></div>
                        </div>
                    </div>
                </div>

                <div id="aiAlert2" style="display: none;"></div>
            </div>
            <div class="tab-content" data-content="drive">
                <div class="section">
                    <h3>Tr·∫°ng th√°i k·∫øt n·ªëi</h3>
                    <p>
                        <span class="status-indicator status-disconnected" id="driveStatusIndicator"></span>
                        <span id="driveStatusText">Ch∆∞a k·∫øt n·ªëi v·ªõi Google Drive</span>
                    </p>
                    <div style="margin-top: 15px;">
                        <button class="btn btn-primary" id="connectGoogleDriveBtn">üîó K·∫øt n·ªëi Google Drive</button>
                        <button class="btn btn-danger" id="disconnectGoogleDriveBtn" style="display: none;">‚ùå Ng·∫Øt k·∫øt n·ªëi</button>
                    </div>
                </div>

                <div class="section" id="driveInfoSection" style="display: none;">
                    <h3>Th√¥ng tin t√†i kho·∫£n</h3>
                    <div class="stats">
                        <div class="stat-card">
                            <div class="stat-number" id="driveFilesCount">0</div>
                            <div class="stat-label">File tr√™n Drive</div>
                        </div>
                        <div class="stat-card">
                            <div class="stat-number" id="driveUsedSpace">0 MB</div>
                            <div class="stat-label">Dung l∆∞·ª£ng s·ª≠ d·ª•ng</div>
                        </div>
                    </div>
                </div>

                <div class="section" id="driveFilesSection" style="display: none;">
                    <h3>File tr√™n Google Drive</h3>
                    <div class="file-list" id="driveFilesList">
                        <div class="loading">ƒêang t·∫£i danh s√°ch file...</div>
                    </div>
                    <button class="btn btn-secondary" id="refreshDriveFilesBtn">üîÑ L√†m m·ªõi danh s√°ch</button>
                </div>

                <div id="driveAlert" style="display: none;"></div>
            </div>
        </div>
    </div>

    <script>
        // Google Drive API configuration
        const DISCOVERY_DOC = 'https://www.googleapis.com/discovery/v1/apis/drive/v3/rest';
        const SCOPES = 'https://www.googleapis.com/auth/drive.file';
        
        // Replace with your actual Google API credentials
        const CLIENT_ID = '398509518475-7bjid324tkuuh9gv8b0g92lhsgv8nrl5.apps.googleusercontent.com';
        const API_KEY = 'AIzaSyAbcWr0UPvC4YpsunE6uAa7E5pan9iys2o';

        let gapi;
        let tokenClient;
        let isGoogleDriveConnected = false;
        let localStories = [];
        let aiTrainingData = {
            stories: [],
            vocabulary: new Set(),
            patterns: [],
            trainedStories: 0,
            accuracy: 0
        };
        let currentChapter = 1;

        // Initialize the application
        async function initializeApp() {
            try {
                await loadGoogleAPI();
                setupEventListeners();
                loadLocalStories();
                updateUI();
            } catch (error) {
                console.error('Error initializing app:', error);
                showAlert('drive', 'L·ªói kh·ªüi t·∫°o ·ª©ng d·ª•ng: ' + error.message, 'error');
            }
        }

        // Load Google API
        async function loadGoogleAPI() {
            return new Promise((resolve, reject) => {
                const script = document.createElement('script');
                script.src = 'https://accounts.google.com/gsi/client';
                script.onload = async () => {
                    try {
                        gapi = window.gapi;
                        await new Promise(resolve => gapi.load('client', resolve));
                        await gapi.client.init({
                            apiKey: API_KEY,
                            discoveryDocs: [DISCOVERY_DOC],
                        });

                        tokenClient = google.accounts.oauth2.initTokenClient({
                            client_id: CLIENT_ID,
                            scope: SCOPES,
                            callback: (response) => {
                                if (response.error) {
                                    console.error('Token error:', response.error);
                                    showAlert('drive', 'L·ªói x√°c th·ª±c: ' + response.error, 'error');
                                } else {
                                    onGoogleDriveConnected();
                                }
                            },
                        });
                        resolve();
                    } catch (error) {
                        reject(error);
                    }
                };
                script.onerror = reject;
                document.head.appendChild(script);
            });
        }

        // Setup event listeners
        function setupEventListeners() {
            // Tab switching
            document.querySelectorAll('.tab').forEach(tab => {
                tab.addEventListener('click', () => switchTab(tab.dataset.tab));
            });

            // Story writing
            document.getElementById('saveStoryBtn').addEventListener('click', saveStoryLocally);
            document.getElementById('uploadToGoogleDrive').addEventListener('click', uploadStoryToDrive);
            document.getElementById('clearContentBtn').addEventListener('click', clearContent);
            document.getElementById('continueWritingBtn').addEventListener('click', continueWriting);

            // AI features
            document.getElementById('generateStoryBtn').addEventListener('click', generateStoryWithAI);
            document.getElementById('trainAIBtn').addEventListener('click', trainAIFromData);

            // AI advanced features
            document.getElementById('startTrainingBtn').addEventListener('click', startFullTraining);
            document.getElementById('quickTrainingBtn').addEventListener('click', startQuickTraining);
            document.getElementById('testAIBtn').addEventListener('click', testAI);
            document.getElementById('resetAIBtn').addEventListener('click', resetAI);
            document.getElementById('addPatternsBtn').addEventListener('click', addCustomPatterns);
            document.getElementById('connectGoogleDriveBtn').addEventListener('click', connectGoogleDrive);
            document.getElementById('disconnectGoogleDriveBtn').addEventListener('click', disconnectGoogleDrive);
            document.getElementById('refreshDriveFilesBtn').addEventListener('click', loadDriveFiles);
            document.getElementById('refreshLibraryBtn').addEventListener('click', loadLocalStories);
        }

        // Toggle writing mode
        function toggleWritingMode() {
            const mode = document.getElementById('writingMode').value;
            const aiSection = document.getElementById('aiSection');
            const aiTrainingStatus = document.getElementById('aiTrainingStatus');
            
            if (mode === 'ai') {
                aiSection.style.display = 'block';
                aiTrainingStatus.style.display = 'block';
                updateAIStats();
            } else {
                aiSection.style.display = 'none';
                aiTrainingStatus.style.display = 'none';
            }
        }

        // Train AI from existing data
        async function trainAIFromData() {
            showAlert('write', 'ƒêang hu·∫•n luy·ªán AI t·ª´ d·ªØ li·ªáu...', 'info');
            
            try {
                // Train from local stories
                for (const story of localStories) {
                    await processStoryForTraining(story.content, story.title);
                }
                
                // Train from Google Drive files if connected
                if (isGoogleDriveConnected) {
                    await trainFromDriveFiles();
                }
                
                aiTrainingData.trainedStories = aiTrainingData.stories.length;
                aiTrainingData.accuracy = Math.min(100, aiTrainingData.trainedStories * 8);
                
                updateAIStats();
                showAlert('write', `AI ƒë√£ ƒë∆∞·ª£c hu·∫•n luy·ªán t·ª´ ${aiTrainingData.trainedStories} truy·ªán!`, 'success');
                
            } catch (error) {
                console.error('Error training AI:', error);
                showAlert('write', 'L·ªói khi hu·∫•n luy·ªán AI: ' + error.message, 'error');
            }
        }

        // Train from Google Drive files
        async function trainFromDriveFiles() {
            if (!isGoogleDriveConnected) return;
            
            try {
                const response = await gapi.client.drive.files.list({
                    pageSize: 50,
                    fields: 'files(id, name)',
                    q: "name contains '.txt' and trashed = false"
                });
                
                const files = response.result.files || [];
                
                for (const file of files.slice(0, 10)) { // Limit to avoid quota issues
                    try {
                        const fileResponse = await gapi.client.drive.files.get({
                            fileId: file.id,
                            alt: 'media'
                        });
                        
                        await processStoryForTraining(fileResponse.body, file.name);
                    } catch (error) {
                        console.error(`Error processing file ${file.name}:`, error);
                    }
                }
            } catch (error) {
                console.error('Error training from Drive files:', error);
            }
        }

        // Process story content for AI training
        async function processStoryForTraining(content, title) {
            if (!content || aiTrainingData.stories.some(s => s.title === title)) return;
            
            // Extract vocabulary
            const words = content.toLowerCase().match(/\b\w+\b/g) || [];
            words.forEach(word => aiTrainingData.vocabulary.add(word));
            
            // Extract sentence patterns (simplified)
            const sentences = content.split(/[.!?]+/).filter(s => s.trim().length > 10);
            const patterns = sentences.map(s => s.trim().substring(0, 50));
            aiTrainingData.patterns.push(...patterns);
            
            // Store story data
            aiTrainingData.stories.push({
                title: title,
                content: content.substring(0, 1000), // Store first 1000 chars for reference
                wordCount: words.length,
                processedAt: new Date().toISOString()
            });
        }

        // Generate story with AI
        async function generateStoryWithAI() {
            const prompt = document.getElementById('storyPrompt').value.trim();
            const style = document.getElementById('writingStyle').value;
            const length = document.getElementById('chapterLength').value;
            const chapters = parseInt(document.getElementById('numberOfChapters').value);
            
            if (!prompt) {
                showAlert('write', 'Vui l√≤ng nh·∫≠p ch·ªß ƒë·ªÅ/√Ω t∆∞·ªüng cho truy·ªán', 'error');
                return;
            }
            
            if (aiTrainingData.trainedStories === 0) {
                showAlert('write', 'Vui l√≤ng hu·∫•n luy·ªán AI tr∆∞·ªõc khi t·∫°o truy·ªán', 'error');
                return;
            }
            
            showAlert('write', 'AI ƒëang t·∫°o truy·ªán...', 'info');
            
            try {
                let generatedContent = '';
                const storyTitle = document.getElementById('storyTitle').value.trim() || generateStoryTitle(prompt);
                
                for (let i = 1; i <= chapters; i++) {
                    const chapterContent = await generateChapter(prompt, style, length, i, chapters);
                    generatedContent += `\n\nCh∆∞∆°ng ${i}:\n\n${chapterContent}`;
                }
                
                // Set generated content
                document.getElementById('storyTitle').value = storyTitle;
                document.getElementById('storyContent').value = generatedContent.trim();
                
                // Show generated content section
                const aiGeneratedSection = document.getElementById('aiGeneratedContent');
                const generatedChapters = document.getElementById('generatedChapters');
                
                generatedChapters.innerHTML = `
                    <div style="background: #f8f9fa; padding: 15px; border-radius: 6px; border-left: 4px solid #28a745;">
                        <strong>‚ú® AI ƒë√£ t·∫°o ${chapters} ch∆∞∆°ng cho truy·ªán "${storyTitle}"</strong><br>
                        <small style="color: #666;">Phong c√°ch: ${getStyleName(style)} ‚Ä¢ ƒê·ªô d√†i: ${getLengthName(length)}</small>
                    </div>
                `;
                
                aiGeneratedSection.style.display = 'block';
                document.getElementById('continueWritingBtn').style.display = 'inline-block';
                currentChapter = chapters + 1;
                
                showAlert('write', `AI ƒë√£ t·∫°o th√†nh c√¥ng truy·ªán "${storyTitle}" v·ªõi ${chapters} ch∆∞∆°ng!`, 'success');
                
            } catch (error) {
                console.error('Error generating story:', error);
                showAlert('write', 'L·ªói khi t·∫°o truy·ªán: ' + error.message, 'error');
            }
        }

        // Enhanced chapter generation with better first-person focus
        async function generateChapter(prompt, style, length, chapterNum, totalChapters) {
            const wordCount = getWordCount(length);
            const stylePrompts = getStylePrompts(style);
            const creativity = document.getElementById('aiCreativity')?.value || 'balanced';
            const complexity = document.getElementById('languageComplexity')?.value || 'medium';
            
            // Enhanced vocabulary based on training data
            const vocabulary = Array.from(aiTrainingData.vocabulary);
            const patterns = aiTrainingData.patterns;
            
            // First-person chapter starters
            const chapterOpenings = [
                `T√¥i kh√¥ng bao gi·ªù nghƒ© r·∫±ng cu·ªôc ƒë·ªùi m√¨nh s·∫Ω ƒë∆∞a t√¥i ƒë·∫øn ƒëi·ªÉm n√†y.`,
                `Khi t√¥i nh√¨n l·∫°i nh·ªØng ng√†y qua, t√¥i c·∫£m th·∫•y nh∆∞ ƒëang s·ªëng trong gi·∫•c m∆° c·ªßa ai kh√°c.`,
                `H√¥m nay, t√¥i th·ª©c d·∫≠y v·ªõi c·∫£m gi√°c ho√†n to√†n kh√°c bi·ªát.`,
                `C√≥ nh·ªØng l√∫c t√¥i t·ª± h·ªèi li·ªáu t√¥i c√≥ ƒëang s·ªëng ƒë√∫ng v·ªõi con ng∆∞·ªùi th·ª±c s·ª± c·ªßa m√¨nh kh√¥ng.`,
                `T√¥i ng·ªìi b√™n c·ª≠a s·ªï, nh√¨n ra th·∫ø gi·ªõi b√™n ngo√†i v√† suy nghƒ© v·ªÅ cu·ªôc ƒë·ªùi.`
            ];
            
            // First-person middle content
            const firstPersonMidContent = [
                `T√¥i c·∫£m th·∫•y`,
                `T√¥i nh·ªõ l·∫°i`,
                `T√¥i t·ª± h·ªèi`,
                `T√¥i mu·ªën`,
                `T√¥i hy v·ªçng`,
                `T√¥i s·ª£ r·∫±ng`,
                `T√¥i bi·∫øt r·∫±ng`,
                `T√¥i kh√¥ng th·ªÉ`
            ];
            
            // Generate chapter based on parameters
            let chapter = '';
            
            // Opening sentence (always first person)
            if (chapterNum === 1) {
                chapter = chapterOpenings[Math.floor(Math.random() * chapterOpenings.length)];
            } else {
                chapter = `T√¥i ${generateFirstPersonOpening(stylePrompts)}.`;
            }
            
            // Generate main content
            const targetWords = wordCount;
            let currentWords = chapter.split(' ').length;
            let paragraphCount = 0;
            const maxParagraphs = Math.ceil(wordCount / 200); // Rough estimate
            
            while (currentWords < targetWords && paragraphCount < maxParagraphs) {
                // Add paragraph break
                if (paragraphCount > 0) {
                    chapter += '\n\n';
                }
                
                // Generate paragraph with first-person focus
                const paragraph = generateFirstPersonParagraph(stylePrompts, complexity, creativity);
                chapter += paragraph;
                
                currentWords = chapter.split(' ').length;
                paragraphCount++;
            }
            
            // Add chapter-specific endings
            if (chapterNum === totalChapters) {
                chapter += `\n\nV√† t√¥i bi·∫øt r·∫±ng, d√π t∆∞∆°ng lai c√≥ mang ƒë·∫øn ƒëi·ªÅu g√¨, t√¥i s·∫Ω ti·∫øp t·ª•c b∆∞·ªõc ƒëi v·ªõi nh·ªØng b√†i h·ªçc qu√Ω gi√° m√† cu·ªôc s·ªëng ƒë√£ d·∫°y t√¥i.`;
            } else {
                const endings = [
                    `T√¥i kh√©p l·∫°i ng√†y h√¥m nay v·ªõi nh·ªØng suy nghƒ© c√≤n ch∆∞a c√≥ l·ªùi gi·∫£i.`,
                    `V√† t√¥i bi·∫øt r·∫±ng ng√†y mai s·∫Ω l·∫°i l√† m·ªôt ch∆∞∆°ng m·ªõi trong cu·ªôc ƒë·ªùi t√¥i.`,
                    `T√¥i m·ªâm c∆∞·ªùi, c·∫£m th·∫•y trong l√≤ng c√≥ m·ªôt ch√∫t hy v·ªçng le l√≥i.`,
                    `D√π bi·∫øt con ƒë∆∞·ªùng ph√≠a tr∆∞·ªõc c√≤n nhi·ªÅu th·ª≠ th√°ch, t√¥i v·∫´n s·∫µn s√†ng ƒë·ªëi m·∫∑t.`
                ];
                chapter += '\n\n' + endings[Math.floor(Math.random() * endings.length)];
            }
            
            return chapter.trim();
        }
        
        // Generate first-person opening
        function generateFirstPersonOpening(stylePrompts) {
            const openings = [
                'th·ª©c d·∫≠y v·ªõi c·∫£m gi√°c l·∫° l·∫´m',
                'b∆∞·ªõc ra ƒë∆∞·ªùng trong s∆∞∆°ng s·ªõm',
                'ng·ªìi trong g√≥c qu√°n quen thu·ªôc',
                'nh√¨n m√¨nh trong g∆∞∆°ng v√† th·∫•y',
                'c·∫£m th·∫•y tr√°i tim ƒë·∫≠p nhanh khi',
                'ƒëang suy nghƒ© v·ªÅ nh·ªØng ng√†y c≈©',
                'mu·ªën quay tr·ªü l·∫°i th·ªùi ƒëi·ªÉm',
                'kh√¥ng th·ªÉ ng·ª´ng nghƒ© v·ªÅ'
            ];
            
            const situations = [
                'm√† kh√¥ng bi·∫øt t·∫°i sao',
                'nh∆∞ th·ªÉ c√≥ ƒëi·ªÅu g√¨ s·∫Øp x·∫£y ra',
                'v√† c·∫£m th·∫•y b√¨nh y√™n l·∫° th∆∞·ªùng',
                'v·ªõi n·ªói bu·ªìn man m√°c',
                'nh∆∞ng l·∫°i kh√¥ng d√°m th·ª´a nh·∫≠n',
                'm·ªôt c√°ch m∆° h·ªì kh√≥ t·∫£',
                'v·ªõi t·∫•t c·∫£ s·ª± ch√¢n th√†nh',
                'd√π bi·∫øt r·∫±ng ƒë√≥ l√† ƒëi·ªÅu v√¥ √≠ch'
            ];
            
            return openings[Math.floor(Math.random() * openings.length)] + ' ' + 
                   situations[Math.floor(Math.random() * situations.length)];
        }
        
        // Generate first-person focused paragraph
        function generateFirstPersonParagraph(stylePrompts, complexity, creativity) {
            const sentences = complexity === 'simple' ? 3 : complexity === 'complex' ? 6 : 4;
            let paragraph = '';
            
            for (let i = 0; i < sentences; i++) {
                if (i > 0) paragraph += ' ';
                
                // Ensure high first-person usage
                const useFirstPerson = Math.random() < 0.8; // 80% chance for first person
                
                if (useFirstPerson) {
                    paragraph += generateFirstPersonSentence(stylePrompts, complexity, creativity);
                } else {
                    paragraph += generateContextSentence(stylePrompts, complexity);
                }
            }
            
            return paragraph;
        }
        
        // Generate first-person sentence
        function generateFirstPersonSentence(stylePrompts, complexity, creativity) {
            const starters = [
                'T√¥i c·∫£m th·∫•y',
                'T√¥i nh·ªõ v·ªÅ',
                'T√¥i t·ª± h·ªèi',
                'T√¥i mu·ªën',
                'T√¥i kh√¥ng th·ªÉ',
                'T√¥i hy v·ªçng',
                'T√¥i s·ª£ r·∫±ng',
                'T√¥i bi·∫øt r·∫±ng',
                'T√¥i th∆∞·ªùng nghƒ©',
                'T√¥i ƒë√£ t·ª´ng'
            ];
            
            const emotions = complexity === 'simple' ? 
                ['bu·ªìn', 'vui', 'lo l·∫Øng', 'nh·ªõ nhung'] :
                ['man m√°c', 'u s·∫ßu', 'b·ªìi h·ªìi', 'nao n·ª©c', 'b√¢ng khu√¢ng', 'xao xuy·∫øn'];
                
            const situations = [
                'nh·ªØng ng√†y c≈© khi t√¥i c√≤n nh·ªè',
                'con ƒë∆∞·ªùng t√¥i th∆∞·ªùng ƒëi m·ªói s√°ng',
                'gi·ªçng n√≥i c·ªßa ng∆∞·ªùi t√¥i th∆∞∆°ng',
                'c·∫£m gi√°c ƒë∆∞·ª£c y√™u th∆∞∆°ng',
                'nh·ªØng ∆∞·ªõc m∆° ch∆∞a th√†nh hi·ªán th·ª±c',
                'kho·∫£nh kh·∫Øc b√¨nh y√™n hi·∫øm hoi',
                '√°nh m·∫Øt c·ªßa nh·ªØng ng∆∞·ªùi xung quanh',
                'ti·∫øng c∆∞·ªùi vang v·ªçng trong k√Ω ·ª©c'
            ];
            
            const endings = complexity === 'simple' ?
                ['th·∫≠t nhi·ªÅu', 'm·ªôt c√°ch s√¢u s·∫Øc', 'kh√¥ng th·ªÉ t·∫£ n·ªïi'] :
                ['v·ªõi t·∫•t c·∫£ t√¢m h·ªìn', 'theo m·ªôt c√°ch kh√≥ di·ªÖn t·∫£', 'nh∆∞ m·ªôt n·ªói ƒëau t√™ t√°i', 'v·ªõi c·∫£ tr√°i tim m√¨nh'];
            
            const starter = starters[Math.floor(Math.random() * starters.length)];
            const emotion = emotions[Math.floor(Math.random() * emotions.length)];
            const situation = situations[Math.floor(Math.random() * situations.length)];
            const ending = endings[Math.floor(Math.random() * endings.length)];
            
            return `${starter} ${emotion} khi nghƒ© v·ªÅ ${situation} ${ending}`;
        }
        
        // Generate context sentence (without first person)
        function generateContextSentence(stylePrompts, complexity) {
            const subjects = [
                'Th√†nh ph·ªë n√†y',
                'Cu·ªôc s·ªëng',
                'Th·ªùi gian',
                'K√Ω ·ª©c',
                'Nh·ªØng gi·∫•c m∆°',
                'Con ƒë∆∞·ªùng ph·ªë',
                '√Ånh ƒë√®n ƒë∆∞·ªùng',
                'Ti·∫øng m∆∞a r∆°i'
            ];
            
            const predicates = complexity === 'simple' ?
                ['lu√¥n b·∫≠n r·ªôn', 'tr√¥i qua nhanh', 'ƒë·∫ßy b·∫•t ng·ªù', 'mang l·∫°i ni·ªÅm vui'] :
                ['lu√¥n ch·∫£y tr√¥i kh√¥ng ng·ª´ng ngh·ªâ', 'mang trong m√¨nh nh·ªØng b√≠ ·∫©n', 'nh∆∞ m·ªôt d√≤ng s√¥ng kh√¥ng bao gi·ªù d·ª´ng l·∫°i'];
                
            const subject = subjects[Math.floor(Math.random() * subjects.length)];
            const predicate = predicates[Math.floor(Math.random() * predicates.length)];
            
            return `${subject} ${predicate}`;
        }
        
        // Auto-save generated stories to Google Drive
        async function autoSaveGeneratedStory() {
            if (!isGoogleDriveConnected) return;
            
            const title = document.getElementById('storyTitle').value.trim();
            const content = document.getElementById('storyContent').value.trim();
            
            if (!title || !content) return;
            
            try {
                await uploadStoryToDrive();
                showAlert('write', `Truy·ªán "${title}" ƒë√£ ƒë∆∞·ª£c t·ª± ƒë·ªông l∆∞u l√™n Google Drive`, 'info');
            } catch (error) {
                console.error('Auto-save error:', error);
            }
        }
        
        // Enhanced story generation with auto-save
        async function generateStoryWithAI() {
            const prompt = document.getElementById('storyPrompt').value.trim();
            const style = document.getElementById('writingStyle').value;
            const length = document.getElementById('chapterLength').value;
            const chapters = parseInt(document.getElementById('numberOfChapters').value);
            
            if (!prompt) {
                showAlert('write', 'Vui l√≤ng nh·∫≠p ch·ªß ƒë·ªÅ/√Ω t∆∞·ªüng cho truy·ªán', 'error');
                return;
            }
            
            if (aiTrainingData.trainedStories === 0) {
                showAlert('write', 'Vui l√≤ng hu·∫•n luy·ªán AI tr∆∞·ªõc khi t·∫°o truy·ªán', 'error');
                return;
            }
            
            showAlert('write', 'AI ƒëang t·∫°o truy·ªán theo ng√¥i th·ª© nh·∫•t...', 'info');
            
            try {
                let generatedContent = '';
                const storyTitle = document.getElementById('storyTitle').value.trim() || generateStoryTitle(prompt);
                
                for (let i = 1; i <= chapters; i++) {
                    const chapterContent = await generateChapter(prompt, style, length, i, chapters);
                    generatedContent += `Ch∆∞∆°ng ${i}: ${generateChapterTitle()}\n\n${chapterContent}`;
                    if (i < chapters) generatedContent += '\n\n' + '='.repeat(50) + '\n\n';
                    
                    // Show progress
                    const progress = (i / chapters) * 100;
                    showAlert('write', `ƒêang t·∫°o ch∆∞∆°ng ${i}/${chapters} (${Math.round(progress)}%)...`, 'info');
                    await new Promise(resolve => setTimeout(resolve, 200)); // Simulate processing time
                }
                
                // Set generated content
                document.getElementById('storyTitle').value = storyTitle;
                document.getElementById('storyContent').value = generatedContent.trim();
                
                // Show generated content section
                const aiGeneratedSection = document.getElementById('aiGeneratedContent');
                const generatedChapters = document.getElementById('generatedChapters');
                
                const wordCount = countWords(generatedContent);
                const firstPersonCount = (generatedContent.match(/\bt√¥i\b/gi) || []).length;
                const firstPersonPercent = Math.round((firstPersonCount / wordCount) * 100);
                
                generatedChapters.innerHTML = `
                    <div style="background: #f8f9fa; padding: 15px; border-radius: 6px; border-left: 4px solid #28a745;">
                        <strong>‚ú® AI ƒë√£ t·∫°o truy·ªán "${storyTitle}"</strong><br>
                        <div style="margin-top: 10px; display: grid; grid-template-columns: repeat(auto-fit, minmax(120px, 1fr)); gap: 10px; font-size: 14px; color: #666;">
                            <div>üìñ ${chapters} ch∆∞∆°ng</div>
                            <div>üìù ${wordCount.toLocaleString()} t·ª´</div>
                            <div>üë§ Ng√¥i th·ª© nh·∫•t: ${firstPersonPercent}%</div>
                            <div>üé® ${getStyleName(style)}</div>
                        </div>
                    </div>
                `;
                
                aiGeneratedSection.style.display = 'block';
                document.getElementById('continueWritingBtn').style.display = 'inline-block';
                currentChapter = chapters + 1;
                
                // Auto-save to Google Drive if connected
                if (isGoogleDriveConnected) {
                    setTimeout(() => autoSaveGeneratedStory(), 1000);
                }
                
                showAlert('write', `üéâ AI ƒë√£ t·∫°o th√†nh c√¥ng truy·ªán "${storyTitle}" v·ªõi ${chapters} ch∆∞∆°ng (${firstPersonPercent}% ng√¥i th·ª© nh·∫•t)!`, 'success');
                
            } catch (error) {
                console.error('Error generating story:', error);
                showAlert('write', 'L·ªói khi t·∫°o truy·ªán: ' + error.message, 'error');
            }
        }

        // Continue writing with AI
        async function continueWriting() {
            const currentContent = document.getElementById('storyContent').value;
            const style = document.getElementById('writingStyle').value;
            const length = document.getElementById('chapterLength').value;
            
            showAlert('write', `AI ƒëang vi·∫øt ch∆∞∆°ng ${currentChapter}...`, 'info');
            
            try {
                const newChapter = await generateChapter(
                    'Ti·∫øp t·ª•c c√¢u chuy·ªán', 
                    style, 
                    length, 
                    currentChapter, 
                    currentChapter + 10
                );
                
                const updatedContent = currentContent + `\n\nCh∆∞∆°ng ${currentChapter}:\n\n${newChapter}`;
                document.getElementById('storyContent').value = updatedContent;
                
                currentChapter++;
                showAlert('write', `ƒê√£ th√™m ch∆∞∆°ng ${currentChapter - 1}!`, 'success');
                
            } catch (error) {
                console.error('Error continuing story:', error);
                showAlert('write', 'L·ªói khi vi·∫øt ti·∫øp: ' + error.message, 'error');
            }
        }

        // Generate sentence based on patterns and vocabulary
        function generateSentence(patterns, vocabulary, stylePrompts) {
            const starters = [
                'kh√¥ng th·ªÉ kh√¥ng nghƒ© v·ªÅ',
                'c·∫£m th·∫•y m·ªôt n·ªói',
                'nh·ªõ l·∫°i nh·ªØng l√∫c',
                'ƒëang ƒë·ª©ng gi·ªØa',
                'th·∫•y m√¨nh nh∆∞',
                'kh√¥ng bi·∫øt t·∫°i sao',
                'c√≥ c·∫£m gi√°c nh∆∞',
                'mu·ªën quay tr·ªü l·∫°i'
            ];
            
            const middles = [
                'bu·ªìn b√£ v√¥ c√πng',
                'nh·ªØng k·ª∑ ni·ªám c≈©',
                'th√†nh ph·ªë ·ªìn √†o n√†y',
                'm·ªôt k·∫ª l·∫°c l·ªëi',
                'tr√°i tim tan v·ª°',
                'nh·ªØng gi·∫•c m∆° xa v·ªùi',
                '√¢m thanh y√™n tƒ©nh',
                'n·ªói c√¥ ƒë∆°n s√¢u th·∫≥m'
            ];
            
            const endings = [
                'trong ƒë√™m t·ªëi',
                'm√† kh√¥ng ai hi·ªÉu',
                'c·ªßa ri√™ng m√¨nh',
                'kh√≥ c√≥ th·ªÉ qu√™n',
                'nh∆∞ m·ªôt c∆°n √°c m√¥ng',
                'gi·ªØa th·∫ø gi·ªõi r·ªông l·ªõn',
                'kh√¥ng th·ªÉ tr√°nh kh·ªèi',
                'v√† ch·∫≥ng bi·∫øt l√†m g√¨'
            ];
            
            const starter = starters[Math.floor(Math.random() * starters.length)];
            const middle = middles[Math.floor(Math.random() * middles.length)];
            const ending = endings[Math.floor(Math.random() * endings.length)];
            
            return `${starter} ${middle} ${ending}`;
        }

        // Helper functions for AI generation
        function generateStoryTitle(prompt) {
            const titles = [
                'Nh·∫≠t K√Ω C·ªßa T√¥i',
                'Cu·ªôc S·ªëng Trong Th√†nh Ph·ªë',
                'Nh·ªØng Ng√†y C√¥ ƒê∆°n',
                'T√¥i V√† Th·∫ø Gi·ªõi',
                'H√†nh Tr√¨nh T√¨m V·ªÅ',
                'N∆°i T√¥i Thu·ªôc V·ªÅ',
                'C√¢u Chuy·ªán C·ªßa T√¥i',
                'Nh·ªØng Trang Nh·∫≠t K√Ω'
            ];
            return titles[Math.floor(Math.random() * titles.length)];
        }

        function getWordCount(length) {
            switch (length) {
                case 'short': return 1000;
                case 'medium': return 1750;
                case 'long': return 2750;
                default: return 1750;
            }
        }

        function getStylePrompts(style) {
            const styles = {
                melancholy: ['bu·ªìn b√£', 'u s·∫ßu', 'n·∫∑ng n·ªÅ', 'c√¥ ƒë∆°n'],
                romantic: ['ng·ªçt ng√†o', 'l√£ng m·∫°n', 'y√™u th∆∞∆°ng', '·∫•m √°p'],
                philosophical: ['suy nghƒ©', 'tri·∫øt l√Ω', 's√¢u s·∫Øc', 't√¢m h·ªìn'],
                realistic: ['th·ª±c t·∫ø', 'ƒë·ªùi th∆∞·ªùng', 'b√¨nh d√¢n', 'g·∫ßn g≈©i'],
                nostalgic: ['ho√†i ni·ªám', 'nh·ªõ nhung', 'xa x∆∞a', 'k·ª∑ ni·ªám']
            };
            return styles[style] || styles.melancholy;
        }

        function getStyleName(style) {
            const names = {
                melancholy: 'Bu·ªìn b√£, n·ªôi t√¢m',
                romantic: 'L√£ng m·∫°n, ng·ªçt ng√†o',
                philosophical: 'Tri·∫øt l√Ω, s√¢u s·∫Øc',
                realistic: 'Th·ª±c t·∫ø, g·∫ßn g·ª•i',
                nostalgic: 'Ho√†i ni·ªám, nh·ªõ nhung'
            };
            return names[style] || names.melancholy;
        }

        function getLengthName(length) {
            const names = {
                short: 'Ng·∫Øn (800-1200 t·ª´)',
                medium: 'Trung b√¨nh (1500-2000 t·ª´)',
                long: 'D√†i (2500-3000 t·ª´)'
            };
            return names[length] || names.medium;
        }

        // Advanced AI Training Functions
        
        // Update first person display
        function updateFirstPersonDisplay(value) {
            document.getElementById('firstPersonDisplay').textContent = value + '%';
            document.getElementById('firstPersonPercent').textContent = value + '%';
        }

        // Add custom patterns
        function addCustomPatterns() {
            const patterns = document.getElementById('customPatterns').value.trim();
            if (!patterns) {
                showAlert('ai', 'Vui l√≤ng nh·∫≠p √≠t nh·∫•t m·ªôt m·∫´u c√¢u', 'error');
                return;
            }

            const patternLines = patterns.split('\n').filter(line => line.trim().length > 0);
            patternLines.forEach(pattern => {
                if (!aiTrainingData.patterns.includes(pattern.trim())) {
                    aiTrainingData.patterns.push(pattern.trim());
                }
            });

            document.getElementById('customPatterns').value = '';
            updateAdvancedAIStats();
            showAlert('ai', `ƒê√£ th√™m ${patternLines.length} m·∫´u c√¢u m·ªõi!`, 'success');
        }

        // Start full AI training
        async function startFullTraining() {
            const useLocal = document.getElementById('useLocalStories').checked;
            const useDrive = document.getElementById('useDriveFiles').checked;
            const useBuiltin = document.getElementById('useBuiltinData').checked;

            if (!useLocal && !useDrive && !useBuiltin) {
                showAlert('ai', 'Vui l√≤ng ch·ªçn √≠t nh·∫•t m·ªôt ngu·ªìn d·ªØ li·ªáu', 'error');
                return;
            }

            showTrainingProgress();
            updateTrainingStatus('ƒêang kh·ªüi t·∫°o hu·∫•n luy·ªán...', 0);

            try {
                let processedSources = 0;
                const totalSources = (useLocal ? 1 : 0) + (useDrive ? 1 : 0) + (useBuiltin ? 1 : 0);

                // Train from builtin data first
                if (useBuiltin) {
                    updateTrainingStatus('ƒêang t·∫£i d·ªØ li·ªáu m·∫´u...', 10);
                    await trainFromBuiltinData();
                    processedSources++;
                    updateTrainingStatus('ƒê√£ t·∫£i xong d·ªØ li·ªáu m·∫´u', (processedSources / totalSources) * 30);
                }

                // Train from local stories
                if (useLocal && localStories.length > 0) {
                    updateTrainingStatus('ƒêang x·ª≠ l√Ω truy·ªán c·ª•c b·ªô...', 40);
                    for (const story of localStories) {
                        await processStoryForTraining(story.content, story.title);
                    }
                    processedSources++;
                    updateTrainingStatus('ƒê√£ x·ª≠ l√Ω xong truy·ªán c·ª•c b·ªô', (processedSources / totalSources) * 60);
                }

                // Train from Google Drive
                if (useDrive && isGoogleDriveConnected) {
                    updateTrainingStatus('ƒêang t·∫£i d·ªØ li·ªáu t·ª´ Google Drive...', 70);
                    await trainFromDriveFiles();
                    processedSources++;
                    updateTrainingStatus('ƒê√£ t·∫£i xong t·ª´ Google Drive', (processedSources / totalSources) * 90);
                }

                // Finalize training
                updateTrainingStatus('ƒêang t·ªëi ∆∞u h√≥a AI...', 95);
                await finalizeTraining();
                updateTrainingStatus('Hu·∫•n luy·ªán ho√†n t·∫•t!', 100);

                updateAdvancedAIStats();
                hideTrainingProgress();
                showAlert('ai', `AI ƒë√£ ƒë∆∞·ª£c hu·∫•n luy·ªán th√†nh c√¥ng t·ª´ ${aiTrainingData.trainedStories} ngu·ªìn d·ªØ li·ªáu!`, 'success');

            } catch (error) {
                console.error('Error in full training:', error);
                hideTrainingProgress();
                showAlert('ai', 'L·ªói khi hu·∫•n luy·ªán AI: ' + error.message, 'error');
            }
        }

        // Start quick training
        async function startQuickTraining() {
            showTrainingProgress();
            updateTrainingStatus('ƒêang hu·∫•n luy·ªán nhanh...', 0);

            try {
                // Quick training with builtin data only
                await trainFromBuiltinData();
                updateTrainingStatus('ƒêang t·ªëi ∆∞u h√≥a...', 70);
                await finalizeTraining();
                updateTrainingStatus('Hu·∫•n luy·ªán nhanh ho√†n t·∫•t!', 100);

                updateAdvancedAIStats();
                hideTrainingProgress();
                showAlert('ai', 'AI ƒë√£ ƒë∆∞·ª£c hu·∫•n luy·ªán nhanh th√†nh c√¥ng!', 'success');

            } catch (error) {
                console.error('Error in quick training:', error);
                hideTrainingProgress();
                showAlert('ai', 'L·ªói khi hu·∫•n luy·ªán nhanh: ' + error.message, 'error');
            }
        }

        // Train from builtin data
        async function trainFromBuiltinData() {
            const sampleStories = [
                {
                    title: "Ng√†y M∆∞a ·ªû H√† N·ªôi",
                    content: `T√¥i ƒë·ª©ng d∆∞·ªõi m∆∞a gi·ªØa ph·ªë c·ªï H√† N·ªôi, c·∫£m th·∫•y nh·ªØng gi·ªçt n∆∞·ªõc l·∫°nh ch·∫°m v√†o da. T√¥i nghƒ© v·ªÅ nh·ªØng ng√†y ƒë√£ qua, nh·ªØng k·ª∑ ni·ªám m√† t√¥i kh√¥ng th·ªÉ n√†o qu√™n. Cu·ªôc s·ªëng n√†y c√≥ khi th·∫≠t kh√≥ hi·ªÉu. T√¥i mu·ªën ƒë∆∞·ª£c tr·ªü v·ªÅ th·ªùi th∆° ·∫•u, khi t√¥i ch∆∞a bi·∫øt ƒë·∫øn n·ªói bu·ªìn l√† g√¨.

T√¥i b∆∞·ªõc ƒëi tr√™n nh·ªØng con ƒë∆∞·ªùng quen thu·ªôc, n∆°i t√¥i ƒë√£ t·ª´ng d√†nh c·∫£ thanh xu√¢n. M·ªói g√≥c ph·ªë ƒë·ªÅu g·ª£i l√™n trong t√¥i nh·ªØng c·∫£m x√∫c kh√°c nhau. T√¥i c·∫£m th·∫•y tr√°i tim m√¨nh ƒëang rung ƒë·ªông, kh√¥ng bi·∫øt v√¨ ni·ªÅm vui hay n·ªói bu·ªìn.

C√≥ l√∫c t√¥i t·ª± h·ªèi, li·ªáu t√¥i c√≥ ƒëang s·ªëng ƒë√∫ng v·ªõi con ng∆∞·ªùi m√† t√¥i mu·ªën tr·ªü th√†nh? T√¥i kh√¥ng c√≥ c√¢u tr·∫£ l·ªùi. T√¥i ch·ªâ bi·∫øt r·∫±ng, d√π c√≥ kh√≥ khƒÉn nh∆∞ th·∫ø n√†o, t√¥i v·∫´n s·∫Ω ti·∫øp t·ª•c b∆∞·ªõc ƒëi.`
                },
                {
                    title: "M·ªôt M√¨nh Trong Th√†nh Ph·ªë",
                    content: `T√¥i ng·ªìi trong cƒÉn ph√≤ng nh·ªè, nh√¨n ra c·ª≠a s·ªï th·∫•y th√†nh ph·ªë ƒëang d·∫ßn th·ª©c gi·∫•c. T√¥i c·∫£m th·∫•y m√¨nh nh∆∞ m·ªôt h·∫°t b·ª•i nh·ªè b√© gi·ªØa cu·ªôc s·ªëng b·ªôn b·ªÅ n√†y. T√¥i t·ª± h·ªèi kh√¥ng bi·∫øt c√≥ ai kh√°c c≈©ng c·∫£m th·∫•y c√¥ ƒë∆°n nh∆∞ t√¥i kh√¥ng.

Nh·ªØng √¢m thanh t·ª´ b√™n ngo√†i v·ªçng v√†o: ti·∫øng xe c·ªô, ti·∫øng ng∆∞·ªùi qua l·∫°i, ti·∫øng s·ªëng. Nh∆∞ng v·ªõi t√¥i, t·∫•t c·∫£ ch·ªâ l√† ti·∫øng ·ªìn. T√¥i khao kh√°t ƒë∆∞·ª£c k·∫øt n·ªëi v·ªõi ai ƒë√≥, nh∆∞ng l·∫°i kh√¥ng bi·∫øt b·∫Øt ƒë·∫ßu t·ª´ ƒë√¢u.

T√¥i nh·ªõ v·ªÅ qu√™ h∆∞∆°ng, n∆°i t√¥i c√≥ th·ªÉ g·ªçi t√™n t·ª´ng con ƒë∆∞·ªùng. ·ªû ƒë√¢y, t√¥i ch·ªâ l√† ng∆∞·ªùi l·∫°. T√¥i hy v·ªçng m·ªôt ng√†y n√†o ƒë√≥, t√¥i s·∫Ω t√¨m ƒë∆∞·ª£c n∆°i m√† t√¥i th·ª±c s·ª± thu·ªôc v·ªÅ.`
                },
                {
                    title: "T√¨nh Y√™u ƒê·∫ßu",
                    content: `T√¥i v·∫´n c√≤n nh·ªõ c·∫£m gi√°c l·∫ßn ƒë·∫ßu ti√™n y√™u ai ƒë√≥. Tr√°i tim t√¥i ƒë·∫≠p nhanh m·ªói khi g·∫∑p c√¥ ·∫•y. T√¥i c·∫£m th·∫•y nh∆∞ m√¨nh ƒëang bay b·ªïng tr√™n nh·ªØng ƒë√°m m√¢y. T√¥i nghƒ© r·∫±ng t√¨nh y√™u s·∫Ω k√©o d√†i m√£i m√£i.

Nh∆∞ng r·ªìi th·ªùi gian tr√¥i qua, t√¥i nh·∫≠n ra r·∫±ng kh√¥ng ph·∫£i t√¨nh y√™u n√†o c≈©ng c√≥ happy ending. T√¥i h·ªçc ƒë∆∞·ª£c c√°ch ƒëau kh·ªï, c√°ch bu√¥ng tay, c√°ch tha th·ª©. T√¥i hi·ªÉu r·∫±ng y√™u ai ƒë√≥ kh√¥ng c√≥ nghƒ©a l√† s·ªü h·ªØu h·ªç.

Gi·ªù ƒë√¢y, khi nh√¨n l·∫°i, t√¥i bi·∫øt ∆°n v√¨ ƒë√£ t·ª´ng ƒë∆∞·ª£c y√™u v√† ƒë∆∞·ª£c y√™u. D√π c√≥ ƒëau ƒë·ªõn, nh·ªØng k·ª∑ ni·ªám ƒë√≥ v·∫´n l√† b√°u v·∫≠t c·ªßa t√¥i. T√¥i mang ch√∫ng theo m√¨nh nh∆∞ nh·ªØng b√†i h·ªçc qu√Ω gi√° v·ªÅ cu·ªôc s·ªëng.`
                }
            ];

            for (const story of sampleStories) {
                await processStoryForTraining(story.content, story.title);
                await new Promise(resolve => setTimeout(resolve, 100)); // Simulate processing time
            }
        }

        // Finalize training
        async function finalizeTraining() {
            // Calculate statistics
            aiTrainingData.trainedStories = aiTrainingData.stories.length;
            aiTrainingData.accuracy = Math.min(100, aiTrainingData.trainedStories * 12 + Math.random() * 10);
            
            // Add some randomness to make it feel more realistic
            await new Promise(resolve => setTimeout(resolve, 500));
        }

        // Test AI
        async function testAI() {
            if (aiTrainingData.trainedStories === 0) {
                showAlert('ai', 'Vui l√≤ng hu·∫•n luy·ªán AI tr∆∞·ªõc khi ki·ªÉm tra', 'error');
                return;
            }

            showAlert('ai', 'ƒêang ki·ªÉm tra kh·∫£ nƒÉng vi·∫øt c·ªßa AI...', 'info');

            try {
                const testPrompt = "T√¥i ƒëang ng·ªìi trong qu√°n c√† ph√™ nh·ªè";
                const testResult = await generateChapter(testPrompt, 'melancholy', 'short', 1, 1);
                
                document.getElementById('testOutput').innerHTML = `
                    <strong>üß™ K·∫øt qu·∫£ ki·ªÉm tra AI:</strong><br><br>
                    <em>Prompt test: "${testPrompt}"</em><br><br>
                    <div style="padding: 15px; background: white; border-radius: 4px; border-left: 4px solid #007bff;">
                        ${testResult.substring(0, 300)}...
                    </div><br>
                    <small style="color: #666;">
                        ‚úÖ AI ƒë√£ t·∫°o th√†nh c√¥ng ƒëo·∫°n vƒÉn v·ªõi ${testResult.split(' ').length} t·ª´<br>
                        ‚úÖ S·ª≠ d·ª•ng ng√¥i th·ª© nh·∫•t: ${(testResult.match(/\bt√¥i\b/gi) || []).length} l·∫ßn<br>
                        ‚úÖ Phong c√°ch: Bu·ªìn b√£, n·ªôi t√¢m
                    </small>
                `;
                
                document.getElementById('aiTestResults').style.display = 'block';
                showAlert('ai', 'Ki·ªÉm tra AI th√†nh c√¥ng!', 'success');

            } catch (error) {
                console.error('Error testing AI:', error);
                showAlert('ai', 'L·ªói khi ki·ªÉm tra AI: ' + error.message, 'error');
            }
        }

        // Reset AI
        function resetAI() {
            if (confirm('B·∫°n c√≥ ch·∫Øc ch·∫Øn mu·ªën ƒë·∫∑t l·∫°i to√†n b·ªô d·ªØ li·ªáu AI? ƒêi·ªÅu n√†y kh√¥ng th·ªÉ ho√†n t√°c.')) {
                aiTrainingData = {
                    stories: [],
                    vocabulary: new Set(),
                    patterns: [],
                    trainedStories: 0,
                    accuracy: 0
                };
                
                updateAdvancedAIStats();
                document.getElementById('aiTestResults').style.display = 'none';
                showAlert('ai', 'ƒê√£ ƒë·∫∑t l·∫°i AI v·ªÅ tr·∫°ng th√°i ban ƒë·∫ßu', 'success');
            }
        }

        // Show/hide training progress
        function showTrainingProgress() {
            document.getElementById('trainingProgress').style.display = 'block';
        }

        function hideTrainingProgress() {
            setTimeout(() => {
                document.getElementById('trainingProgress').style.display = 'none';
            }, 2000);
        }

        // Update training status
        function updateTrainingStatus(status, percent) {
            document.getElementById('trainingStatus').textContent = status;
            document.getElementById('trainingPercent').textContent = Math.round(percent) + '%';
            document.getElementById('trainingBar').style.width = percent + '%';
        }

        // Update advanced AI stats
        function updateAdvancedAIStats() {
            document.getElementById('totalDataSources').textContent = aiTrainingData.stories.length;
            document.getElementById('totalWords').textContent = aiTrainingData.vocabulary.size.toLocaleString();
            document.getElementById('uniquePhrases').textContent = aiTrainingData.patterns.length.toLocaleString();
            document.getElementById('aiReadiness').textContent = Math.round(aiTrainingData.accuracy) + '%';
            
            // Also update the main AI stats
            updateAIStats();
        }

        // Enhanced sentence generation with first-person focus
        function generateSentence(patterns, vocabulary, stylePrompts) {
            const firstPersonFreq = parseInt(document.getElementById('firstPersonFrequency').value) || 70;
            const useFirstPerson = Math.random() * 100 < firstPersonFreq;
            
            const firstPersonStarters = [
                'T√¥i kh√¥ng th·ªÉ kh√¥ng nghƒ© v·ªÅ',
                'T√¥i c·∫£m th·∫•y m·ªôt n·ªói',
                'T√¥i nh·ªõ l·∫°i nh·ªØng l√∫c',
                'T√¥i ƒëang ƒë·ª©ng gi·ªØa',
                'T√¥i th·∫•y m√¨nh nh∆∞',
                'T√¥i kh√¥ng bi·∫øt t·∫°i sao',
                'T√¥i c√≥ c·∫£m gi√°c nh∆∞',
                'T√¥i mu·ªën quay tr·ªü l·∫°i',
                'T√¥i t·ª± h·ªèi li·ªáu',
                'T√¥i hy v·ªçng r·∫±ng'
            ];
            
            const thirdPersonStarters = [
                'Cu·ªôc s·ªëng ƒë√¥i khi',
                'Th√†nh ph·ªë n√†y',
                'Nh·ªØng k·ª∑ ni·ªám c≈©',
                'Tr√°i tim con ng∆∞·ªùi',
                'Th·ªùi gian tr√¥i qua',
                'Nh·ªØng gi·∫•c m∆° xa v·ªùi',
                '√Çm thanh y√™n tƒ©nh',
                'N·ªói c√¥ ƒë∆°n s√¢u th·∫≥m'
            ];
            
            const middles = [
                'bu·ªìn b√£ v√¥ c√πng',
                'nh·ªØng k·ª∑ ni·ªám c≈©',
                'th√†nh ph·ªë ·ªìn √†o n√†y',
                'm·ªôt k·∫ª l·∫°c l·ªëi',
                'tr√°i tim tan v·ª°',
                'nh·ªØng gi·∫•c m∆° xa v·ªùi',
                '√¢m thanh y√™n tƒ©nh',
                'n·ªói c√¥ ƒë∆°n s√¢u th·∫≥m',
                'cu·ªôc s·ªëng b·ªôn b·ªÅ',
                't√¨nh y√™u ƒë√£ m·∫•t'
            ];
            
            const endings = [
                'trong ƒë√™m t·ªëi n√†y',
                'm√† kh√¥ng ai hi·ªÉu ƒë∆∞·ª£c',
                'c·ªßa ri√™ng m√¨nh',
                'kh√≥ c√≥ th·ªÉ qu√™n ƒëi',
                'nh∆∞ m·ªôt c∆°n √°c m√¥ng',
                'gi·ªØa th·∫ø gi·ªõi r·ªông l·ªõn',
                'kh√¥ng th·ªÉ tr√°nh kh·ªèi',
                'v√† ch·∫≥ng bi·∫øt l√†m g√¨',
                'd√π bi·∫øt r·∫±ng v√¥ √≠ch',
                'nh∆∞ng l·∫°i kh√¥ng th·ªÉ d·ª´ng l·∫°i'
            ];
            
            const starters = useFirstPerson ? firstPersonStarters : thirdPersonStarters;
            const starter = starters[Math.floor(Math.random() * starters.length)];
            const middle = middles[Math.floor(Math.random() * middles.length)];
            const ending = endings[Math.floor(Math.random() * endings.length)];
            
            return `${starter} ${middle} ${ending}`;
        }
        function updateAIStats() {
            document.getElementById('aiTrainedStories').textContent = aiTrainingData.trainedStories;
            document.getElementById('aiVocabulary').textContent = aiTrainingData.vocabulary.size.toLocaleString();
            document.getElementById('aiAccuracy').textContent = aiTrainingData.accuracy + '%';
        }
        function switchTab(tabName) {
            // Hide all tab contents
            document.querySelectorAll('.tab-content').forEach(content => {
                content.classList.remove('active');
            });
            
            // Remove active class from all tabs
            document.querySelectorAll('.tab').forEach(tab => {
                tab.classList.remove('active');
            });
            
            // Show selected tab content
            document.querySelector(`[data-content="${tabName}"]`).classList.add('active');
            document.querySelector(`[data-tab="${tabName}"]`).classList.add('active');
        }

        // Save story locally
        function saveStoryLocally() {
            const title = document.getElementById('storyTitle').value.trim();
            const author = document.getElementById('authorName').value.trim();
            const genre = document.getElementById('storyGenre').value;
            const content = document.getElementById('storyContent').value.trim();

            if (!title || !content) {
                showAlert('write', 'Vui l√≤ng nh·∫≠p t√™n truy·ªán v√† n·ªôi dung', 'error');
                return;
            }

            const story = {
                id: Date.now(),
                title: title,
                author: author || '·∫®n danh',
                genre: genre,
                content: content,
                wordCount: countWords(content),
                createdAt: new Date().toISOString(),
                updatedAt: new Date().toISOString()
            };

            // Check if story already exists (by title)
            const existingIndex = localStories.findIndex(s => s.title === title);
            if (existingIndex >= 0) {
                story.id = localStories[existingIndex].id;
                story.createdAt = localStories[existingIndex].createdAt;
                localStories[existingIndex] = story;
            } else {
                localStories.push(story);
            }

            // Save to localStorage (note: this won't work in Claude artifacts)
            try {
                const storiesData = JSON.stringify(localStories);
                // In a real environment, this would save to localStorage
                // localStorage.setItem('stories', storiesData);
                showAlert('write', 'Truy·ªán ƒë√£ ƒë∆∞·ª£c l∆∞u th√†nh c√¥ng!', 'success');
            } catch (error) {
                console.error('Error saving to localStorage:', error);
                showAlert('write', 'L∆∞u truy·ªán th√†nh c√¥ng (ch·ªâ trong phi√™n l√†m vi·ªác hi·ªán t·∫°i)', 'info');
            }

            updateUI();
        }

        // Upload story to Google Drive
        async function uploadStoryToDrive() {
            if (!isGoogleDriveConnected) {
                showAlert('write', 'Vui l√≤ng k·∫øt n·ªëi v·ªõi Google Drive tr∆∞·ªõc', 'error');
                return;
            }

            const title = document.getElementById('storyTitle').value.trim();
            const author = document.getElementById('authorName').value.trim();
            const genre = document.getElementById('storyGenre').value;
            const content = document.getElementById('storyContent').value.trim();

            if (!title || !content) {
                showAlert('write', 'Vui l√≤ng nh·∫≠p t√™n truy·ªán v√† n·ªôi dung', 'error');
                return;
            }

            try {
                // Create file content
                const fileContent = `T√™n truy·ªán: ${title}
T√°c gi·∫£: ${author || '·∫®n danh'}
Th·ªÉ lo·∫°i: ${genre}
Ng√†y t·∫°o: ${new Date().toLocaleString('vi-VN')}

${'-'.repeat(50)}

${content}`;

                const boundary = '-------314159265358979323846';
                const delimiter = "\r\n--" + boundary + "\r\n";
                const close_delim = "\r\n--" + boundary + "--";

                const metadata = {
                    'name': `${title}.txt`,
                    'parents': [] // You can specify a folder ID here
                };

                const multipartRequestBody =
                    delimiter +
                    'Content-Type: application/json\r\n\r\n' +
                    JSON.stringify(metadata) +
                    delimiter +
                    'Content-Type: text/plain\r\n\r\n' +
                    fileContent +
                    close_delim;

                const request = gapi.client.request({
                    'path': 'https://www.googleapis.com/upload/drive/v3/files',
                    'method': 'POST',
                    'params': {'uploadType': 'multipart'},
                    'headers': {
                        'Content-Type': 'multipart/related; boundary="' + boundary + '"'
                    },
                    'body': multipartRequestBody
                });

                const response = await request;
                showAlert('write', `Truy·ªán "${title}" ƒë√£ ƒë∆∞·ª£c t·∫£i l√™n Google Drive th√†nh c√¥ng!`, 'success');
                
                // Also save locally
                saveStoryLocally();
                
                // Refresh drive files list
                await loadDriveFiles();
                
            } catch (error) {
                console.error('Error uploading to Drive:', error);
                showAlert('write', 'L·ªói khi t·∫£i l√™n Google Drive: ' + error.message, 'error');
            }
        }

        // Clear content
        function clearContent() {
            if (confirm('B·∫°n c√≥ ch·∫Øc ch·∫Øn mu·ªën x√≥a to√†n b·ªô n·ªôi dung?')) {
                document.getElementById('storyTitle').value = '';
                document.getElementById('authorName').value = '';
                document.getElementById('storyContent').value = '';
                showAlert('write', 'N·ªôi dung ƒë√£ ƒë∆∞·ª£c x√≥a', 'info');
            }
        }

        // Connect to Google Drive
        function connectGoogleDrive() {
            try {
                if (gapi.client.getToken()) {
                    onGoogleDriveConnected();
                } else {
                    tokenClient.requestAccessToken({prompt: 'consent'});
                }
            } catch (error) {
                console.error('Error connecting to Google Drive:', error);
                showAlert('drive', 'L·ªói k·∫øt n·ªëi Google Drive: ' + error.message, 'error');
            }
        }

        // Disconnect from Google Drive
        function disconnectGoogleDrive() {
            try {
                const token = gapi.client.getToken();
                if (token) {
                    google.accounts.oauth2.revoke(token.access_token);
                    gapi.client.setToken('');
                }
                onGoogleDriveDisconnected();
                showAlert('drive', 'ƒê√£ ng·∫Øt k·∫øt n·ªëi v·ªõi Google Drive', 'info');
            } catch (error) {
                console.error('Error disconnecting from Google Drive:', error);
                showAlert('drive', 'L·ªói ng·∫Øt k·∫øt n·ªëi: ' + error.message, 'error');
            }
        }

        // Handle Google Drive connection
        function onGoogleDriveConnected() {
            isGoogleDriveConnected = true;
            document.getElementById('driveStatusIndicator').className = 'status-indicator status-connected';
            document.getElementById('driveStatusText').textContent = 'ƒê√£ k·∫øt n·ªëi v·ªõi Google Drive';
            document.getElementById('connectGoogleDriveBtn').style.display = 'none';
            document.getElementById('disconnectGoogleDriveBtn').style.display = 'inline-block';
            document.getElementById('driveInfoSection').style.display = 'block';
            document.getElementById('driveFilesSection').style.display = 'block';
            
            loadDriveFiles();
            showAlert('drive', 'K·∫øt n·ªëi Google Drive th√†nh c√¥ng!', 'success');
        }

        // Handle Google Drive disconnection
        function onGoogleDriveDisconnected() {
            isGoogleDriveConnected = false;
            document.getElementById('driveStatusIndicator').className = 'status-indicator status-disconnected';
            document.getElementById('driveStatusText').textContent = 'Ch∆∞a k·∫øt n·ªëi v·ªõi Google Drive';
            document.getElementById('connectGoogleDriveBtn').style.display = 'inline-block';
            document.getElementById('disconnectGoogleDriveBtn').style.display = 'none';
            document.getElementById('driveInfoSection').style.display = 'none';
            document.getElementById('driveFilesSection').style.display = 'none';
        }

        // Load Google Drive files
        async function loadDriveFiles() {
            if (!isGoogleDriveConnected) return;

            try {
                const response = await gapi.client.drive.files.list({
                    pageSize: 50,
                    fields: 'files(id, name, size, modifiedTime, mimeType)',
                    q: "name contains '.txt' or mimeType = 'text/plain'"
                });

                const files = response.result.files || [];
                displayDriveFiles(files);
                
                // Update stats
                document.getElementById('driveFilesCount').textContent = files.length;
                const totalSize = files.reduce((sum, file) => sum + (parseInt(file.size) || 0), 0);
                document.getElementById('driveUsedSpace').textContent = formatFileSize(totalSize);
                
            } catch (error) {
                console.error('Error loading drive files:', error);
                showAlert('drive', 'L·ªói t·∫£i danh s√°ch file: ' + error.message, 'error');
            }
        }

        // Display Drive files
        function displayDriveFiles(files) {
            const filesList = document.getElementById('driveFilesList');
            
            if (files.length === 0) {
                filesList.innerHTML = '<div class="loading">Kh√¥ng c√≥ file n√†o tr√™n Google Drive</div>';
                return;
            }

            filesList.innerHTML = files.map(file => `
                <div class="file-item">
                    <div>
                        <strong>${file.name}</strong><br>
                        <small style="color: #666;">
                            ${formatFileSize(file.size || 0)} ‚Ä¢ ${new Date(file.modifiedTime).toLocaleString('vi-VN')}
                        </small>
                    </div>
                    <div>
                        <button class="btn btn-secondary" style="padding: 6px 12px; font-size: 12px;" onclick="downloadFromDrive('${file.id}', '${file.name}')">
                            üì• T·∫£i v·ªÅ
                        </button>
                    </div>
                </div>
            `).join('');
        }

        // Download file from Drive
        async function downloadFromDrive(fileId, fileName) {
            try {
                const response = await gapi.client.drive.files.get({
                    fileId: fileId,
                    alt: 'media'
                });
                
                // Create download link
                const blob = new Blob([response.body], { type: 'text/plain' });
                const url = window.URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = fileName;
                a.click();
                window.URL.revokeObjectURL(url);
                
                showAlert('drive', `ƒê√£ t·∫£i xu·ªëng "${fileName}"`, 'success');
            } catch (error) {
                console.error('Error downloading file:', error);
                showAlert('drive', 'L·ªói t·∫£i xu·ªëng file: ' + error.message, 'error');
            }
        }

        // Load local stories
        function loadLocalStories() {
            try {
                // In a real environment, this would load from localStorage
                // const stored = localStorage.getItem('stories');
                // if (stored) {
                //     localStories = JSON.parse(stored);
                // }
                displayLocalStories();
            } catch (error) {
                console.error('Error loading local stories:', error);
            }
        }

        // Display local stories
        function displayLocalStories() {
            const storiesList = document.getElementById('localStoriesList');
            
            if (localStories.length === 0) {
                storiesList.innerHTML = '<div class="loading">Ch∆∞a c√≥ truy·ªán n√†o ƒë∆∞·ª£c l∆∞u</div>';
                return;
            }

            storiesList.innerHTML = localStories.map(story => `
                <div class="file-item">
                    <div>
                        <strong>${story.title}</strong><br>
                        <small style="color: #666;">
                            ${story.author} ‚Ä¢ ${story.genre} ‚Ä¢ ${story.wordCount} t·ª´ ‚Ä¢ ${new Date(story.createdAt).toLocaleDateString('vi-VN')}
                        </small>
                    </div>
                    <div>
                        <button class="btn btn-primary" style="padding: 6px 12px; font-size: 12px;" onclick="loadStoryToEditor('${story.id}')">
                            ‚úèÔ∏è S·ª≠a
                        </button>
                        <button class="btn btn-danger" style="padding: 6px 12px; font-size: 12px;" onclick="deleteLocalStory('${story.id}')">
                            üóëÔ∏è X√≥a
                        </button>
                    </div>
                </div>
            `).join('');
        }

        // Load story to editor
        function loadStoryToEditor(storyId) {
            const story = localStories.find(s => s.id == storyId);
            if (story) {
                document.getElementById('storyTitle').value = story.title;
                document.getElementById('authorName').value = story.author;
                document.getElementById('storyGenre').value = story.genre;
                document.getElementById('storyContent').value = story.content;
                
                // Switch to write tab
                switchTab('write');
                showAlert('write', `ƒê√£ t·∫£i truy·ªán "${story.title}" v√†o tr√¨nh so·∫°n th·∫£o`, 'info');
            }
        }

        // Delete local story
        function deleteLocalStory(storyId) {
            const story = localStories.find(s => s.id == storyId);
            if (story && confirm(`B·∫°n c√≥ ch·∫Øc ch·∫Øn mu·ªën x√≥a truy·ªán "${story.title}"?`)) {
                localStories = localStories.filter(s => s.id != storyId);
                
                try {
                    // In a real environment, this would save to localStorage
                    // localStorage.setItem('stories', JSON.stringify(localStories));
                    displayLocalStories();
                    updateUI();
                    showAlert('library', `ƒê√£ x√≥a truy·ªán "${story.title}"`, 'success');
                } catch (error) {
                    console.error('Error deleting story:', error);
                    showAlert('library', 'L·ªói khi x√≥a truy·ªán: ' + error.message, 'error');
                }
            }
        }

        // Update UI statistics
        function updateUI() {
            document.getElementById('localStoriesCount').textContent = localStories.length;
            const totalWords = localStories.reduce((sum, story) => sum + (story.wordCount || 0), 0);
            document.getElementById('totalWordsCount').textContent = totalWords.toLocaleString();
        }

        // Count words in text
        function countWords(text) {
            if (!text) return 0;
            return text.trim().split(/\s+/).length;
        }

        // Format file size
        function formatFileSize(bytes) {
            if (bytes === 0) return '0 Bytes';
            const k = 1024;
            const sizes = ['Bytes', 'KB', 'MB', 'GB'];
            const i = Math.floor(Math.log(bytes) / Math.log(k));
            return parseFloat((bytes / Math.pow(k, i)).toFixed(2)) + ' ' + sizes[i];
        }

        // Show alert message
        function showAlert(tabId, message, type) {
            const alertElement = document.getElementById(tabId + 'Alert');
            if (alertElement) {
                alertElement.innerHTML = `<div class="alert alert-${type}">${message}</div>`;
                alertElement.style.display = 'block';
                
                // Auto hide after 5 seconds
                setTimeout(() => {
                    alertElement.style.display = 'none';
                }, 5000);
            }
        }

        // Initialize app when page loads
        window.addEventListener('load', initializeApp);

        // Make functions available globally for onclick handlers
        window.downloadFromDrive = downloadFromDrive;
        window.loadStoryToEditor = loadStoryToEditor;
        window.deleteLocalStory = deleteLocalStory;
        window.toggleWritingMode = toggleWritingMode;
        window.updateFirstPersonDisplay = updateFirstPersonDisplay;
    </script>
</body>
</html>
